<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.7.1">
<title>Sessão 1: Instalação e configurações iniciais</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote::before{display:none}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{word-spacing:0;line-height:1.6}
.quoteblock.abstract blockquote::before,.quoteblock.abstract p::before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_sessão_1_instalação_e_configurações_iniciais">Sessão 1: Instalação e configurações iniciais</a>
<ul class="sectlevel2">
<li><a href="#_1_criação_de_máquina_virtual_no_virtualbox">1) Criação de máquina virtual no Virtualbox</a></li>
<li><a href="#_2_instalação_do_debian_linux">2) Instalação do Debian Linux</a></li>
<li><a href="#_3_ajustes_pós_instalação">3) Ajustes pós-instalação</a></li>
<li><a href="#_4_configuração_do_lvm">4) Configuração do LVM</a></li>
<li><a href="#_5_inserção_de_senha_no_bootloader">5) Inserção de senha no <strong><em>bootloader</em></strong></a></li>
<li><a href="#_6_clonando_máquinas_virtuais">6) Clonando máquinas virtuais</a></li>
<li><a href="#_7_operações_avançadas_com_lvm">7) Operações avançadas com LVM</a></li>
<li><a href="#_8_criptografia_de_partições">8) Criptografia de partições</a></li>
</ul>
</li>
<li><a href="#_sessão_2_firewall_e_dns">Sessão 2: Firewall e DNS</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão">1) Topologia desta sessão</a></li>
<li><a href="#_2_criação_da_vm_de_firewall_e_dns_primário">2) Criação da VM de firewall e DNS primário</a></li>
<li><a href="#_3_configuração_inicial_do_firewall">3) Configuração inicial do firewall</a></li>
<li><a href="#_4_configuração_do_servidor_dns_primário">4) Configuração do servidor DNS primário</a></li>
<li><a href="#_5_configuração_do_dnssec">5) Configuração do DNSSEC</a></li>
<li><a href="#_6_automatizando_assinatura_dnssec_após_alterações">6) Automatizando assinatura DNSSEC após alterações</a></li>
<li><a href="#_7_reconfiguração_da_vm_debian_template">7) Reconfiguração da VM <strong><em>debian-template</em></strong></a></li>
<li><a href="#_8_criação_da_vm_de_dns_secundário">8) Criação da VM de DNS secundário</a></li>
<li><a href="#_9_configuração_do_dns_secundário">9) Configuração do DNS secundário</a></li>
</ul>
</li>
<li><a href="#_sessão_3_autenticação_centralizada">Sessão 3: Autenticação centralizada</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão_2">1) Topologia desta sessão</a></li>
<li><a href="#_2_configuração_do_servidor_ldap">2) Configuração do servidor LDAP</a></li>
<li><a href="#_3_habilitando_logs_do_ldap">3) Habilitando logs do LDAP</a></li>
<li><a href="#_4_edição_de_índices_e_permissões_no_ldap">4) Edição de índices e permissões no LDAP</a></li>
<li><a href="#_5_adição_de_grupos_e_usuários_no_ldap">5) Adição de grupos e usuários no LDAP</a></li>
<li><a href="#_6_integração_e_teste_do_sistema_de_autenticação_com_ldap">6) Integração e teste do sistema de autenticação com LDAP</a></li>
<li><a href="#_7_configurando_uma_autoridade_certificadora_ca_para_o_ssh">7) Configurando uma autoridade certificadora (CA) para o SSH</a></li>
<li><a href="#_8_configurando_a_ssh_ca_no_servidor_ldap">8) Configurando a SSH-CA no servidor LDAP</a></li>
<li><a href="#_9_automatizando_a_assinatura_de_chaves_ssh_de_usuários">9) Automatizando a assinatura de chaves SSH de usuários</a></li>
<li><a href="#_10_configurando_o_template_para_funcionar_com_ldapssh_ca">10) Configurando o template para funcionar com LDAP/SSH-CA</a></li>
<li><a href="#_11_ajuste_das_regras_de_firewall">11) Ajuste das regras de firewall</a></li>
<li><a href="#_12_configurando_um_cliente_linux">12) Configurando um cliente Linux</a></li>
<li><a href="#_13_configurando_o_firewall_para_funcionar_com_ldapssh_ca">13) Configurando o firewall para funcionar com LDAP/SSH-CA</a></li>
<li><a href="#_14_restringindo_login_por_grupos_e_usuários">14) Restringindo login por grupos e usuários</a></li>
<li><a href="#_15_restringindo_logins_ssh_apenas_via_chaves_assimétricas">15) Restringindo logins SSH apenas via chaves assimétricas</a></li>
<li><a href="#_16_bloqueando_tentativas_de_brute_force_contra_o_ssh">16) Bloqueando tentativas de brute force contra o SSH</a></li>
</ul>
</li>
<li><a href="#_sessão_4_controles_de_segurança">Sessão 4: Controles de segurança</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão_3">1) Topologia desta sessão</a></li>
<li><a href="#_2_requisitos_de_senha_na_base_ldap">2) Requisitos de senha na base LDAP</a></li>
<li><a href="#_3_busca_de_senhas_fracas">3) Busca de senhas fracas</a></li>
<li><a href="#_4_criação_da_vm_do_servidor_de_arquivos_nfs">4) Criação da VM do servidor de arquivos NFS</a></li>
<li><a href="#_5_ajuste_das_regras_de_firewall">5) Ajuste das regras de firewall</a></li>
<li><a href="#_6_configuração_do_servidor_de_arquivos_nfs_e_quotas_de_disco">6) Configuração do servidor de arquivos NFS e quotas de disco</a></li>
<li><a href="#_7_uso_de_acls_localmente">7) Uso de ACLs localmente</a></li>
<li><a href="#_8_uso_de_acls_via_nfs">8) Uso de ACLs via NFS</a></li>
<li><a href="#_9_controle_granular_de_permissões_via_sudo">9) Controle granular de permissões via sudo</a></li>
</ul>
</li>
<li><a href="#_sessão_5_gestão_de_configuração">Sessão 5: Gestão de configuração</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão_4">1) Topologia desta sessão</a></li>
<li><a href="#_2_instalação_e_configuração_inicial_do_ansible">2) Instalação e configuração inicial do Ansible</a></li>
<li><a href="#_3_execução_de_comandos_simples">3) Execução de comandos simples</a></li>
<li><a href="#_4_uso_de_roles_no_ansible">4) Uso de roles no Ansible</a></li>
<li><a href="#_5_testando_os_controles_do_sudo">5) Testando os controles do sudo</a></li>
<li><a href="#_6_controle_da_senha_do_usuário_root">6) Controle da senha do usuário root</a></li>
<li><a href="#_6_versionamento_de_configuração_com_git">6) Versionamento de configuração com git</a></li>
</ul>
</li>
<li><a href="#_sessão_6_registro_e_correlacionamento_de_eventos">Sessão 6: Registro e correlacionamento de eventos</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão_5">1) Topologia desta sessão</a></li>
<li><a href="#_2_criação_da_vm_de_gestão_de_logs">2) Criação da VM de gestão de logs</a></li>
<li><a href="#_3_ajuste_das_regras_de_firewall_para_o_ntp">3) Ajuste das regras de firewall para o NTP</a></li>
<li><a href="#_4_configuração_do_ntp">4) Configuração do NTP</a></li>
<li><a href="#_5_registro_de_comandos_digitados_com_snoopylog">5) Registro de comandos digitados com SnoopyLog</a></li>
<li><a href="#_6_instalação_e_configuração_inicial_do_graylog">6) Instalação e configuração inicial do Graylog</a></li>
<li><a href="#_7_ajuste_das_regras_de_firewall_para_o_graylog">7) Ajuste das regras de firewall para o Graylog</a></li>
<li><a href="#_8_visualizando_logs_de_máquinas_no_graylog">8) Visualizando logs de máquinas no Graylog</a></li>
<li><a href="#_9_autenticação_centralizada_via_ldap_no_graylog">9) Autenticação centralizada via LDAP no Graylog</a></li>
<li><a href="#_10_configurando_inputs_customizados_no_graylog">10) Configurando inputs customizados no Graylog</a></li>
</ul>
</li>
<li><a href="#_sessão_7_hardening_de_sistemas_web">Sessão 7: Hardening de sistemas web</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão_6">1) Topologia desta sessão</a></li>
<li><a href="#_2_configuração_do_servidor_de_banco_de_dados">2) Configuração do servidor de banco de dados</a></li>
<li><a href="#_4_configuração_do_servidor_web_www1">4) Configuração do servidor web www1</a></li>
<li><a href="#_5_configuração_automática_do_servidor_web_www2">5) Configuração automática do servidor web www2</a></li>
<li><a href="#_6_configuração_do_balanceador_de_carga">6) Configuração do balanceador de carga</a></li>
</ul>
</li>
<li><a href="#_sessão_8_isolamento_de_processos_e_conteinerização">Sessão 8: Isolamento de processos e conteinerização</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão_7">1) Topologia desta sessão</a></li>
<li><a href="#_2_criação_da_vm_docker1_e_instalação">2) Criação da VM docker1 e instalação</a></li>
<li><a href="#_3_criação_da_vm_docker2">3) Criação da VM docker2</a></li>
<li><a href="#_4_trabalhando_com_containers">4) Trabalhando com containers</a></li>
<li><a href="#_5_distribuindo_containers_para_um_registry_externo">5) Distribuindo containers para um <strong><em>registry</em></strong> externo</a></li>
<li><a href="#_6_construindo_serviços_com_o_docker">6) Construindo serviços com o Docker</a></li>
<li><a href="#_7_operando_com_múltiplos_membros_no_cluster">7) Operando com múltiplos membros no cluster</a></li>
<li><a href="#_8_adicionando_novos_serviços_ao_cluster">8) Adicionando novos serviços ao cluster</a></li>
<li><a href="#_9_configurando_a_persistência_dos_dados">9) Configurando a persistência dos dados</a></li>
</ul>
</li>
<li><a href="#_sessão_9_criação_de_sistemas_linux_customizados">Sessão 9: Criação de sistemas Linux customizados</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão_8">1) Topologia desta sessão</a></li>
<li><a href="#_2_criação_da_vm_de_build">2) Criação da VM de build</a></li>
<li><a href="#_3_construindo_uma_distribuição_mínima">3) Construindo uma distribuição mínima</a></li>
<li><a href="#_4_utilizando_um_repositório_local_de_pacotes">4) Utilizando um repositório local de pacotes</a></li>
<li><a href="#_5_construindo_uma_imagem_mais_divertida">5) Construindo uma imagem mais&#8230;&#8203; divertida?</a></li>
</ul>
</li>
<li><a href="#_sessão_10_módulos_de_segurança_do_kernel">Sessão 10: Módulos de segurança do kernel</a>
<ul class="sectlevel2">
<li><a href="#_1_topologia_desta_sessão_9">1) Topologia desta sessão</a></li>
<li><a href="#_2_criação_do_ambiente_de_segurança">2) Criação do ambiente de segurança</a></li>
<li><a href="#_3_instalação_do_apparmor">3) Instalação do AppArmor</a></li>
<li><a href="#_4_criação_de_um_perfil_apparmor_para_o_servidor_web_nginx">4) Criação de um perfil AppArmor para o servidor web Nginx</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<link rel="stylesheet"  href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.1.0/css/font-awesome.min.css">
<div class="sect1">
<h2 id="_sessão_1_instalação_e_configurações_iniciais">Sessão 1: Instalação e configurações iniciais</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A segurança e o <em>hardening</em> de um sistema Linux começa desde o primeiro momento: sua instalação. Mesmo antes de iniciarmos a preparação de uma máquina ou servidor, as considerações sobre segurança devem povoar a mente do administrador de sistemas, visando reduzir a superfície de ataque, facilitar procedimentos de auditoria e garantir que as melhores práticas de configuração serão aplicadas de forma fácil e homogênea em todo o parque computacional.</p>
</div>
<div class="paragraph">
<p>Com o advento da virtualização, prevalente na maioria das organizações já há mais de dez anos, toma força o conceito de <em>one service per server</em>, ou um serviço por servidor. Nesse caso, o objetivo é que tenhamos vários servidores simples, muitas vezes com um único serviço operacional&#8201;&#8212;&#8201;isso facilita enormemente a administração e diminiu a superfície de ataque de cada servidor, pois haverão poucos programas, bibliotecas e portas abertas a serem atacadas em cada máquina individual. O uso de <em>templates</em> é especialmente vantajoso para garantir que essa premissa seja aplicada com sucesso; construindo imagens-base sólidas e regularmente atualizadas e homologadas pela equipe de segurança da organização, é muito mais fácil e conveniente garantir que as VMs derivadas desses <em>templates</em> serão seguras.</p>
</div>
<div class="paragraph">
<p>Por outro lado, com a virtualização tivemos também o surgimento do <em>virtual machinel sprawl</em>&#8201;&#8212;&#8201;um número crescente (e muitas vezes aparentemente incontrolável) de máquinas virtuais sendo criadas no <em>datacenter</em>, minando as vantagens da simplicidade e facilidade de configuração apresentadas anteriormente. Processo e controles são fundamentais para garantir que VMs sejam criadas apenas quando necessário, e que possuam um ciclo de vida que considere sua implantação, operação e descontinuação quando não mais relevantes.</p>
</div>
<div class="paragraph">
<p>O primeiro passo para garantir que as várias máquinas em nosso ambiente estarão seguras é ser criterioso, portanto, com a criação dos <em>templates</em> de máquina virtual. Nesta sessão iremos tratar dos aspectos de segurança relevantes na instalação de um sistema Debian Linux a ser usado como <em>template</em> para derivação de VMs futuras a serem usadas neste curso, trabalhando aspectos relevantes da instalação de pacotes, gestão de discos e partições e criptografia de dados sensíveis.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="sect2">
<h3 id="_1_criação_de_máquina_virtual_no_virtualbox">1) Criação de máquina virtual no Virtualbox</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Abra o <em>Oracle VM Virtualbox</em>. Para criar uma nova máquina virtual, clique em <em>New</em>. Na tela seguinte, você deverá escolher um nome, tipo e versão do sistema operacional a ser instalado na VM. Em <em>Name</em>, digite <code>debian-template</code>, em <em>Type</em> escolha <code>Linux</code> e em <em>Version</em> selecione <code>Debian (64-bit)</code>.</p>
<div id="img-vbox1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/vbox1.png" alt="vbox1">
</div>
<div class="title">Figure 1. Criação de nova VM, parte 1</div>
</div>
<div class="paragraph">
<p>Em seguida, clique em <em>Next</em>.</p>
</div>
</li>
<li>
<p>Na tela seguinte escolheremos a quantidade de memória RAM a ser usada pelo sistema. O Debian Linux é um sistema bastante frugal, com recomendações mínimas de memória da ordem de 512 MB. Como a máquina que estamos instalando será um <em>template</em>, é interessante que ela seja bastante enxuta, e que as VMs derivadas cresçam em capacidade de acordo com o <em>workload</em> específico de cada aplicação.</p>
<div class="paragraph">
<p>Aponte <code>768 MB</code> de RAM, e em seguida clique em <em>Next</em>.</p>
</div>
<div style="page-break-after: always;"></div>
</li>
<li>
<p>Agora, iremos definir se iremos criar um novo disco rígido virtual para a VM (ou usar um preexistente), e definir seu tamanho. Nesta primeira tela, mantenha a seleção-padrão <em>Create a virtual hard disk now</em>. Clique em <em>Create</em>.</p>
<div id="img-vbox2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/vbox2.png" alt="vbox2">
</div>
<div class="title">Figure 2. Criação de nova VM, parte 2</div>
</div>
<div class="paragraph">
<p>Na tela seguinte, de escolha do formato do disco virtual, mantenha a opção-padrão <em>VDI (VirtualBox Disk Image)</em>. Em casos específicos em que se deseje interoperabilidade da VM com outros ambientes de virtualização, como VMWare ou Hyper-V, pode ser interessante escolher o formato VMDK. Clique em <em>Next</em>.</p>
</div>
<div class="paragraph">
<p>Agora, iremos selecionar se o espaço disco irá crescer à medida que for usado (<em>Dynamically allocated</em>), ou se será completamente alocado quando da sua criação (<em>Fixed size</em>). Em ambientes de produção, é geralmente recomendável selecionar a segunda opção, evitando que os dados do disco virtual fiquem fragmentados em pontos diferentes do disco físico, o que pode acarretar lentidão na leitura de dados, especialmente ao usar discos mecânicos. Neste exemplo, mantenha selecionada a opção <em>Dynamically allocated</em> e clique em <em>Next</em>.</p>
</div>
<div class="paragraph">
<p>Selecionaremos agora a localização do arquivo de disco virtual e seu tamanho. Não é necessário alterar a primeira opção&#8201;&#8212;&#8201;já para a segunda, é importante considerar que um <em>template</em> de máquina virtual será usado para criar vários tipos diferentes de servidores-alvo. Por esse motivo, é interessante que seu disco seja organizado de forma simples e seja facilmente extensível futuramente: a flexibilidade de adição de novos discos virtuais é especialmente vantajosa, pois permite que criemos uma instalação básica bastante enxuta, e a aumentemos conforme necessário.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>Mantenha o valor-padrão de <code>8 GB</code> para o tamanho do disco virtual, e clique em <em>Create</em>.</p>
</div>
<div id="img-vbox3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/vbox3.png" alt="vbox3">
</div>
<div class="title">Figure 3. Criação de nova VM, parte 3</div>
</div>
</li>
<li>
<p>Será criada uma nova máquina virtual com o nome <code>debian-template</code>. Vamos fazer uma rápida pós-configuração antes de iniciar o processo de instalação: clique com o botão direito sobre a VM, e em seguida em <em>Settings</em>.</p>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>Selecione <em>Storage</em> &gt; <em>Controller: IDE</em> &gt; <em>Empty</em>, e na parte à direita da janela clique no pequeno ícone de um CD em frente à opção <em>Optical Drive</em>. Em seguida, clique em <em>Choose Virtual Optical Disk File&#8230;&#8203;</em> e navegue pelo sistema de arquivos, selecionando a imagem ISO de instalação do Debian Linux como mostrado abaixo.</p>
</div>
<div id="img-vbox-conf1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/vbox-conf1.png" alt="vbox conf1">
</div>
<div class="title">Figure 4. Configuração de nova VM</div>
</div>
<div class="paragraph">
<p>Em <em>Audio</em>, desmarque a caixa <em>Enable Audio</em>. Como iremos criar um conjunto de máquinas virtuais que atuarão exclusivamente como servidores, não há necessidade de dispor de áudio nas VMs.</p>
</div>
<div class="paragraph">
<p>Em <em>Network</em> &gt; <em>Adapter 1</em> &gt; <em>Attached to</em>, altere a conexão de rede da máquina virtual para <em>Bridged Adapter</em>. Em <em>Name</em>, verifique que a placa de rede física conectada à rede externa está selecionada (isso é especialmente importante em máquinas que possuem múltiplas placas de rede ou interfaces <em>wireless</em>). Se desejar, expanda <em>Advanced</em> e clique no pequeno círculo azul à direita de <em>MAC Address</em> para randomizar um novo endereço físico para a placa de rede da máquina virtual, especialmente útil em casos de conflito de IP.</p>
</div>
<div class="paragraph">
<p>Em <em>USB</em>, marque a caixa <em>USB 1.1 (OHCI Controller)</em>. Esta configuração evita que sejam levantados erros ao iniciar a VM caso as extensões do Virtualbox não estejam instaladas na máquina hospedeira.</p>
</div>
<div class="paragraph">
<p>Finalmente, clique em <em>OK</em>.</p>
</div>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect2">
<h3 id="_2_instalação_do_debian_linux">2) Instalação do Debian Linux</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Selecione a máquina virtual <code>debian-template</code> e clique no botão <em>Start</em> para iniciá-la. Apos um curto período, você verá o menu de <em>boot</em> do Debian Linux; selecione a opção <em>Install</em> para começar o instalador no modo texto.</p>
<div id="img-debinst1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst1.png" alt="debinst1">
</div>
<div class="title">Figure 5. Instalação do Debian Linux, parte 1</div>
</div>
</li>
<li>
<p>No passo de seleção de idioma, selecione <em>Portuguese (Brazil)</em>. Em localidade, selecione <em>Brasil</em>. Para o mapa de teclado a ser usado, provavelmente será o <em>Português Brasileiro</em> (verifique se há a tecla <code>ç</code> ao lado do caractere <code>l</code>).</p>
<div class="paragraph">
<p>Os componentes do instalador serão carregados a seguir.</p>
</div>
</li>
<li>
<p>Em seguida, o instalador irá tentar autoconfigurar a rede usando DHCP. Caso esse protocolo não esteja disponível em sua rede local, consulte o instrutor sobre como proceder com a configuração manual das interfaces de rede.</p>
<div class="paragraph">
<p>Configurada a rede, iremos escolher o <em>hostname</em> da máquina. Defina o mesmo nome usado para a máquina virtual, <code>debian-template</code>.</p>
</div>
<div class="paragraph">
<p>Para o nome de domínio da rede, iremos usar a rede local fictícia <code>intnet</code> durante o curso.</p>
</div>
<div style="page-break-after: always;"></div>
</li>
<li>
<p>Agora, iremos definir a senha do <code>root</code>, o superusuário em sistemas Linux. É bastante recomendado que se defina uma senha especialmente segura, já que esse usuário possui permissões totais sobre o sistema. Por simplicidade e homogeneidade no ambiente de curso, defina a senha como <code>rnpesr</code>.</p>
<div id="img-debinst2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst2.png" alt="debinst2">
</div>
<div class="title">Figure 6. Instalação do Debian Linux, parte 2</div>
</div>
<div class="paragraph">
<p>Na tela seguinte, confirme a senha.</p>
</div>
</li>
<li>
<p>O próximo passo é criar um usuário não-privilegiado para tarefas corriqueiras do sistema. Para o nome completo do usuário, digite <code>aluno</code>&#8201;&#8212;&#8201;este também será o nome de conta do usuário.</p>
<div class="paragraph">
<p>Para a senha, defina de igual forma <code>rnpesr</code>.</p>
</div>
</li>
<li>
<p>O instalador irá tentar obter a hora via Internet através do protocolo NTP. Em seguida, teremos que escolher um estado para definir o fuso horário do sistema. Escolha o estado em que você está realizando este curso.</p>
</li>
<li>
<p>Agora, faremos o particionamento do disco. Temos quatro opções: particionamento assistido usando o disco inteiro, assistido usando o disco inteiro com LVM, assistido com o disco inteiro e LVM criptografado e particionamento manual. Se tivéssemos mais de um disco virtual conectado à máquina, o instalador ofereceria também a opção de configuração assistida de RAID (<em>Redundant Array of Independent Disks</em>).</p>
<div class="paragraph">
<p>Mas, o que é LVM?</p>
</div>
<div class="paragraph">
<p>O <em>Logical Volume Manager</em> (LVM) é um sistema de mapeamento de dispositivos do Linux que permite a criação e gestão de volumes lógicos de armazenamento. As utilidades da gestão de armazenamento via volumes lógicos são muitas, destacando-se:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Criação de volumes lógicos únicos englobando diferentes volumes físicos ou discos físicos inteiros, permitindo redimensionamento dinâmico de volumes.</p>
</li>
<li>
<p>Gestão facilitada de grandes quantidades de discos físicos, permitindo que discos sejam adicionados ou substituídos sem <em>downtime</em> ou impacto à disponibilidade&#8201;&#8212;&#8201;especialmente útil quando combinado com hardware que suporta <em>hot swapping</em>.</p>
</li>
<li>
<p>Em pequenos sistemas (como <em>desktops</em> e estações de trabalho) permite que o administrador não tenha que estimar no passo de instalação quão grande uma partição irá se tornar, permitindo redimensionamento dinâmico futuro.</p>
</li>
<li>
<p>Criação de backups consistentes através de <em>snapshots</em> de volumes lógicos.</p>
</li>
<li>
<p>Criptografar múltiplas partições físicas com uma mesma senha.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Em essência, o LVM traz enorme flexibilidade ao administrador de sistemas, resolvendo muitos dos problemas de particionamento que tínhamos no passado. Ele possui alguns conceitos centrais, ilustrados pela imagem a seguir:</p>
</div>
<div id="img-lvm-layout" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/lvm-layout.png" alt="lvm layout">
</div>
<div class="title">Figure 7. Organização do LVM</div>
</div>
<div class="paragraph">
<p>Na base do sistema temos os discos físicos conectados à máquina&#8201;&#8212;&#8201;como <code>/dev/sdb</code> ou <code>/dev/sdc</code>, por exemplo&#8201;&#8212;&#8201;que podem ser particionados (em formato MBR ou GPT) em múltiplas partições. Essas partições são denominadas volumes físicos (<em>Physical Volumes</em>, ou PVs). Vários PVs podem ser aglutinados para definir um grupo de volumes (<em>Volume Groups</em>, ou VGs), que é um agrupamento lógico desses PVs sob um mesmo nome. Pode-se então criar vários volumes lógicos (<em>Logical Volumes</em>, ou LVs) dentro desse VG, e finalmente formatar e montar diretórios dentro dos LVs, já no contexto do sistema de arquivos.</p>
</div>
<div class="paragraph">
<p>A explicação acima é propositalmente sucinta; iremos entrar em maior detalhe com relação ao funcionamento e operação do LVM em atividades subsequentes.</p>
</div>
<div class="paragraph">
<p>De volta ao instalador, iremos configurar um particionamento manual usando LVM. Por isso, na tela <em>Método de particionamento</em>, selecione <em>Manual</em>.</p>
</div>
<div id="img-debinst3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst3.png" alt="debinst3">
</div>
<div class="title">Figure 8. Instalação do Debian Linux, parte 3</div>
</div>
</li>
<li>
<p>Na tela seguinte, o primeiro passo é criar uma tabela de partições vazia no disco virtual <code>/dev/sda</code>. Coloque o cursor sobre o disco <em>SCSI1 (0,0,0) (sda) - 8.6 GB ATA VBOX HARDDISK</em> e pressione <code>ENTER</code>. Em seguida, responda <em>Sim</em> para a pergunta <em>Criar nova tabela de partições vazia neste dispositivo?</em>.</p>
</li>
<li>
<p>Agora, iremos configurar o LVM. Selecione a opção <em>Configurar o Gerenciador de Volumes Lógicos</em>, e responda <em>Sim</em> para a pergunta <em>Gravar as mudanças nos discos e configurar LVM?</em>.</p>
<div style="page-break-after: always;"></div>
</li>
<li>
<p>Você verá a tela de configuração do LVM, como se segue.</p>
<div id="img-debinst4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst4.png" alt="debinst4">
</div>
<div class="title">Figure 9. Instalação do Debian Linux, parte 4</div>
</div>
<div class="paragraph">
<p>A qualquer momento, você pode selecionar a opção <em>Exibir detalhes de configuração</em> para verificar o estado atual de configuração do LVM.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>O primeiro passo é criar um VG, então escolhar <em>Criar grupo de volumes</em>. Para o nome do grupo, digite <code>vg-base</code>. Em seguida, marque com a tecla <code>Espaço</code> os volmes físicos que integrarão esse VG (no caso, apenas o dispositivo <code>/dev/sda</code> está disponível), e finalmente responda <em>Sim</em> para a pergunta <em>Gravar as mudanças nos discos e configurar LVM?</em>. Ao exibir os detalhes de configuração após este passo, você deverá ver a tela a seguir:</p>
</div>
<div id="img-debinst5" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst5.png" alt="debinst5">
</div>
<div class="title">Figure 10. Instalação do Debian Linux, parte 5</div>
</div>
</li>
<li>
<p>Todos os volumes físicos (PVs) foram alocados a grupos de volumes (VGs), então agora nos resta criar volumes lógicos (LVs). Com efeito, neste momento é como se estivéssemos particionando um disco no Linux em uma instalação tradicional. Iremos criar três LVs:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>lv-boot</code>: LV que irá armazenar o diretório <code>/boot</code> do sistema, com tamanho de 256 MB. É interessante separar o <code>/boot</code> para reduzir a complexidade do sistema de arquivos em disco, bem como para aplicar configurações diferenciadas ao <em>filesystem</em>, como RAID por software, sistemas de arquivos não-usuais como ZFS, ou caso se deseje criptografar a raiz do sistema.</p>
</li>
<li>
<p><code>lv-swap</code>: LV que irá servidor como área de troca (<em>swap</em>) do SO em caso de escassez de memória física. Como idealmente não queremos chegar nesse cenário, alocaremos apenas 256 MB para essa área.</p>
</li>
<li>
<p><code>lv-root</code>: LV quer irá armazenar a raiz do sistema, <code>/</code>, com tamanho de 1536 MB. Pode parecer um valor pequeno, mas considere que iremos separar outros sistemas de arquivos posteriormente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Imediatamente, podem surgir duas perguntas:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Por que não estamos alocando a totalidade do disco?</strong> O LVM nos permite grande flexibilidade, que será demonstrada em atividades subsequentes. Ao alocarmos [256 + 256 + 1536] = 2048 MB em um disco de 8 GB, deixamos (aproximadamente) 6 GB livres que poderão ser alocados de acordo com o tipo específico de uso de cada máquina. Em sentido estrito, a alocação que fizemos acima não é exatamente ideal para um <em>template</em>, mas iremos corrigir isso ao demonstrar as funcionalidades do LVM, a seguir.</p>
</li>
<li>
<p><strong>Por que não criamos LVs para partições como</strong> <code>/tmp</code><strong>,</strong> <code>/usr</code> <strong>ou</strong> <code>/var</code><strong>?</strong> De fato, é bastante recomendável separar essas partições em servidores, como veremos a seguir. Iremos criar esses LVs brevemente, após a instalação do SO.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Para criar um LV, selecione <em>Criar volume lógico</em>. Em seguida, selecione o grupo de volumes no qual será feita a alocação (no caso, apenas <code>vg-base</code> está disponível). Para o nome do primeiro volume lógico, digite <code>lv-boot</code>, como delineado acima. Para seu tamanho, defina 256 MB.</p>
</div>
<div class="paragraph">
<p>Prossiga com a criação dos outros dois LVs, <code>lv-swap</code> e <code>lv-root</code>, com os tamanhos especificados acima. Ao exibir os detalhes de configuração após este passo, você deverá ver a tela a seguir:</p>
</div>
<div id="img-debinst6" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst6.png" alt="debinst6">
</div>
<div class="title">Figure 11. Instalação do Debian Linux, parte 6</div>
</div>
<div class="paragraph">
<p>Se tudo estiver a contento, selecione <em>Finalizar</em>.</p>
</div>
</li>
<li>
<p>Ainda não acabou! Neste momento, configuramos o LVM&#8201;&#8212;&#8201;alocamos volumes físicos, criamos um grupo de volumes agrupando esses PVs e finalmente criamos 3 volumes lógicos dentro do VG. Falta informar ao sistema quais serão os pontos de montagem desses LVs, e quais sistemas de arquivos serão usados. Usaremos a seguinte configuração:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>lv-boot</code>: montado sob o diretório <code>/boot</code>, formatado em <code>ext2</code>.</p>
</li>
<li>
<p><code>lv-swap</code>: área de troca (<em>swap</em>).</p>
</li>
<li>
<p><code>lv-root</code>: montado sob o diretório <code>/</code>, formatado em <code>ext4</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Para fazer as configurações acima, selecione um dos LVs indicados (por exemplo, deixe o cursor sobre a linha <code>#1 255.9 MB</code>, logo abaixo de <code>lv-boot</code>), e pressione <code>ENTER</code>. Em <em>Usar como</em>, escolha <em>Sistema de arquivos ext2</em>, e em <em>Ponto de montagem</em> selecione <code>/boot</code>. Finalmente, selecione <em>Finalizar a configuração da partição</em>.</p>
</div>
<div class="paragraph">
<p>Prossiga com a configuração dos outros dois LVs, <code>lv-swap</code> e <code>lv-root</code>, de acordo com as características especificadas acima. Ao exibir os detalhes de configuração após este passo, você deverá ver a tela a seguir:</p>
</div>
<div id="img-debinst7" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst7.png" alt="debinst7">
</div>
<div class="title">Figure 12. Instalação do Debian Linux, parte 7</div>
</div>
<div class="paragraph">
<p>Se tudo estiver a contento, selecione <em>Finalizar o particionamento e escrever as mudanças no disco</em>. Confirme a pergunta subsequente escolhendo <em>Sim</em>. Os discos serão formatados e o sistema-base do Debian será instalado.</p>
</div>
</li>
<li>
<p>O próximo passo será a seleção e instalação de pacotes adicionais. Na pergunta <em>Selecionar um espelho de rede</em>, responda <em>Sim</em>. Em seguida, selecione <em>Brasil</em> como o país do espelho e aponte o servidor <code>ftp.br.debian.org</code>. Quanto à informação do proxy HTTP a ser usado, deixe em branco (a menos que o contrário seja indicado pelo seu instrutor).</p>
<div class="paragraph">
<p>O instalador irá fazer o download dos arquivos de índice do repositório de pacotes.</p>
</div>
<div class="paragraph">
<p>Após algum tempo, surgirá a pergunta <em>Participar do concurso de utilização de pacotes</em>&#8201;&#8212;&#8201;responda <em>Não</em>. Em seguida, o <code>tasksel</code> será invocado. Nesta tela podemos escolher quais conjuntos de software iremos instalar no disco.</p>
</div>
<div class="paragraph">
<p>Para servidores de rede, em linhas gerais, é usualmente recomendável não selecionar nada além do estritamente necessário nesta tela, e proceder com a instalação manual de pacotes posteriormente; o <code>tasksel</code> geralmente instala um conjunto de pacotes superior ao que objetivamos originalmente, aumentando a superfície de ataque e exposição do sistema. Para ambientes <em>desktop</em>, é perfeitamente razoável escolher o ambiente gráfico base e uma das opções de gerenciadores de janelas disponíveis.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>Mantenha marcadas apenas as caixas <em>servidor SSH</em> e <em>utilitários de sistema padrão</em>, e selecione <em>Continuar</em>.</p>
</div>
<div id="img-debinst8" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst8.png" alt="debinst8">
</div>
<div class="title">Figure 13. Instalação do Debian Linux, parte 8</div>
</div>
<div class="paragraph">
<p>O instalador irá fazer o download e instalação dos pacotes selecionados.</p>
</div>
</li>
<li>
<p>A última etapa é efetuar a instalação do carregador de inicialização, ou <em>bootloader</em>, no sistema. O Debian, assim como a maioria das demais distribuições, utiliza o GRUB (<em>GRand Unified Bootloader</em>) como <em>bootloader</em> padrão.</p>
<div class="paragraph">
<p>Responda <em>Sim</em> para a pergunta <em>Instalar o carregador de inicialização GRUB no registro mestre de inicialização</em>, e em seguida selecione o dispositivo de instalação <code>/dev/sda</code> (o único disponível).</p>
</div>
<div style="page-break-after: always;"></div>
</li>
<li>
<p>A instalação está concluída. Selecione <em>Continuar</em> para reinicializar a VM no novo sistema instalado.</p>
<div class="paragraph">
<p>Após o reboot, você deverá ver a tela de login abaixo:</p>
</div>
<div id="img-debinst9" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/debinst9.png" alt="debinst9">
</div>
<div class="title">Figure 14. Instalação do Debian Linux, concluída</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_ajustes_pós_instalação">3) Ajustes pós-instalação</h3>
<div class="paragraph">
<p>Instalado nosso <em>template</em>, iremos continuar sua configuração para torná-lo, de fato, uma imagem-base de boa qualidade para ser usada em derivações de VMs futuras. Além de corrigir a situação dos volumes lógicos (que deixamos incompleta propositalmente durante a instalação), iremos também fazer algumas configurações de base com relação aos repositórios, atualização de pacotes e contas de usuário.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Faça login na máquina <code>debian-template</code> como usuário <code>root</code>, usando a senha <code>rnpesr</code>. Imediatamente após o login, você verá uma mensagem parecida com a que se segue:</p>
<div class="literalblock">
<div class="content">
<pre>Linux debian-template 4.9.0-7-amd64 #1 SMP Debian 4.9.110-3+deb9u2 (2018-08-13) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname
debian-template</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># whoami
root</pre>
</div>
</div>
<div class="paragraph">
<p>Essa mensagem é definida no arquivo <code>/etc/motd</code>, conhecida como <em>message of the day</em> (ou "mensagem do dia"). É interessante customizar essa mensagem para refletir o ambiente local, avisando o administrador sobre os requisitos legais para operar máquinas da organização, ou informando sobre onde encontrar documentação sobre os servidores. Lembre-se que, já que estamos mexendo no <em>template</em>, essa mensagem será copiada para todas as VMs derivadas desta imagem.</p>
</div>
<div class="paragraph">
<p>Neste curso, vamos deixar o <em>motd</em> vazio. Execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># echo "" &gt; /etc/motd</pre>
</div>
</div>
<div class="paragraph">
<p>Saia da sessão corrente usando <code>exit</code> ou <code>CTRL + D</code>, e logue novamente. Note que a mensagem anterior será suprimida.</p>
</div>
</li>
<li>
<p>Ao longo do curso, iremos editar vários arquivos de texto em ambiente Linux. Há vários editores de texto disponíveis para a tarefa, como o <code>vi</code>, <code>emacs</code> ou <code>nano</code>. Caso você não esteja familiarizado com um editor de texto, recomendamos o uso do <code>nano</code>, que possui uma interface bastante amigável para usuários iniciantes. Para editar um arquivo com o <code>nano</code>, basta digitar <code>nano</code> seguido do nome do arquivo a editar&#8201;&#8212;&#8201;não é necessário que o arquivo tenha sido criado previamente:</p>
<div class="literalblock">
<div class="content">
<pre># nano teste</pre>
</div>
</div>
<div class="paragraph">
<p>Digite livremente a seguir. Use as setas do teclado para navegar no texto, e <code>DELETE</code> ou <code>BACKSPACE</code> para apagar texto. O <code>nano</code> possui alguns atalhos interessantes, como:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>CTRL + G</code>: Exibir a ajuda do editor</p>
</li>
<li>
<p><code>CTRL + X</code>: Fechar o <code>buffer</code> de arquivo atual (que pode ser um texto sendo editado, ou o painel de ajuda), e sair do <code>nano</code>. Para salvar o arquivo, digite <code>Y</code> (<em>yes</em>) ou <code>S</code> (<em>sim</em>) para confirmar as mudanças ao arquivo, opcionalmente altere o nome do arquivo a ser escrito no disco, e digite <code>ENTER</code>.</p>
</li>
<li>
<p><code>CTRL + O</code>: Salvar o arquivo no disco sem sair do editor.</p>
</li>
<li>
<p><code>CTRL + W</code>: Buscar padrão no texto.</p>
</li>
<li>
<p><code>CTRL + K</code>: Cortar uma linha inteira e salvar no <code>buffer</code> do editor.</p>
</li>
<li>
<p><code>CTRL + U</code>: Colar o <code>buffer</code> do editor na posição atual do cursor. Pode ser usado repetidamente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Para salvar e sair do texto sendo editado, como mencionado acima, utilize <code>CTRL + X</code>.</p>
</div>
</li>
<li>
<p>Edite o arquivo <code>/etc/network/interfaces</code> como se segue, reinicie a rede e verifique o funcionamento:</p>
<div class="literalblock">
<div class="content">
<pre># nano /etc/network/interfaces
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/network/interfaces
source /etc/network/interfaces.d/*

auto lo enp0s3

iface lo inet loopback

iface enp0s3 inet dhcp</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart networking</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ip a s | grep '^ *inet '
    inet 127.0.0.1/8 scope host lo
    inet 192.168.29.104/24 brd 192.168.29.255 scope global enp0s3</pre>
</div>
</div>
<div class="paragraph">
<p>Desabilite a verificação de <em>hostnames</em> remotos do <code>ssh</code> para agilizar o procedimento de login. Reinicie o <em>daemon</em> posteriormente.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i '/UseDNS/s/^#//' /etc/ssh/sshd_config</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart ssh</pre>
</div>
</div>
</li>
<li>
<p>Durante as atividades deste curso iremos ter que digitar vários comandos no terminal das VMs, os quais serão mostrados nos cadernos de atividade de cada sessão. Alguns desses comandos serão bastante longos e/ou terão uma sintaxe complicada&#8201;&#8212;&#8201;nesse caso, o ideal é que tenhamos a possibilidade de copiá-los diretamente do caderno para a console, evitando erros de digitação.</p>
<div class="paragraph">
<p>O protocolo de login remoto SSH é ideal para solucionar essa tarefa. Em ambiente Windows, dois dos métodos mais populares para efetuar logins remotos via SSH são os programas PuTTY (<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" class="bare">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a>) ou Cygwin (<a href="https://cygwin.com/install.html" class="bare">https://cygwin.com/install.html</a>). Vamos, primeiro, visualizar os passos necessários usando o PuTTY.</p>
</div>
<div class="paragraph">
<p>Em qualquer caso, o primeiro passo é sempre descobrir qual o endereço IP da máquina remota à qual queremos nos conectar. Para isso digite, na máquina <code>debian-template</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ip a s enp0s3 | grep '^ *inet ' | awk '{print $2}' | cut -d'/' -f1
192.168.29.104</pre>
</div>
</div>
<div class="paragraph">
<p>O uso do <strong>PuTTY</strong>, por se tratar de um programa <em>standalone</em> com o objetivo único de efetuar login via SSH, é mais simples. Faça o download do PuTTY em sua máquina física Windows, usando a URL informada acima. Em seguida, apenas abra o programa e digite na caixa <em>Host Name</em> o endereço IP da máquina remota descoberto acima. Em seguida, clique em <em>Open</em>.</p>
</div>
<div id="img-ssh1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/ssh1.png" alt="ssh1">
</div>
<div class="title">Figure 15. Login via SSH usando o PuTTY, parte 1</div>
</div>
<div class="paragraph">
<p>Será mostrado um alerta de segurança avisando que a chave do <em>host</em> remoto não se encontra na <em>cache</em> local, o que pode configurar um risco de segurança. Clique em <em>Yes</em> para prosseguir com a tentativa de login.</p>
</div>
<div class="paragraph">
<p>Em seguida, será solicitado o nome de usuário com o qual efetuar a conexão. Como, por padrão, o <em>daemon</em> <code>sshd</code> do Debian não permite logins remotos usando o <code>root</code>, escolha o usuário <code>aluno</code>. Para a senha, informe <code>rnpesr</code>. Em caso de sucesso, você verá a tela a seguir:</p>
</div>
<div id="img-ssh2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/ssh2.png" alt="ssh2">
</div>
<div class="title">Figure 16. Login via SSH usando o PuTTY, parte 2</div>
</div>
<div class="paragraph">
<p>Para tornar-se o superusuário <code>root</code>, agora, basta executar o comando <code>su -</code> e informar a senha correta, como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su -
Senha:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># whoami
root</pre>
</div>
</div>
<div class="paragraph">
<p>Para copiar/colar comandos no PuTTY, basta selecionar o texto desejado no ambiente da máquina física e digitar <code>CTRL + C</code>, e em seguida clicar com o botão direito na janela do PuTTY. O texto selecionado será colado na posição do cursor.</p>
</div>
</li>
<li>
<p>O uso do Cygwin é um pouco mais envolvido, já que seu objetivo é mais complexo: prover, em ambiente Windows, funcionalidade equivalente à que temos disponível em uma distribuição Linux. Para começar, faça o download e execute o instalador do Cygwin em sua máquina física Windows.</p>
<div class="paragraph">
<p>A instalação é, em grande parte, bastante similar à de qualquer aplicativo Windows. Na tela inicial, clique em <em>Next</em>. Em <em>Choose a Download Source</em>, mantenha marcada a caixa <em>Install from Internet</em> e clique em <em>Next</em>. Em <em>Select Root Install Directory</em>, os valores padrão estão apropriados&#8201;&#8212;&#8201;clique em <em>Next</em>. Na tela <em>Select Local Package Directory</em>, novamente, mantenha o valor padrão e clique em <em>Next</em>.</p>
</div>
<div class="paragraph">
<p>Agora, vamos selecionar a fonte de pacotes. Em <em>Select Your Internet Connection</em>, a menos que haja um <em>proxy</em> na rede local (informe-se com seu instrutor), mantenha marcada a caixa <em>Direct Connection</em> e clique em <em>Next</em>. Será feito o download da lista de espelhos disponíveis para o Cygwin. Em <em>Choose A Download Site</em>, qualquer espelho irá funcionar, mas evidentemente é desejável que escolhamos um que possua maior velocidade de download&#8201;&#8212;&#8201;o site <a href="http://linorg.usp.br" class="bare">http://linorg.usp.br</a> é provavelmente uma boa opção, nesse caso. Clique em <em>Next</em>, e o instalador irá baixar a lista de pacotes disponíveis.</p>
</div>
<div class="paragraph">
<p>Em adição ao sistema-base padrão, é necessário instalar o OpenSSH para efetuar logins remotos. Na caixa de busca <em>Search</em>, no topo da tela, digite o termo de busca <code>openssh</code>. Expanda a árvore <code>Net</code> e clique na palavra <em>Skip</em> na linha do pacote <code>openssh: The OpenSSH server and client programs</code>&#8201;&#8212;&#8201;ela irá alterar para a versão a ser instalada, <code>7.9p1-1</code> no caso da figura mostrada abaixo:</p>
</div>
<div id="img-ssh3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/ssh3.png" alt="ssh3">
</div>
<div class="title">Figure 17. Instalação do OpenSSH no Cygwin</div>
</div>
<div class="paragraph">
<p>Clique em <em>Next</em>. Em <em>Review and confirm changes</em>, verifique que o Cygwin irá instalar o OpenSSH e todas as demais dependências do sistema-base Linux, como o <em>shell</em> <code>bash</code> ou ferramentas como o <code>grep</code>, e clique em <em>Next</em>. O instalador irá fazer o download e instalação dos pacotes selecionados.</p>
</div>
<div class="paragraph">
<p>Concluído o processo, procure pelo programa <code>Cygwin Terminal</code> no menu iniciar da sua máquina física Windows, e execute-o. Agora, tente fazer login via SSH normalmente, como se estivesse em um <em>shell</em> Linux:</p>
</div>
<div id="img-ssh4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/ssh4.png" alt="ssh4">
</div>
<div class="title">Figure 18. Login via SSH usando o Cygwin</div>
</div>
<div class="paragraph">
<p>Para copiar/colar comandos no Cygwin, basta selecionar o texto desejado no ambiente da máquina física e digitar <code>CTRL + C</code>, e em seguida mudar o foco para a janela do Cygwin e digitar a combinação <code>SHIFT + Insert</code>. Para copiar texto a partir da janela do Cygwin, selecione-o e use a combinação de teclas <code>CTRL + Insert</code>. Para encontrar os arquivos localizados em sua máquina física, o diretório <code>/cygdrive/X</code> pode ser usado para mapear para os discos da máquina local&#8201;&#8212;&#8201;por exemplo, o diretório <code>/cygdrive/c</code> mapeia diretamente para o <code>C:\</code> da máquina Windows.</p>
</div>
</li>
<li>
<p>A seguir, vamos checar a configuração dos repositórios de pacotes sendo usados pelo sistema. Cheque o conteúdo do arquivo <code>/etc/apt/sources.list</code>:</p>
<div class="literalblock">
<div class="content">
<pre># cat /etc/apt/sources.list
#

# deb cdrom:[Debian GNU/Linux 9.5.0 _Stretch_ - Official amd64 xfce-CD Binary-1 20180714-10:25]/ stretch main

deb cdrom:[Debian GNU/Linux 9.5.0 _Stretch_ - Official amd64 xfce-CD Binary-1 20180714-10:25]/ stretch main

deb http://ftp.br.debian.org/debian/ stretch main
deb-src http://ftp.br.debian.org/debian/ stretch main

deb http://security.debian.org/debian-security stretch/updates main
deb-src http://security.debian.org/debian-security stretch/updates main

# stretch-updates, previously known as 'volatile'
deb http://ftp.br.debian.org/debian/ stretch-updates main
deb-src http://ftp.br.debian.org/debian/ stretch-updates main</pre>
</div>
</div>
<div class="paragraph">
<p>Temos algumas linhas desnecessárias neste arquivo: primeiro, as entradas <code>deb cdrom</code> referem-se ao CD de instalação do Debian, que usamos durante a atividade (2) desta sessão; além dessas, as entradas <code>deb-src</code> referem-se a pacotes de código-fonte, que podem ser baixados com o comando <code>apt-get source</code> e posteriormente compilados pelo administrador. Via de regra, não usaremos quaisquer dessas entradas em um sistema de produção, então elas podem ser removidas com segurança.</p>
</div>
<div class="paragraph">
<p>Sobre os componentes (ou seções) do repositório, note que apenas a <code>main</code> está incluída no arquivo acima. O Debian possui três seções principais:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>main</code>: contém apenas software compatível com a DFSG (<em>Debian Free Software Guidelines</em>, ou diretivas de software livre do Debian), e não dependem de software fora desta seção para funcionar. Esses são os pacotes considerados parte integrante da distribuição de software do Debian.</p>
</li>
<li>
<p><code>contrib</code>: contém pacotes compatíveis com a DFSG, mas que possuem dependências que não estão na seção <code>main</code>.</p>
</li>
<li>
<p><code>non-free</code>: contém software incompatível com a DFSG.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Em geral, não há grandes restrições para incluir todas as três seções de software detalhadas acima em uma organização. Assim, iremos incluir as duas seções faltantes, <code>contrib</code> e <code>non-free</code>, no arquivo <code>/etc/apt/sources.list</code>. Edite-o usando o <code>vi</code> ou o <code>nano</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/apt/sources.list
(...)</pre>
</div>
</div>
<div class="paragraph">
<p>Após a edição, seu conteúdo deverá ficar assim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/apt/sources.list
deb http://ftp.br.debian.org/debian/ stretch main contrib non-free
deb http://ftp.br.debian.org/debian/ stretch-updates main contrib non-free
deb http://security.debian.org/debian-security stretch/updates main contrib non-free</pre>
</div>
</div>
</li>
<li>
<p>Atualize a lista de pacotes disponíveis nos repositórios remotos usando o comando:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get update</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, vamos garantir que nosso <em>template</em> está plenamente atualizado com:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get dist-upgrade -y</pre>
</div>
</div>
<div class="paragraph">
<p>Caso o kernel do sistema tenha sido atualizado no processo (pacotes com o nome <code>linux-image-*</code>), será necessário reiniciar a máquina para realizar o <em>boot</em> com o novo kernel. Faça isso, se for o caso, com o comando <code>reboot</code>.</p>
</div>
<div class="paragraph">
<p>Após o reinício, logue novamente como o usuário <code>root</code>. Para remover os binários dos pacotes recentemente instalados do sistema, execute <code>apt-get clean</code>. Se quiser remover as dependências de pacotes que estão instaladas no sistema e já não são mais necessárias, rode <code>apt-get autoremove</code>.</p>
</div>
<div class="paragraph">
<p>Para remover todos os kernels antigos do sistema (isto é, todos os kernels exceto o que está em execução no momento), você pode executar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dpkg -l | egrep 'linux-image-[0-9\.-]*-amd64' | awk '{print $2}' | grep -v $(uname -r) | xargs apt-get purge -y</pre>
</div>
</div>
</li>
<li>
<p>Este é um bom momento para instalar pacotes que você acredita serem necessários em todas as máquinas a serem derivadas deste <em>template</em>. Pacotes como o <code>sudo</code> ou <code>vim</code> podem ser boas opções, dependendo das necessidades da sua organização.</p>
<div class="paragraph">
<p>Neste momento, iremos instalar apenas os pacotes listados abaixo. Execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get install rsync nfs-common sudo dirmngr</pre>
</div>
</div>
</li>
<li>
<p>Pode ser interessante desabilitar a combinação de teclas <code>CTRL + ALT + DEL</code>; mesmo em um ambiente virtualizado, há casos em que o administrador se confunde e acaba enviando essa combinação de teclas para a console de um servidor aberto, causando seu <em>reboot</em> inadvertidamente.</p>
<div class="paragraph">
<p>Note que, por padrão, essa combinação de teclas aponta para o <code>reboot.target</code>, um <em>target</em> (ou alvo) do <code>systemd</code> que é responsável pelo reinício do sistema operacional.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -ld /lib/systemd/system/ctrl-alt-del.target
lrwxrwxrwx 1 root root 13 jun 13 17:20 /lib/systemd/system/ctrl-alt-del.target -&gt; reboot.target</pre>
</div>
</div>
<div class="paragraph">
<p>Para desabilitar o <code>CTRL + ALT + DEL</code>, basta executar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl mask ctrl-alt-del.target
Created symlink /etc/systemd/system/ctrl-alt-del.target → /dev/null.</pre>
</div>
</div>
</li>
<li>
<p>O <em>template</em> atual (a máquina <code>debian-template</code>) será usada como base para várias VMs futuras, como estabelecido. Ao copiar a máquina, a primeira ação a ser realizada será sempre alterar o <em>hostname</em> para o nome da nova máquina&#8201;&#8212;&#8201;pode ser muito interessante ter um meio para automatizar essa tarefa, como um <em>shell script</em>.</p>
<div class="paragraph">
<p>Crie um novo arquivo <code>/root/scripts/changehost.sh</code> (crie o diretório <code>/root/scripts</code> se este não existir), com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash


usage() {
  echo "  Usage: $0 HOSTNAME"
  exit 1
}


# testar parametros
[ -z $1 ] &amp;&amp; usage

# testar sintaxe valida
if [[ "$1" =~ [^a-z0-9-] ]]; then
  echo "  HOSTNAME must be lowercase alphanumeric: [a-z0-9]*"
  usage
elif [ ${#1} -gt 63 ]; then
  echo "  HOSTNAME must have &lt;63 chars"
  usage
fi

# alterar hostname local
chost="$( hostname -s )"
sed -i "s/${chost}/${1}/g" /etc/hosts
sed -i "s/${chost}/${1}/g" /etc/hostname

invoke-rc.d hostname.sh restart
invoke-rc.d networking force-reload
hostnamectl set-hostname $1

# re-gerar chaves SSH
rm -f /etc/ssh/ssh_host_* 2&gt; /dev/null
dpkg-reconfigure openssh-server &amp;&gt; /dev/null</code></pre>
</div>
</div>
<div class="paragraph">
<p>O <em>script</em> acima espera receber um único parâmetro: o novo <em>hostname</em> a ser configurado para a máquina. Após checar se o parâmetro possui sintaxe válida, o <em>script</em> irá alterar o nome da máquina nos arquivos <code>/etc/hostname</code> e <code>/etc/hosts</code>, reiniciar as interfaces de rede e <em>daemons</em> relevantes, e finalmente re-gerar as chaves de host do <code>ssh</code> com o novo nome da máquina.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_configuração_do_lvm">4) Configuração do LVM</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos prosseguir com a configuração do LVM, que fizemos apenas parcialmente durante a instalação&#8201;&#8212;&#8201;para relembrar, configuramos três volumes lógicos (LVs), <code>lv-boot</code>, <code>lv-swap</code> e <code>lv-root</code>. Para verificar o estado dos volumes lógicos em um sistema Linux, execute o comando <code>lvdisplay</code>:</p>
<div class="literalblock">
<div class="content">
<pre># lvdisplay | grep 'Logical volume\|LV Path\|LV Name\|LV Size'
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-boot
  LV Name                lv-boot
  LV Size                244,00 MiB
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-swap
  LV Name                lv-swap
  LV Size                244,00 MiB
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-root
  LV Name                lv-root
  LV Size                1,43 GiB</pre>
</div>
</div>
<div class="paragraph">
<p>Para verificar o estado dos grupos de volumes (VGs), execute <code>vgdisplay</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># vgdisplay
  --- Volume group ---
  VG Name               vg-base
  System ID
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  4
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                3
  Open LV               3
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               8,00 GiB
  PE Size               4,00 MiB
  Total PE              2047
  Alloc PE / Size       488 / 1,91 GiB
  Free  PE / Size       1559 / 6,09 GiB
  VG UUID               hOXyJN-XA3n-i4RG-4mhJ-rDF5-edi7-xXS5f0</pre>
</div>
</div>
<div class="paragraph">
<p>E, finalmente, para verificar o estado dos volumes físicos (PVs), execute <code>pvdisplay</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pvdisplay
  --- Physical volume ---
  PV Name               /dev/sda1
  VG Name               vg-base
  PV Size               8,00 GiB / not usable 2,00 MiB
  Allocatable           yes
  PE Size               4,00 MiB
  Total PE              2047
  Free PE               1559
  Allocated PE          488
  PV UUID               ZnHHMn-Y37D-6Psd-oHei-K1Qd-wHjY-6gqFZ3</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar três novos LVs, com as configurações que se seguem:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>lv-tmp</code>: armazenará o diretório <code>/tmp</code>, com tamanho de 512 MB.</p>
</li>
<li>
<p><code>lv-var</code>: armazenará o diretório <code>/var</code>, com tamanho de 1536 MB.</p>
</li>
<li>
<p><code>lv-usr</code>: armazenará o diretório <code>/usr</code>, ocupando todo o tamanho restante do VG <code>vg-base</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Para criá-los, execute os comandos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lvcreate -L 512M -n lv-tmp vg-base
Logical volume "lv-tmp" created.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># lvcreate -L 1536M -n lv-var vg-base
Logical volume "lv-var" created.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># lvcreate -l 100%FREE -n lv-usr vg-base
  Logical volume "lv-usr" created.</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos verificar como ficou a situação dos nossos volumes lógicos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lvdisplay | grep 'Logical volume\|LV Path\|LV Name\|LV Size'
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-boot
  LV Name                lv-boot
  LV Size                244,00 MiB
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-swap
  LV Name                lv-swap
  LV Size                244,00 MiB
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-root
  LV Name                lv-root
  LV Size                1,43 GiB
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-tmp
  LV Name                lv-tmp
  LV Size                512,00 MiB
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-var
  LV Name                lv-var
  LV Size                1,50 GiB
  --- Logical volume ---
  LV Path                /dev/vg-base/lv-usr
  LV Name                lv-usr
  LV Size                4,09 GiB</pre>
</div>
</div>
<div class="paragraph">
<p>Naturalmente, o VG está ocupado em sua totalidade, agora:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># vgdisplay | grep PE
  PE Size               4,00 MiB
  Total PE              2047
  Alloc PE / Size       2047 / 8,00 GiB
  Free  PE / Size       0 / 0</pre>
</div>
</div>
<div class="paragraph">
<p>O mesmo pode ser dito para o PV:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pvdisplay | grep PE
  PE Size               4,00 MiB
  Total PE              2047
  Free PE               0
  Allocated PE          2047</pre>
</div>
</div>
</li>
<li>
<p>Apesar de termos criado os LVs para os diretórios <code>/tmp</code>, <code>/var</code> e <code>/usr</code>, nosso trabalho ainda não acabou&#8201;&#8212;&#8201;temos que formatar esses diretórios, copiar o conteúdo dos diretórios atuais para dentro dos novos, configurar a montagem automática via <code>/etc/fstab</code> e apagar os diretórios antigos para liberar espaço.</p>
<div class="paragraph">
<p>Primeiro, vamos formatar os LVs usando o sistema de arquivos <code>ext4</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkfs.ext4 /dev/mapper/vg--base-lv--tmp
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mkfs.ext4 /dev/mapper/vg--base-lv--var
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mkfs.ext4 /dev/mapper/vg--base-lv--usr
(...)</pre>
</div>
</div>
<div class="paragraph">
<p>Apesar de não termos feito nos exemplos acima, este seria um excelente momento para customizar aspectos do sistema de arquivos para adequá-lo aos tipos específicos de arquivos que serão armazenados ali dentro. Por exemplo, pode ser interessante escolher um tamanho de <em>inode</em> menor do que o padrão caso se deseje armazenar muitos arquivos pequenos, como é frequentemente o caso em servidores de e-mail, digamos. Para mais informações, consulte a página de manual <code>man 8 mke2fs</code>.</p>
</div>
<div class="paragraph">
<p>Uma curiosidade: o tamanho padrão de <em>inodes</em> de novos sistemas de arquivos formatados é definido em <code>/etc/mke2fs.conf</code>; este valor pode ser customizado através da <em>flag</em> <code>-I</code> no comando <code>mkfs.ext*</code>.</p>
</div>
</li>
<li>
<p>O próximo passo é montar esses sistemas de arquivo e sincronizar o conteúdo dos diretórios atuais (que estão dentro da raiz, <code>/</code>) com os novos diretórios. Crie um <em>shell script</em>, <code>/root/scripts/syncdirs.sh</code>, com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

for d in tmp var usr; do
  [ -d /mnt/${d} ] || mkdir /mnt/${d}
  mount /dev/mapper/vg--base-lv--${d} /mnt/${d}
  rsync -av /${d}/ /mnt/${d}
  umount /mnt/${d}
  rmdir /mnt/${d}
done</code></pre>
</div>
</div>
<div class="paragraph">
<p>O script acima irá iterar sobre os nomes <code>tmp</code>, <code>var</code> e <code>usr</code>, com o nome <code>DIR</code>. Para cada um deles, fará os passos a seguir:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Criar o diretório <code>/mnt/DIR</code>, se não existir.</p>
</li>
<li>
<p>Montar o volume lógico <code>lv-DIR</code> dentro do diretório <code>/mnt/DIR</code>.</p>
</li>
<li>
<p>Usando o comando <code>rsync</code>, copiar o conteúdo do diretório <code>/DIR</code> para <code>/mnt/DIR</code>.</p>
</li>
<li>
<p>Desmontar o volume lógigo <code>lv-DIR</code>.</p>
</li>
<li>
<p>Remover a pasta <code>/mnt/DIR</code>, se vazia.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Execute o <em>script</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/syncdirs.sh

(...)

sent 551,267 bytes  received 2,023 bytes  368,860.00 bytes/sec
total size is 409,038,950  speedup is 739.28</pre>
</div>
</div>
</li>
<li>
<p>Vamos configurar a montagem automáticas dos novos volumes lógicos. Edite o arquivo <code>/etc/fstab</code> e adicione as linhas a seguir:</p>
<div class="literalblock">
<div class="content">
<pre># nano /etc/fstab
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># tail -n3 /etc/fstab
/dev/mapper/vg--base-lv--tmp  /tmp  ext4  defaults  0  2
/dev/mapper/vg--base-lv--var  /var  ext4  defaults  0  2
/dev/mapper/vg--base-lv--usr  /usr  ext4  defaults  0  2</pre>
</div>
</div>
<div class="paragraph">
<p>Note que estamos usando as opções de montagem <code>defaults</code>, no exemplo acima. Segundo a página de manual do comando <code>mount</code> (que pode ser acessada através do comando <code>man 8 mount</code>), essa opção equivale a <code>rw, suid, dev, exec, auto, nouser, async</code>.</p>
</div>
<div class="paragraph">
<p>Considerando o uso das partições acima, pode ser interessante do ponto de vista de <em>hardening</em> tornar a montagem um pouco mais restritiva. Considere as seguintes opções:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>ro</code>: montar o sistema de arquivos em modo somente-leitura. Inviável para diretórios como <code>/tmp</code> ou <code>/var</code>, embora possa ser considerado para o <code>/usr</code>, por exemplo. O grande inconveniente dessa proteção é que a permissão de escrita terá que ser atribuída manualmente sempre que se quiser escrever no diretório (digamos, durante a instalação de um novo pacote), motivo pelo qual não faremos essa configuração neste curso.</p>
</li>
<li>
<p><code>nosuid</code>: não permitir que <em>bits</em> <em>setuid</em> ou <em>setgid</em> tenham efeito no sistema de arquivos. Antes de colocar em prática, é recomendável escanear o sistema de arquivos por binários desse tipo, como faremos a seguir.</p>
</li>
<li>
<p><code>nodev</code>: não interpretar dispositivos especiais de bloco ou caractere nesse sistema de arquivos. Em geral, apenas o diretório <code>/dev</code> conterá arquivos dessa natureza.</p>
</li>
<li>
<p><code>noexec</code>: não permitir execução direta de quaisquer binários no sistema de arquivos. Não é viável habilitar essa opção para o diretório <code>/usr</code>, por motivos óbvios, mas pode ser uma boa opção para o <code>/tmp</code>, por exemplo&#8201;&#8212;&#8201;muitos <em>exploits</em> simples de escalada de privilégio tentam escrever e executar binários a partir do <code>/tmp</code>, e esta proteção pode dificultar sua ação. Contudo, alguns <em>scripts</em> de instalação de pacotes do Debian tentam executar binários diretamente do <code>/tmp</code>, e habilitá-lo com <code>noexec</code> pode quebrar a instalação desses pacotes&#8201;&#8212;&#8201;assim, não iremos utilizar essa configuração neste curso.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Antes de prosseguir com a customização das opções de montagem, vamos verificar quais binários possuem o <em>bit</em> <em>suid</em> ativo no sistema:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># find / -perm -4000 -exec ls {} \; 2&gt; /dev/null
/bin/mount
/bin/ping
/bin/umount
/bin/su
/usr/lib/openssh/ssh-keysign
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/lib/eject/dmcrypt-get-device
/usr/bin/newgrp
/usr/bin/chsh
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/gpasswd</pre>
</div>
</div>
<div class="paragraph">
<p>Note que temos executáveis nos diretórios <code>/bin</code> e <code>/usr/bin</code>&#8201;&#8212;&#8201;assim, não é factível habilitar a opção <code>nosuid</code> no diretório <code>/usr</code>, neste momento.</p>
</div>
<div class="paragraph">
<p>De posse do conhecimento acima, vamos editar as opções de montagem dos volumes lógicos no arquivo <code>/etc/fstab</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/fstab
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># tail -n3 /etc/fstab
/dev/mapper/vg--base-lv--tmp  /tmp  ext4  defaults,nosuid,nodev         0  2
/dev/mapper/vg--base-lv--var  /var  ext4  defaults,nosuid,nodev         0  2
/dev/mapper/vg--base-lv--usr  /usr  ext4  defaults,nodev                0  2</pre>
</div>
</div>
</li>
<li>
<p>O último passo é reiniciar o sistema e verificar se nossas configurações surtiram efeito. Antes disso, vamos registrar o tamanho ocupado por cada um dos diretórios (<code>tmp</code>, <code>var</code> e <code>usr</code>), e comparar com os tamanhos ocupados nos LVs após o <em>reboot</em>.</p>
<div class="literalblock">
<div class="content">
<pre># du -sm /{tmp,var,usr}
1       /tmp
181     /var
463     /usr</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito. Reinicie a máquina:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># reboot</pre>
</div>
</div>
<div class="paragraph">
<p>Após o <em>reboot</em>, logue como o usuário <code>root</code> e verifique que os volumes lógicos estão montados corretamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mount | grep '/tmp\|/var\|/usr'
/dev/mapper/vg--base-lv--tmp on /tmp type ext4 (rw,nosuid,nodev,relatime,data=ordered)
/dev/mapper/vg--base-lv--var on /var type ext4 (rw,nosuid,nodev,relatime,data=ordered)
/dev/mapper/vg--base-lv--usr on /usr type ext4 (rw,nodev,relatime,data=ordered)</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique, ainda, que o espaço ocupado dentro desses volumes é bastante próximo do tamanho dos diretórios dentro da raiz, <code>/</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># df -m | sed -n '1p; /\/\(tmp\|var\|usr\)/p'
Sist. Arq.                    Blocos de 1M Usado Disponível Uso% Montado em
/dev/mapper/vg--base-lv--tmp           488     1        452   1% /tmp
/dev/mapper/vg--base-lv--var          1480   186       1203  14% /var
/dev/mapper/vg--base-lv--usr          4059   486       3348  13% /usr</pre>
</div>
</div>
</li>
<li>
<p>Faltou alguma coisa? Ah sim! Não apagamos o conteúdo dos diretórios <code>tmp</code>, <code>var</code> e <code>usr</code> de dentro da raiz, <code>/</code>. Note como o espaço ocupado ainda é bastante grande neste momento:</p>
<div class="literalblock">
<div class="content">
<pre># df -m | sed -n '1p; /\/$/p'
Sist. Arq.                    Blocos de 1M Usado Disponível Uso% Montado em
/dev/mapper/vg--base-lv--root         1409   900        421  69% /</pre>
</div>
</div>
<div class="paragraph">
<p>Mas, como apagar esses diretórios? Não podemos simplesmente rodar um comando <code>rm -rf /usr</code>, pois estaríamos removendo os arquivos gravados dentro do volume lógico <code>/dev/mapper/vg&#8212;&#8203;base-lv&#8212;&#8203;usr</code>, e não dentro da raiz. O que fazer, então?</p>
</div>
<div class="paragraph">
<p>A opção <code>bind</code> do comando <code>mount</code> (8) permite remontar um sistema de arquivos em outro ponto da hierarquia de diretórios, tornando seu conteúdo acessível em ambos os lugares. Monte, usando a opção <code>bind</code>, a raiz do sistema dentro do diretório <code>/mnt</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mount -o bind / /mnt</pre>
</div>
</div>
<div class="paragraph">
<p>O diretório raiz, <code>/</code>, agora está acessível também abaixo de <code>/mnt</code>, como podemos observar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls /mnt/
bin   dev  home        initrd.img.old  lib64       media  opt   root  sbin  sys  usr  vmlinuz
boot  etc  initrd.img  lib             lost+found  mnt    proc  run   srv   tmp  var  vmlinuz.old</pre>
</div>
</div>
<div class="paragraph">
<p>O volume lógico <code>/dev/mapper/vg&#8212;&#8203;base-lv&#8212;&#8203;usr</code>, no entanto, está montado apenas abaixo do diretório <code>/usr</code>, e não abaixo de <code>/mnt/usr</code>&#8201;&#8212;&#8201;em outras palavras, a pasta <code>/mnt/usr</code> referencia diretamente o conjunto de arquivos gravados dentro da raiz do sistema, os quais queremos apagar para liberar espaço.</p>
</div>
<div class="paragraph">
<p>Faça um teste&#8201;&#8212;&#8201;crie um arquivo dentro de <code>/usr</code> com o nome <code>teste</code>. Note que ele está acessível pelo caminho <code>/usr/teste</code>, mas não via <code>/mnt/usr/teste</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># touch /usr/teste</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -ld /usr/teste
-rw-r--r-- 1 root root 0 out 18 15:48 /usr/teste</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -ld /mnt/usr/teste
ls: não foi possível acessar '/mnt/usr/teste': Arquivo ou diretório não encontrado</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito! Apague o conteúdo dos diretórios <code>/mnt/tmp</code>, <code>/mnt/var</code> e <code>/mnt/usr</code>, que foram copiados para os volumes lógicos via <code>rsync</code> no passo (9) desta atividade e não são mais necessários. Não apague as pastas em si, pois elas são ponto de montagem desses LVs.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># for d in tmp var usr; do cd /mnt/${d} ; rm -rf ..?* .[!.]* *; done</pre>
</div>
</div>
<div class="paragraph">
<p>Para referência, o comando acima irá entrar nas pastas <code>/mnt/tmp</code>, <code>/mnt/var</code> e <code>/mnt/usr</code>, e, em cada uma irá apagar todos os arquivos e diretórios:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Não-ocultos (<code>*</code>)</p>
</li>
<li>
<p>Ocultos, cujo primeiro caractere seja <code>.</code> e o segundo caractere seja qualquer <em>exceto</em> <code>.</code></p>
</li>
<li>
<p>Ocultos, iniciados por dois caracteres <code>.</code> e seguidos obrigatoriamente por algum outro caractere qualquer</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Com efeito, a expressão regular acima irá apagar todo o conteúdo da pasta exceto os <em>symlinks</em> especiais <code>.</code> e <code>..</code>.</p>
</div>
<div class="paragraph">
<p>Verifique que o espaço ocupado dentro do diretório raiz, <code>/</code>, reduziu significativamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># df -m | sed -n '1p; /\/$/p'
Sist. Arq.                    Blocos de 1M Usado Disponível Uso% Montado em
/dev/mapper/vg--base-lv--root         1409   258       1063  20% /</pre>
</div>
</div>
<div class="paragraph">
<p>Reinicie a máquina virtual para verificar que suas alterações não causaram nenhum impacto à estabilidade do sistema.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_inserção_de_senha_no_bootloader">5) Inserção de senha no <strong><em>bootloader</em></strong></h3>
<div class="paragraph">
<p>Um aspecto que não pode ser esquecido é o <em>bootloader</em>, que faz a carga inicial do kernel&#8201;&#8212;&#8201;se desprotegido, um atacante com acesso físico à máquina pode utilizá-lo para alterar a senha do usuário <code>root</code> e ter acesso irrestrito ao sistema, dentre outras possibilidades.</p>
</div>
<div class="paragraph">
<p>Como vimos durante a instalação do Debian, o <em>bootloader</em> em uso pela grande maioria das distribuições Linux atualmente é o GRUB (<em>GRand Unified Bootloader</em>). Vamos configurar uma senha de acesso ao GRUB para impedir que um atacante consiga ter acesso indevido ao sistema.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Usando o comando <code>grub-mkpasswd-pbkdf2</code>, vamos gerar um hash para a senha <code>rnpesr123</code>.</p>
<div class="literalblock">
<div class="content">
<pre># echo -e 'rnpesr123\nrnpesr123' | grub-mkpasswd-pbkdf2 | awk '/grub.pbkdf/{print$N F}'
grub.pbkdf2.sha512.10000.E025151B0DA98A3153BADD61FCDC2A6037A0505699B7C414D046D834380AB53D20532441EDAFF9B1E330E8496D2C7799E6EFB43C399CC6567D0AFD8961F70109.50A159E523E889A805937F5BB65B4067149D0FDAB0536061015B4345647350A2E09D19580D77D51E58BFDA3432FE2416AE61F90D7F84D1D834CFC979DCBA8F8D</pre>
</div>
</div>
</li>
<li>
<p>Agora, vamos editar o arquivo <code>/etc/grub.d/40_custom</code> e inserir o superusuário <code>admin</code>, com senha idêntica ao hash gerado no passo anterior.</p>
<div class="literalblock">
<div class="content">
<pre># echo 'set superusers="admin"' &gt;&gt; /etc/grub.d/40_custom</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ghash="$( echo -e 'rnpesr123\nrnpesr123' | grub-mkpasswd-pbkdf2 | awk '/grub.pbkdf/{print$NF}' )" ; echo "password_pbkdf2 admin ${ghash}" &gt;&gt; /etc/grub.d/40_custom ; unset ghash</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># tail -n2 /etc/grub.d/40_custom
set superusers="admin"
password_pbkdf2 admin grub.pbkdf2.sha512.10000.65E70B724A540A0AE79C2F6BB34AFC4397BB13952D20A9C209DD70A9F31FE462D301B733D8B1B308C67908A25B44AB09420CEB306EDAEEB15765905A7DEEB3BF.209A3080C89ED4C542716B9BE14162E8338DF8E36B68F9E0146BDC8E572CF41585F6BF67C2573AFF2645F0D851A8E9D5B6AA2E4608E4735E689FA84ECA815C14</pre>
</div>
</div>
</li>
<li>
<p>Finalmente, vamos reconfigurar o GRUB com a nova combinação usuário/senha e reiniciar a máquina. Verifique se a configuração está funcionando.</p>
<div class="literalblock">
<div class="content">
<pre># grub-mkconfig -o /boot/grub/grub.cfg
Generating grub configuration file ...
Imagem Linux encontrada: /boot/vmlinuz-4.9.0-8-amd64
Imagem initrd encontrada: /boot/initrd.img-4.9.0-8-amd64
concluído</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># reboot</pre>
</div>
</div>
<div class="paragraph">
<p>Após o <em>boot</em> da máquina, o menu do GRUB nos apresenta a possibilidade de editar a configuração apertando a tecla <code>e</code>:</p>
</div>
<div id="img-grub-passwd1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/grub-passwd1.png" alt="grub passwd1">
</div>
<div class="title">Figure 19. Edição de opções no GRUB</div>
</div>
<div class="paragraph">
<p>Apertando <code>e</code> sobre a primeira opção, imediatamente o sistema requisita a combinação usuário/senha configurada anteriormente:</p>
</div>
<div id="img-grub-passwd2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/grub-passwd2.png" alt="grub passwd2">
</div>
<div class="title">Figure 20. Inserção de usuário/senha no GRUB</div>
</div>
<div class="paragraph">
<p>Mediante a inserção da combinação correta, o menu de edição de opções de <em>boot</em> é mostrado, como se segue.</p>
</div>
<div id="img-grub-passwd3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/grub-passwd3.png" alt="grub passwd3">
</div>
<div class="title">Figure 21. Edição de opções de boot no GRUB</div>
</div>
<div class="paragraph">
<p>Note ainda que, com esta configuração, o <em>boot</em> normal do sistema prossegue apenas se a combinação de usuário/senha correta for inserida no GRUB.</p>
</div>
</li>
<li>
<p>Vamos editar a configuração do GRUB para que ele solicite senha <strong>apenas</strong> em caso de edição de entradas do menu, e que o <em>boot</em> normal do sistema prossiga sem que haja necessidade de interação.</p>
<div class="paragraph">
<p>Para conseguir o efeito desejado, é necessário editar o arquivo <code>/etc/grub.d/10_linux</code>. Na função <code>linux_entry()</code>, iremos editar as duas linhas <code>echo "menuentry (&#8230;&#8203;)</code>, inserindo a flag <code>--unrestricted</code> antes da variável <code>${CLASS}</code>.</p>
</div>
<div class="paragraph">
<p>Vamos ver um antes/depois para ficar mais claro. Veja como estão as linhas 132-134 do arquivo <code>/etc/grub.d/10_linux</code> antes da edição:</p>
</div>
<div class="listingblock">
<div class="title">Listing 1. /etc/grub.d/10_linux</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">132       echo "menuentry '$(echo "$title" | grub_quote)' ${CLASS} \$menuentry_id_option 'gnulinux-$version-$type-$boot_device_id' {" | sed "s/^/$submenu_indentation/"
133   else
134       echo "menuentry '$(echo "$os" | grub_quote)' ${CLASS} \$menuentry_id_option 'gnulinux-simple-$boot_device_id' {" | sed "s/^/$submenu_indentation/"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Após a edição, elas devem ficar assim:</p>
</div>
<div class="listingblock">
<div class="title">Listing 2. /etc/grub.d/10_linux</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">132       echo "menuentry '$(echo "$title" | grub_quote)' --unrestricted ${CLASS} \$menuentry_id_option 'gnulinux-$version-$type-$boot_device_id' {" | sed "s/^/$submenu_indentation/"
133   else
134       echo "menuentry '$(echo "$os" | grub_quote)' --unrestricted ${CLASS} \$menuentry_id_option 'gnulinux-simple-$boot_device_id' {" | sed "s/^/$submenu_indentation/"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note a adição da <code>flag</code> <code>--unrestricted</code> antes de <code>${CLASS}</code> nas linhas 132 e 134.</p>
</div>
<div class="paragraph">
<p>Refaça a configuração do GRUB, reinicie a máquina e teste o funcionamento.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># update-grub
Generating grub configuration file ...
Imagem Linux encontrada: /boot/vmlinuz-4.9.0-8-amd64
Imagem initrd encontrada: /boot/initrd.img-4.9.0-8-amd64
concluído</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># reboot</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_clonando_máquinas_virtuais">6) Clonando máquinas virtuais</h3>
<div class="paragraph">
<p>Nosso <em>template</em>, para todos os efeitos, está preparado, atualizado e com configurações básicas de segurança aplicadas. Assim sendo, podemos utilizá-lo como base para a criação de novas máquinas virtuais durante este curso, começando a partir de agora.</p>
</div>
<div class="paragraph">
<p>Contudo, o Oracle VM Virtualbox não suporta o conceito de <em>templates</em> "a rigor", da mesma forma como interpretado em outras soluções de virtualização (como VMWare e Hyper-V). Para emular esse conceito de <em>templates</em>, sempre que necessário iremos clonar a máquina virtual <code>debian-template</code> e renomear a VM-clone, garantindo que o endereço físico (MAC) da placa de rede seja randomizado para evitar conflitos de IP.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Desligue a máquina <code>debian-template</code>:</p>
<div class="literalblock">
<div class="content">
<pre># halt -p</pre>
</div>
</div>
</li>
<li>
<p>Na janela principal do Virtualbox, clique com o botão direito na máquina <code>debian-template</code> e selecione a opção <em>Clone&#8230;&#8203;</em>.</p>
<div class="paragraph">
<p>Na tela seguinte, indique qual o nome da nova máquina virtual: para este exemplo, defina o nome <code>lvm-test</code>. Mantenha a caixa <em>Reinitialize the MAC address of all network cards</em> marcada.</p>
</div>
<div id="img-vbox-clone1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/vbox-clone1.png" alt="vbox clone1">
</div>
<div class="title">Figure 22. Clonagem de máquinas virtuais no Virtualbox</div>
</div>
<div class="paragraph">
<p>Clique em <em>Next</em>.</p>
</div>
</li>
<li>
<p>Na janela seguinte, você pode escolher se deseja fazer um clone completo (<em>Full clone</em>), ou um clone ligado (<em>Linked clone</em>). A diferença entre ambos é que no caso do clone completo é criada uma cópia separada do disco da VM original, ao passo que no clone ligado faz-se apenas um <em>snapshot</em> desse disco.</p>
<div class="paragraph">
<p>Mantenha <em>Full clone</em> marcado e clique em <em>Clone</em>.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_7_operações_avançadas_com_lvm">7) Operações avançadas com LVM</h3>
<div class="paragraph">
<p>Imagine que a máquina que acabamos de criar, <code>lvm-test</code>, será usada para dois propósitos: 1) atuar como um servidor de e-mail, armazenando as mensagens dos usuários da organização sob a pasta <code>/var/mail</code> e 2) armazenar dados sensíveis da organização, que devem ser acessados apenas por um número muito restrito de usuários, sob a pasta <code>/crypt</code>.</p>
</div>
<div class="paragraph">
<p>Vamos lidar com a situação (1), primeiramente.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Opere com a máquina recém-clonada, <code>lvm-test</code>. Na janela principal do Virtualbox, clique com o botão direito sobre a VM e depois em <em>Settings</em>.</p>
<div class="paragraph">
<p>Em <em>Storage</em> &gt; <em>Controller: SATA</em>, clique no ícone com um pequeno HD com um sinal de <code>+</code>, com a legenda <em>Adds hard disk</em> para adicionar um novo disco à VM. Depois, clique em <em>Create new disk</em>.</p>
</div>
<div class="paragraph">
<p>Para o formato, escolha <em>VDI</em> e clique em <em>Next</em>. Mantenha a caixa <em>Dynamically allocated</em> marcada e clique em <em>Next</em>.</p>
</div>
<div class="paragraph">
<p>Para o nome do disco, digite <code>lvm-pv2</code> e mantenha o tamanho em 8 GB. Finalmente, clique em <em>Create</em>.</p>
</div>
</li>
<li>
<p>Repita o passo (1), adicionando um terceiro disco à VM. Desta vez, nomeie o disco como <code>lvm-crypt</code> e mantenha seu tamanho em 8 GB.</p>
<div class="paragraph">
<p>Ao final do processo, sua VM deverá estar com a seguinte configuração:</p>
</div>
<div id="img-lvm-test-config" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/lvm-test-config.png" alt="lvm test config">
</div>
<div class="title">Figure 23. Discos adicionados à máquina lvm-test</div>
</div>
<div class="paragraph">
<p>Clique em <em>OK</em>, e ligue a máquina <code>lvm-test</code>.</p>
</div>
</li>
<li>
<p>Usando o script <code>/root/scripts/changehost.sh</code> que criamos anteriormente, renomeie a máquina:</p>
<div class="literalblock">
<div class="content">
<pre># hostname
debian-template</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh lvm-test</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname
lvm-test</pre>
</div>
</div>
</li>
<li>
<p>Prosseguindo com o tratamento do requisito (1), abordado no enunciado desta atividade, note que o espaço disponível no <code>/var</code> atualmente é bastante exíguo:</p>
<div class="literalblock">
<div class="content">
<pre># df -h | sed -n '1p; /\/var$/p'
Sist. Arq.                     Tam. Usado Disp. Uso% Montado em
/dev/mapper/vg--base-lv--var   1,5G  185M  1,2G  14% /var</pre>
</div>
</div>
<div class="paragraph">
<p>Iremos utilizar o primeiro disco adicionado à VM, <code>lvm-pv2</code>, para aumentar o tamanho disponível para o diretório <code>/var</code>. Queremos, em ordem:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identificar sob qual nome o disco <code>lvm-pv2</code> foi identificado pelo sistema Linux</p>
</li>
<li>
<p>Adicionar a totalidade do disco <code>lvm-pv2</code> ao grupo de volumes <code>vg-base</code></p>
</li>
<li>
<p>Estender o volume lógico <code>lv-var</code> para usar o espaço extra disponível no VG <code>vg-base</code></p>
</li>
<li>
<p>Estender o sistema de arquivos do dispositivo <code>/dev/mapper/vg&#8212;&#8203;base-lv&#8212;&#8203;var</code> para utilizar o espaço extra disponível no LV <code>lv-var</code></p>
</li>
<li>
<p>Verificar o aumento do espaço disponível</p>
</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<p>Primeiramente, temos que detectar sob qual nome foi adicionado o disco virtual <code>lvm-pv2</code>. O comando <code>dmesg</code> nos mostra que três discos foram detectados durante o <em>boot</em>:</p>
<div class="literalblock">
<div class="content">
<pre># dmesg | grep 'Attached SCSI disk'
[    1.924154] sd 2:0:0:0: [sdc] Attached SCSI disk
[    1.924182] sd 1:0:0:0: [sdb] Attached SCSI disk
[    1.936628] sd 0:0:0:0: [sda] Attached SCSI disk</pre>
</div>
</div>
<div class="paragraph">
<p>Desses, sabemos que o dispositivo <code>/dev/sda</code> é o disco original que criamos durante a instalação do sistema, já que ele se encontra formatado e em uso pelo LVM:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pvdisplay
  --- Physical volume ---
  PV Name               /dev/sda1
  VG Name               vg-base
  PV Size               8,00 GiB / not usable 2,00 MiB
  Allocatable           yes (but full)
  PE Size               4,00 MiB
  Total PE              2047
  Free PE               0
  Allocated PE          2047
  PV UUID               ZnHHMn-Y37D-6Psd-oHei-K1Qd-wHjY-6gqFZ3</pre>
</div>
</div>
<div class="paragraph">
<p>Restam, então, os discos <code>/dev/sdb</code> e <code>/dev/sdc</code>. Em tese, poderíamos usar a diferença de tamanho entre os discos para intuir qual deles é o volume <code>lvm-pv2</code>, e qual é o <code>lvm-crypt</code>. Contudo, ambos possuem o mesmo tamanho, 8 GB. O que fazer, então?</p>
</div>
<div class="paragraph">
<p>Para determinar com precisão essa informação, na janela principal do Virtualbox acesse <em>File</em> &gt; <em>Virtual Media Manager</em>. Na aba <em>Hard disks</em>, selecione o disco <code>lvm-pv2.vdi</code> e acesse a aba <em>Information</em>, como mostrado abaixo:</p>
</div>
<div id="img-lvm-disk1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/lvm-disk1.png" alt="lvm disk1">
</div>
<div class="title">Figure 24. Identificando o UUID de um disco no Virtualbox</div>
</div>
<div class="paragraph">
<p>Note as <em>strings</em> inicial e final do campo <em>UUID</em> (<em>Universally Unique Identifier</em>), <code>b247f9cb</code> e <code>016039606b8a</code> respectivamente no exemplo acima.</p>
</div>
<div class="paragraph">
<p>De volta à máquina <code>lvm-test</code>, execute o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hdparm -i /dev/sdb | grep 'SerialNo' | cut -d',' -f3
 SerialNo=VBb247f9cb-8a6b6039</pre>
</div>
</div>
<div class="paragraph">
<p>Excluindo-se as letras <code>VB</code> do <em>serial</em> acima, note que a <em>string</em> <code>b247f9cb</code> é idêntica à que visualizamos no Virtualbox. De igual modo, a <em>string</em> <code>8a6b6039</code> é uma reversão dois-a-dois do final da <em>string</em> identificada no <em>Virtual Media Manager</em> do Virtualbox, anteriormente. Portanto, podemos afirmar com segurança que o disco <code>/dev/sdb</code> é o volume virtual <code>lvm-pv2</code>.</p>
</div>
<div class="paragraph">
<p>Faça o teste com o volume <code>lvm-crypt</code> e o disco <code>/dev/sdc</code>. As <em>strings</em> identificadoras do campo <em>UUID</em> são compatíveis?</p>
</div>
</li>
<li>
<p>Identificado o disco <code>/dev/sdb</code> como nosso alvo, e como desejamos adicionar um disco inteiro ao VG <code>vg-base</code>, o primeiro passo é editar a tabela de partições do disco corretamente. Para tanto, basta criar uma partição primária ocupando a totalidade do disco, e identificá-la como <code>Linux LVM</code>.</p>
<div class="literalblock">
<div class="content">
<pre># fdisk /dev/sdb

Bem-vindo ao fdisk (util-linux 2.29.2).
As alterações permanecerão apenas na memória, até que você decida gravá-las.
Tenha cuidado antes de usar o comando de gravação.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): o
Criado um novo rótulo de disco DOS com o identificador de disco 0xe7d643f2.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): n
Tipo da partição
   p   primária (0 primárias, 0 estendidas, 4 livre)
   e   estendida (recipiente para partições lógicas)
Selecione (padrão p):

Usando resposta padrão p.
Número da partição (1-4, padrão 1):
Primeiro setor (2048-16777215, padrão 2048):
Último setor, +setores ou +tamanho{K,M,G,T,P} (2048-16777215, padrão 16777215):

Criada uma nova partição 1 do tipo "Linux" e de tamanho 8 GiB.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): t
Selecionou a partição 1
Tipo de partição (digite L para listar todos os tipos): 8e
O tipo da partição "Linux" foi alterado para "Linux LVM".</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): w
A tabela de partição foi alterada.
Chamando ioctl() para reler tabela de partição.
Sincronizando discos.</pre>
</div>
</div>
<div class="paragraph">
<p>Em ordem, executamos <code>fdisk /dev/sdb</code> para editar a tabela de partições do dispositivo e então:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>o</code> para criar uma tabela de partições vazia</p>
</li>
<li>
<p><code>n</code> para criar uma nova partição</p>
</li>
<li>
<p><code>ENTER</code> para aceitar o tipo padrão de partição (primária)</p>
</li>
<li>
<p><code>ENTER</code> para aceitar o número padrão de partição (número <code>1</code>)</p>
</li>
<li>
<p><code>ENTER</code> para aceitar o primeiro setor disponível no disco (2048)</p>
</li>
<li>
<p><code>ENTER</code> para aceitar o último setor disponível no disco (16777215), maximizando o tamanho da partição</p>
</li>
<li>
<p><code>t</code> para alterar o identificador da partição</p>
</li>
<li>
<p><code>8e</code> para identificar a partição como <code>Linux LVM</code></p>
</li>
<li>
<p><code>w</code> para gravar as alterações realizadas e sair do programa</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Para visualizar o estado do disco, podemos usar <code>fdisk -l</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># fdisk -l /dev/sdb
Disco /dev/sdb: 8 GiB, 8589934592 bytes, 16777216 setores
Unidades: setor de 1 * 512 = 512 bytes
Tamanho de setor (lógico/físico): 512 bytes / 512 bytes
Tamanho E/S (mínimo/ótimo): 512 bytes / 512 bytes
Tipo de rótulo do disco: dos
Identificador do disco: 0xe7d643f2

Dispositivo Inicializar Início      Fim  Setores Tamanho Id Tipo
/dev/sdb1                 2048 16777215 16775168      8G 8e Linux LVM</pre>
</div>
</div>
<div class="paragraph">
<p>A seguir, usaremos o comando <code>pvcreate</code> para inicializar a partição e prepará-la para o LVM:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pvcreate /dev/sdb1
  Physical volume "/dev/sdb1" successfully created.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># pvdisplay /dev/sdb1
  "/dev/sdb1" is a new physical volume of "8,00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdb1
  VG Name
  PV Size               8,00 GiB
  Allocatable           NO
  PE Size               0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               FdZmMJ-ZFdQ-vi0z-lc5r-9Zy2-zfbR-1uJbuj</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>pvscan</code> é uma opção interessante para mostrar o estado dos volumes físicos do sistema:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pvscan
  PV /dev/sda1   VG vg-base         lvm2 [8,00 GiB / 0    free]
  PV /dev/sdb1                      lvm2 [8,00 GiB]
  Total: 2 [16,00 GiB] / in use: 1 [8,00 GiB] / in no VG: 1 [8,00 GiB]</pre>
</div>
</div>
</li>
<li>
<p>Agora sim, podemos adicionar o novo volume físico <code>/dev/sdb1</code> ao grupo de volumes <code>vg-base</code>. Note seu espaço atual:</p>
<div class="literalblock">
<div class="content">
<pre># vgdisplay | grep 'VG Name\|VG Size'
  VG Name               vg-base
  VG Size               8,00 GiB</pre>
</div>
</div>
<div class="paragraph">
<p>Expanda o VG:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># vgextend vg-base /dev/sdb1
  Volume group "vg-base" successfully extended</pre>
</div>
</div>
<div class="paragraph">
<p>Verificando o estado do VG <code>vg-base</code>, note que seu tamanho saltou para 16 GB, como esperado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># vgdisplay | grep 'VG Name\|VG Size'
  VG Name               vg-base
  VG Size               15,99 GiB</pre>
</div>
</div>
</li>
<li>
<p>A seguir, iremos estender o volume lógico <code>lv-var</code> para utilizar a totalidade do novo espaço adicionado ao VG. Note seu espaço atual:</p>
<div class="literalblock">
<div class="content">
<pre># lvdisplay /dev/vg-base/lv-var | grep Size
  LV Size                1,50 GiB</pre>
</div>
</div>
<div class="paragraph">
<p>Façamos o procedimento de expansão:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lvextend -l +100%FREE /dev/vg-base/lv-var
  Size of logical volume vg-base/lv-var changed from 1,50 GiB (384 extents) to 9,50 GiB (2431 extents).
  Logical volume vg-base/lv-var successfully resized.</pre>
</div>
</div>
<div class="paragraph">
<p>E em seguida, chequemos o novo tamanho disponível:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lvdisplay /dev/vg-base/lv-var | grep Size
  LV Size                9,50 GiB</pre>
</div>
</div>
</li>
<li>
<p>O passo final é redimensionar o sistema de arquivos. Como queremos simplesmente ocupar a totalidade do volume lógico, e kernels mais modernos do Linux suportam <em>on-line resizing</em> (i.e. redimensionamento sem necessidade de desmontar o sistema de arquivos), basta executar:</p>
<div class="literalblock">
<div class="content">
<pre># resize2fs /dev/mapper/vg--base-lv--var
resize2fs 1.43.4 (31-Jan-2017)
Filesystem at /dev/mapper/vg--base-lv--var is mounted on /var; on-line resizing required
old_desc_blocks = 1, new_desc_blocks = 2
The filesystem on /dev/mapper/vg--base-lv--var is now 2489344 (4k) blocks long.</pre>
</div>
</div>
<div class="paragraph">
<p>Note, imediatamente, que o espaço disponível para o <code>/var</code> aumenta significativamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># df -h | sed -n '1p; /\/var$/p'
Sist. Arq.                     Tam. Usado Disp. Uso% Montado em
/dev/mapper/vg--base-lv--var   9,4G  188M  8,8G   3% /var</pre>
</div>
</div>
<div class="paragraph">
<p>E assim, concluímos nossa seção sobre o LVM. É um sistema muito poderoso, que oferece grande flexibilidade na gestão de armazenamento no Linux. Imagine: qual teria sido a dificuldade em estender o espaço disponível para o <code>/var</code> em um sistema sem o uso do LVM?</p>
</div>
<div class="paragraph">
<p>Outros aspectos avançados do LVM, como gestão de volumes <em>striped</em> (concatenados) e <em>mirrored</em> (espelhados), provisionamento dinâmico de espaço e <em>snapshots</em> não foram trabalhados aqui. Convidamos o aluno a investigar essas capacidades, e testar suas funcionalidades em ambiente de laboratório. A documentação do Red Hat Enterprise Linux sobre o LVM é um excelente recurso para começar: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/lv_overview" class="bare">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/lv_overview</a></p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_8_criptografia_de_partições">8) Criptografia de partições</h3>
<div class="paragraph">
<p>Retomando o requisito (2) apresentado na atividade (7), foi dito que se desejava: armazenar dados sensíveis da organização, que devem ser acessados apenas por um número muito restrito de usuários, sob a pasta <code>/crypt</code>.</p>
</div>
<div class="paragraph">
<p>Vamos, agora, implementar esse requisito na máquina <code>lvm-test</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A solução que iremos implantar para garantir o requisito é criptografar a partição. Para tanto, precisaremos instalar os seguintes pacotes:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install cryptsetup -y</pre>
</div>
</div>
</li>
<li>
<p>Prepare o disco <code>/dev/sdc</code> da mesma forma que fizemos no passo (6) da atividade anterior. Ao final do processo, a saída do comando <code>pvdisplay /dev/sdc1</code> deve ser como mostrada abaixo:</p>
<div class="literalblock">
<div class="content">
<pre># pvdisplay /dev/sdc1
  "/dev/sdc1" is a new physical volume of "8,00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdc1
  VG Name
  PV Size               8,00 GiB
  Allocatable           NO
  PE Size               0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               JKRAlt-0sgK-d0np-3N3J-JRyE-YDbG-0cdZee</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar um novo VG para armazenar dados sensíveis. Execute:</p>
<div class="literalblock">
<div class="content">
<pre># vgcreate vg-crypt /dev/sdc1
  Volume group "vg-crypt" successfully created</pre>
</div>
</div>
</li>
<li>
<p>O próximo passo é criar um volume lógico:</p>
<div class="literalblock">
<div class="content">
<pre># lvcreate -l +100%FREE -n lv-crypt vg-crypt
  Logical volume "lv-crypt" created.</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que o LV foi criado corretamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lvdisplay /dev/vg-crypt/lv-crypt
  --- Logical volume ---
  LV Path                /dev/vg-crypt/lv-crypt
  LV Name                lv-crypt
  VG Name                vg-crypt
  LV UUID                mMOiAc-Q7Yo-hgjN-rb2S-mzfr-youw-PnHGRC
  LV Write Access        read/write
  LV Creation host, time lvm-test, 2018-10-19 11:12:42 -0300
  LV Status              available
  # open                 0
  LV Size                8,00 GiB
  Current LE             2047
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           254:6</pre>
</div>
</div>
</li>
<li>
<p>Agora, vamos criptografar esse LV&#8201;&#8212;&#8201;o comando <code>cryptsetup</code> pode ser usado para este fim. Iremos criptografar o disco no formato LUKS (<em>Linux Unified Key Setup</em>), o padrão para criptografia de armazenamento no Linux. Diferentemente de outras soluções de criptografia, o LUKS armazena todas as informações de configuração no cabeçalho da partição, permitindo ao usuário migrar seus dados de forma fácil entre diferentes distribuições Linux ou mesmo outros sistemas operacionais.</p>
<div class="paragraph">
<p>A cifra padrão de criptografia do LUKS pode ser visualizada com o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cryptsetup --help | grep 'LUKS1:'
        LUKS1: aes-xts-plain64, Chave: 256 bits, Hash de cabeçalho LUKS: sha256, RNG: /dev/urandom</pre>
</div>
</div>
<div class="paragraph">
<p>Para criptografar a partição, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cryptsetup luksFormat /dev/mapper/vg--crypt-lv--crypt

WARNING!
========
Isto vai sobrescrever dados em /dev/mapper/vg--crypt-lv--crypt permanentemente.

Are you sure? (Type uppercase yes): YES
Digite a senha:
Verificar senha:</pre>
</div>
</div>
<div class="paragraph">
<p>Digite <em>YES</em> em letras maiúsculas para confirmar sobrescrita dos dados. Escolha uma senha forte para proteger os dados. Neste laboratório, recomendamos a senha <code>rnpesr123</code>, por conveniência.</p>
</div>
</li>
<li>
<p>Como saber que uma partição está criptografada? E, de fato, como saber o tipo de uma partição qualquer? O comando <code>lsblk</code> é especialmente útil nesse cenário:</p>
<div class="literalblock">
<div class="content">
<pre># lsblk --fs
NAME                    FSTYPE      LABEL UUID                                   MOUNTPOINT
sda
└─sda1                  LVM2_member       n3dXDL-gCma-P258-pl31-Ow9A-Spcp-2mjsCG
  ├─vg--base-lv--boot   ext2              ebda5914-0f0c-4e7e-91fc-dbb978a2f870   /boot
  ├─vg--base-lv--swap   swap              fcf0e5dd-d744-4acc-aff4-65aa2219fde2   [SWAP]
  ├─vg--base-lv--root   ext4              bfebe607-ef84-4ac8-8ce0-54dded08ae9e   /
  ├─vg--base-lv--tmp    ext4              3db27de5-69ae-4db7-baba-2de5a4576942   /tmp
  ├─vg--base-lv--var    ext4              2a13673c-4266-4683-a548-d66b0c1078b1   /var
  └─vg--base-lv--usr    ext4              5621572f-4786-4cb6-8826-2dae623b3e5d   /usr
sdb
└─sdb1                  LVM2_member       FdZmMJ-ZFdQ-vi0z-lc5r-9Zy2-zfbR-1uJbuj
  └─vg--base-lv--var    ext4              2a13673c-4266-4683-a548-d66b0c1078b1   /var
sdc
└─sdc1                  LVM2_member       JKRAlt-0sgK-d0np-3N3J-JRyE-YDbG-0cdZee
  └─vg--crypt-lv--crypt crypto_LUKS       2f10b9c6-aab3-4038-b74c-6bab83e658fe
sr0</pre>
</div>
</div>
<div class="paragraph">
<p>Note que o LV que acabamos de criar e criptografar, <code>lv-crypt</code>, possui o tipo de sistema de arquivos <code>crypto_LUKS</code>. Note, ainda, que ele não está montado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mount | grep 'lv--crypt'</pre>
</div>
</div>
</li>
<li>
<p>O próximo passo é formatar a partição. Contudo, para acessar partições LUKS, temos primeiro que mapeá-la sob um nome&#8201;&#8212;&#8201;execute:</p>
<div class="literalblock">
<div class="content">
<pre># cryptsetup luksOpen /dev/mapper/vg--crypt-lv--crypt seg10-crypt
Digite a senha para /dev/mapper/vg--crypt-lv--crypt:</pre>
</div>
</div>
<div class="paragraph">
<p>Para verificar os nomes mapeados, novamente podemos usar o <code>lsblk</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lsblk /dev/sdc
NAME                    MAJ:MIN RM SIZE RO TYPE  MOUNTPOINT
sdc                       8:32   0   8G  0 disk
└─sdc1                    8:33   0   8G  0 part
  └─vg--crypt-lv--crypt 254:6    0   8G  0 lvm
    └─seg10-crypt       254:7    0   8G  0 crypt</pre>
</div>
</div>
<div class="paragraph">
<p>Com o dispositivo <code>/dev/mapper/vg&#8212;&#8203;crypt-lv&#8212;&#8203;crypt</code> mapeado para <code>/dev/mapper/seg10-crypt</code>, podemos, agora sim, formatar a partição:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkfs.ext4 /dev/mapper/seg10-crypt
mke2fs 1.43.4 (31-Jan-2017)
Creating filesystem with 2095616 4k blocks and 524288 inodes
Filesystem UUID: 5740608c-8609-4d95-ae9b-73a016765610
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632

Allocating group tables: done
Writing inode tables: done
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done</pre>
</div>
</div>
<div class="paragraph">
<p>E, finalmente, montá-la:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mount /dev/mapper/seg10-crypt /mnt/</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mount | grep '/mnt'
/dev/mapper/seg10-crypt on /mnt type ext4 (rw,relatime,data=ordered)</pre>
</div>
</div>
</li>
<li>
<p>Após gravar dados na partição criptografada, temos que fazer o caminho oposto. Primeiro, desmontá-la:</p>
<div class="literalblock">
<div class="content">
<pre># umount /mnt</pre>
</div>
</div>
<div class="paragraph">
<p>E, em seguida, remover o mapeamento por nome da partição LUKS:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cryptsetup luksClose seg10-crypt</pre>
</div>
</div>
</li>
<li>
<p>Concluídas nossas atividades de exemplo com o LVM e criptografia de partições, desligue a máquina <code>lvm-test</code>:</p>
<div class="literalblock">
<div class="content">
<pre># halt -p</pre>
</div>
</div>
<div class="paragraph">
<p>Como não utilizaremos mais esta máquina no decorrer do curso, vamos removê-la. Na janela principal do Virtualbox, clique com o botão direito sobre a VM <code>lvm-test</code> e selecione <em>Remove</em>. Na nova janela, clique em <em>Delete all files</em> para remover todos os discos associados à máquina.</p>
</div>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_2_firewall_e_dns">Sessão 2: Firewall e DNS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O ponto de partida para a segurança da rede em qualquer organização é, certamente, o <em>firewall</em>. Utilizando-se do princípio de segurança do <em>chokepoint</em>, ou gargalo, tem como premissa atuar como um ponto focal no controle do tráfego de rede, permitindo aos administradores configurar acessos e proibições de acordo com as políticas organizacionais. Conceitualmente, o firewall consiste em um filtro de pacotes e tem sua atuação restrita até a camada 4 (transporte) do modelo OSI, ficando a tarefa de filtragem em nível de aplicação para outros programas e <em>appliances</em> de controle da rede, como IDSs (<em>Intrusion Detection System</em>), IPSs (<em>Intrusion Protection System</em>), <em>proxies</em> ou WAFs (<em>Web Application Firewalls</em>).</p>
</div>
<div class="paragraph">
<p>Juntamente com o firewall, o serviço de resolução de nomes (DNS, ou <em>Domain Name System</em>) também é peça-chave na segurança da rede. Provendo um serviço essencial&#8201;&#8212;&#8201;tradução de endereços de rede para nomes e vice-versa&#8201;&#8212;&#8201;o serviço DNS deve ser cuidadosamente configurado pelos administradores para evitar ataques de <em>spoofing</em> e prover redundância em caso de falhas inesperadas. Os servidores DNS se dividem em primário, secundário e recursivo; destes, os dois primeiros são responsáveis por responder por um domínio de rede (ditos <strong>autoritativos</strong>, portanto), e o último apenas funciona como uma fonte de consulta e <em>cache</em> para os clientes da rede.</p>
</div>
<div class="paragraph">
<p>Neste curso, faremos uma configuração extremamente restritiva do firewall de nosso <em>datacenter</em> simulado, e a cada novo serviço implementado iremos retornar à sua configuração para abrir as portas e protocolos adequados. Já no caso do DNS, configuraremos um servidor primário/secundário autoritativo com suporte a DNSSEC para a rede interna <code>intnet.</code>, restringindo todas as máquinas a realizarem suas consultas exclusivamente nesses servidores. Iremos, ainda, configurar um servidor DNS recursivo em um <em>daemon</em> distinto exclusivamente para consultas e <em>cache</em> de resultados, visando o aumento da segurança do sistema de resolução de nomes.</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>A figura abaixo mostra a topologia de rede que será utilizada nesta sessão, com as máquinas relevantes em destaque.</p>
</div>
<div id="img-topologia2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/Topologia_SEG10_S2.png" alt="Topologia SEG10 S2">
</div>
<div class="title">Figure 25. Topologia de rede desta sessão</div>
</div>
<div class="paragraph">
<p>Teremos apenas duas máquinas, por enquanto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ns1</code>, atuando como firewall de rede e DNS primário. Endereços IP via DHCP (interface <em>bridge</em>), 10.0.42.1/24 (interface DMZ) e 192.168.42.1/24 (interface Intranet).</p>
</li>
<li>
<p><code>ns2</code>, atuando como DNS secundário e localizada na DMZ (<em>Demilitarized Zone</em>, ou zona desmilitarizada). Endereço IP 10.0.42.2/24.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Antes de começarmos, precisamos configurar corretamente as redes virtuais no Virtualbox. Acesse o menu <em>File</em> &gt; <em>Host Network Manager</em> e crie as seguintes redes:</p>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Redes <em>host-only</em> no Virtualbox</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Rede</th>
<th class="tableblock halign-left valign-top">Endereço IPv4</th>
<th class="tableblock halign-left valign-top">Máscara de rede</th>
<th class="tableblock halign-left valign-top">Servidor DHCP</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtualbox Host-Only Ethernet Adapter #2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.42.254</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.255.255.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Desabilitado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtualbox Host-Only Ethernet Adapter #3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">192.168.42.254</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.255.255.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Desabilitado</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Visualmente, sua janela deve ficar parecida com o seguinte:</p>
</div>
<div id="img-vbox-networks" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/vbox-networks.png" alt="vbox networks">
</div>
<div class="title">Figure 26. Redes host-only no Virtualbox</div>
</div>
<div class="paragraph">
<p>É possível que os números específicos das redes (<code>#2</code> para a DMZ e <code>#3</code> para a Intranet, na imagem acima) não fiquem exatamente iguais aos exemplificados. Nesse caso, faça uma anotação indicando qual número de rede <em>host-only</em> corresponde a cada uma das redes configuradas. Verifique, ainda, que o servidor DHCP interno do Virtualbox está desabilitado em ambas as redes.</p>
</div>
<div style="page-break-after: always;"></div>
</li>
<li>
<p>As configurações de rede realizadas internamente em cada máquina virtual foram apresentados de forma sucinta na topologia desta sessão. Iremos detalhar as configurações logo abaixo:</p>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Configurações de rede de cada VM</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-middle">VM Nome</th>
<th class="tableblock halign-left valign-middle">Interface</th>
<th class="tableblock halign-left valign-middle">Modo</th>
<th class="tableblock halign-left valign-middle">Endereço</th>
<th class="tableblock halign-left valign-middle">Gateway</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="3"><p class="tableblock">ns1</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">enp0s3</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">DHCP</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Automático</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Automático</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">enp0s8</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Estático</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">10.0.42.1/24</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">n/a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">enp0s9</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Estático</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">192.168.42.1/24</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">n/a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">ns2</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">enp0s3</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Estático</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">10.0.42.2/24</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">10.0.42.1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A partir do Debian 9, a nomenclatura padrão de interfaces de rede foi alterada. Ao invés de denotarmos as interfaces como <code>eth0</code>, <code>eth1</code> ou <code>eth2</code>, o <code>systemd/udev</code> utiliza, a partir da versão v197, um método de nomenclatura de interfaces usando <em>biosdevnames</em>, como documentado oficialmente em <a href="https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/" class="bare">https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/</a> . Com efeito, esse novo sistema suporta cinco meios de nomeação de interfaces de rede:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Nomes incorporando números de índice providos pelo firmware/BIOS de dispositivos <em>on-board</em> (p.ex.: <code>eno1</code>)</p>
</li>
<li>
<p>Nomes incorporando números de índice providos pelo firmware/BIOS de encaixes <em>hotplug</em> PCI Express (p.ex.: <code>ens1</code>)</p>
</li>
<li>
<p>Nomes incorporando localização física/geográfica do conector do hardware (p.ex.: <code>enp2s0</code>)</p>
</li>
<li>
<p>Nomes incorporando o endereço MAC da interface (p.ex.: <code>enx78e7d1ea46da</code>)</p>
</li>
<li>
<p>Nomes clássicos, usando nomenclatura não-previsível nativa do kernel (p.ex.: <code>eth0</code>)</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Todas as VMs utilizadas neste curso serão derivadas da máquina <code>debian-template</code>, configurada com o Debian 9. A equivalência da nova nomenclatura de interfaces de rede, se comparada com a antiga, ficaria assim:</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<caption class="title">Table 3. Nomenclatura de interfaces de máquinas Debian 9</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-middle">Interface antiga</th>
<th class="tableblock halign-left valign-middle">Interface nova</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">eth0</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">enp0s3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">eth1</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">enp0s8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">eth2</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">enp0s9</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Observe, por exemplo, como é feita a detecção de interfaces durante o <em>boot</em> da máquina <code>ns1</code>, que criaremos a seguir:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dmesg | grep 'renamed from'
[    1.658908] e1000 0000:00:09.0 enp0s9: renamed from eth2
[    1.659807] e1000 0000:00:08.0 enp0s8: renamed from eth1
[    1.660711] e1000 0000:00:03.0 enp0s3: renamed from eth0</pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_2_criação_da_vm_de_firewall_e_dns_primário">2) Criação da VM de firewall e DNS primário</h3>
<div class="paragraph">
<p>Iremos agora criar a primeira máquina virtual efetiva de nosso <em>datacenter</em> simulado, a máquina <code>ns1</code>. Essa máquina atuará como um firewall de borda e DNS primário da rede, como configuraremos a seguir. Por se tratar de um firewall, é necessário que ela possua ao menos duas (ou, em nosso caso específico, três) interfaces de rede interconectando redes distintas.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Clone a máquina <code>debian-template</code> seguindo os mesmos passos da atividade (6) da sessão 1. Para o nome da máquina, escolha <code>ns1</code>.</p>
</li>
<li>
<p>Após a clonagem, na janela principal do Virtualbox, clique com o botão direito sobre a VM <code>ns1</code> e depois em <em>Settings</em>.</p>
<div class="paragraph">
<p>Em <em>Network</em> &gt; <em>Adapter 1</em> &gt; <em>Attached to</em>, mantenha escolhida a opção <em>Bridged Adapter</em>, já que esta será a interface de conexão externa da máquina.</p>
</div>
<div class="paragraph">
<p>Em <em>Adapter 2</em>, marque a caixa <em>Enable Network Adapter</em> e em <em>Attached to</em> selecione <em>Host-only Adapter</em>. O nome da rede <em>host-only</em> deve ser o mesmo alocado para a <strong>DMZ</strong>, como indicado na atividade (1) desta sessão. Seguindo o exemplo mostrado na figura da atividade, a rede escolhida seria portanto a <code>Virtualbox Host-Only Ethernet Adapter #2</code>.</p>
</div>
<div class="paragraph">
<p>Em <em>Adapter 3</em>, marque a caixa <em>Enable Network Adapter</em> e em <em>Attached to</em> selecione <em>Host-only Adapter</em>. O nome da rede <em>host-only</em> deve ser o mesmo alocado para a <strong>Intranet</strong>, como indicado na atividade (1) desta sessão. Seguindo o exemplo da figura, escolheríamos então <code>Virtualbox Host-Only Ethernet Adapter #3</code>.</p>
</div>
<div class="paragraph">
<p>Clique em <em>OK</em>, e ligue a máquina <code>ns1</code>.</p>
</div>
</li>
<li>
<p>Após o <em>boot</em>, faça login como o usuário <code>root</code>. Primeiro, vamos configurar a rede: edite o arquivo <code>/etc/network/interfaces</code> como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># nano /etc/network/interfaces
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/network/interfaces
source /etc/network/interfaces.d/*

auto lo enp0s3 enp0s8 enp0s9

iface lo inet loopback

iface enp0s3 inet dhcp

iface enp0s8 inet static
address 10.0.42.1/24

iface enp0s9 inet static
address 192.168.42.1/24</pre>
</div>
</div>
<div class="paragraph">
<p>Para garantir que nenhum endereço IP antigo, primário, se mantenha alocado às interfaces, execute o comando <code>flush</code> e em seguida reinicie a rede do sistema:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ip addr flush label 'enp0s*' ; systemctl restart networking</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que as interfaces estão com os endereços corretamente alocados:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ip addr show label 'enp0s*' | grep 'inet ' | awk '{print $2,$NF}'
192.168.29.104/24 enp0s3
10.0.42.1/24 enp0s8
192.168.42.1/24 enp0s9</pre>
</div>
</div>
</li>
<li>
<p>Usando o script <code>/root/scripts/changehost.sh</code> que criamos anteriormente, renomeie a máquina:</p>
<div class="literalblock">
<div class="content">
<pre># hostname
debian-template</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh ns1</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname
ns1</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_configuração_inicial_do_firewall">3) Configuração inicial do firewall</h3>
<div class="paragraph">
<p>Para garantir a segurança da rede iremos configurar o firewall de forma extremamente restritiva, como se segue:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Tráfego oriundo do firewall (<em>chain</em> OUTPUT) será permitido.</p>
</li>
<li>
<p>Todo o tráfego na interface <em>loopback</em> será permitido.</p>
</li>
<li>
<p>Serão permitidos pacotes destinados ao firewall (<em>chain</em> INPUT) ou passando pelo firewall (<em>chain</em> FORWARD) cujo estado seja relacionado ou estabelecido.</p>
</li>
<li>
<p>Serão permitidos pacotes ICMP oriundos das redes DMZ e Intranet com destino ao firewall <em>FWGW1-G</em>.</p>
</li>
<li>
<p>Será permitida gerência via <code>ssh</code> do firewall a partir de máquinas da Intranet.</p>
</li>
<li>
<p>Será autorizado o tráfego na Internet das máquinas da DMZ e Intranet <strong>exclusivamente</strong> nas portas TCP/80 e TCP/443.</p>
</li>
<li>
<p>Todos os demais acessos serão bloqueados.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>À medida que novas regras forem necessárias, nas sessões seguintes, iremos criar regras de exceção pontualmente durante a execução das atividades, explicando os motivos das liberações. Vamos, ponto a ponto, realizar as configurações explicitadas acima:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, como em qualquer firewall de rede, devemos habilitar o repasse de pacotes entre interfaces. Para isso, edite o arquivo <code>/etc/sysctl.conf</code> e descomente a linha com a diretiva <code>net.ipv4.ip_forward</code>, como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># sed -i '/net.ipv4.ip_forward/s/^#//' /etc/sysctl.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Processe as alterações no arquivo com:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sysctl -p
net.ipv4.ip_forward = 1</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que esse arquivo é lido durante o <em>boot</em> do sistema, o que garante que nossa configuração perdurará mesmo após reiniciarmos a máquina.</p>
</div>
</li>
<li>
<p>Agora, vamos retomar as diretivas informadas no início desta atividade: para a requisição (a) não precisamos fazer nada, já que a política da <em>chain</em> OUTPUT encontra-se em ACCEPT:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -L OUTPUT
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination</pre>
</div>
</div>
</li>
<li>
<p>A diretiva (b) pode ser atendida com a regra que se segue:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -i lo -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Já tratamos do caso da <em>chain</em> OUTPUT, e não faz sentido falarmos em tráfego na interface <em>loopback</em> na <em>chain</em> FORWARD.</p>
</div>
</li>
<li>
<p>Para a diretiva (c) devemos usar uma regra de estados nas <em>chains</em> INPUT e FORWARD, da seguinte forma:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT</pre>
</div>
</div>
</li>
<li>
<p>Como a diretiva (d) diz especificamente de pacotes "com destino ao firewall", fica claro que devemos adicionar uma regra à <em>chain</em> INPUT. Note ainda que a diretiva é precisa em especificar que <strong>apenas</strong> o tráfego ICMP das redes DMZ e Intranet deve ser autorizado, e nenhum outro. Finalmente, não é especificado qual tipo de pacote ICMP será aceito, o que nos permite deduzir que todos serão aceitos.</p>
<div class="paragraph">
<p>Para inserir uma regra que inclua ambas as redes de origem, basta separá-las com vírgula, como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -s 10.0.42.0/24,192.168.42.0/24 -p icmp -m icmp --icmp-type any -j ACCEPT</pre>
</div>
</div>
</li>
<li>
<p>A diretiva (e) é clara ao especificar que a gerência será via <code>ssh</code> (portanto, na porta 22 do protocolo TCP), a ser feita no firewall (ou seja, <em>chain</em> INPUT), e apenas a partir de máquinas da Intranet. Podemos atender a esse requisito com a seguinte regra:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -s 192.168.42.0/24 -p tcp -m tcp --dport 22 -j ACCEPT</pre>
</div>
</div>
</li>
<li>
<p>A diretiva (f) diz que o tráfego na Internet das máquinas da DMZ e Intranet deve ser autorizado apenas nas portas TCP/80 e TCP/443. O requisito de IP de origem é bastante claro, mas o de destino não&#8201;&#8212;&#8201;de fato, máquinas na Internet podem ter, a princípio, qualquer endereço IP. Faz sentido, então, indicarmos a interface de saída dos pacotes, <code>enp0s3</code>.</p>
<div class="paragraph">
<p>Outro aspecto a ser observado é que os pacotes desta vez não se destinam ao firewall, mas sim passam por ele para atingir máquinas na Internet, indicando que a regra deve ser inserida na <em>chain</em> FORWARD.</p>
</div>
<div class="paragraph">
<p>Podemos ainda usar o módulo <code>multiport</code> para evitar a digitação de duas regras similares. Então, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 10.0.42.0/24,192.168.42.0/24 -o enp0s3 -p tcp -m multiport --dports 80,443 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Há ainda que se considerar a necessidade de realizar a tradução dos endereços de saída, pois não é possível que as máquinas da DMZ/Intranet naveguem com seus IPs em faixas privadas. Temos que criar uma regra de SNAT para permitir a navegação&#8201;&#8212;&#8201;levando em conta que o endereço da interface <code>enp0s3</code> é dinâmico, faz sentido usar o alvo MASQUERADE, nesse caso.</p>
</div>
<div class="paragraph">
<p>Um adendo final: podemos fazer uma regra tão restritiva quanto a que fizemos na <em>chain</em> FORWARD acima, especificando também o protocolo e porta em que o SNAT será realizado. Tenha em mente apenas que, em caso de adição de exceções futuras, será necessário adicionar o protocolo/porta de exceção em <strong>ambas</strong> as <em>chains</em>, <code>filter/FORWARD</code> e <code>nat/POSTROUTING</code>.</p>
</div>
<div class="paragraph">
<p>A regra fica assim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A POSTROUTING -s 10.0.42.0/24,192.168.42.0/24 -o enp0s3 -p tcp -m multiport --dports 80,443 -j MASQUERADE</pre>
</div>
</div>
</li>
<li>
<p>Atender a diretiva (g) final é bastante fácil: basta alterar a política das <em>chains</em> INPUT e FORWARD para DROP:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -P INPUT DROP</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -P FORWARD DROP</pre>
</div>
</div>
</li>
<li>
<p>Verifique a configuração final do firewall, comparando com os requisitos iniciais. Consulte primeiro a tabela <em>filter</em>:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -L -vn
Chain INPUT (policy DROP 189 packets, 52988 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0
  982 67024 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
    0     0 ACCEPT     icmp --  *      *       10.0.42.0/24         0.0.0.0/0            icmptype 255
    0     0 ACCEPT     icmp --  *      *       192.168.42.0/24      0.0.0.0/0            icmptype 255
    0     0 ACCEPT     tcp  --  *      *       192.168.42.0/24      0.0.0.0/0            tcp dpt:22

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
    0     0 ACCEPT     tcp  --  *      enp0s3  10.0.42.0/24         0.0.0.0/0            multiport dports 80,443
    0     0 ACCEPT     tcp  --  *      enp0s3  192.168.42.0/24      0.0.0.0/0            multiport dports 80,443

Chain OUTPUT (policy ACCEPT 16 packets, 1264 bytes)
 pkts bytes target     prot opt in     out     source               destination</pre>
</div>
</div>
<div class="paragraph">
<p>E, depois, a tabela <em>nat</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -L -vn -t nat
Chain PREROUTING (policy ACCEPT 10 packets, 1485 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain INPUT (policy ACCEPT 6 packets, 1012 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 MASQUERADE  tcp  --  *      enp0s3  10.0.42.0/24         0.0.0.0/0            multiport dports 80,443
    0     0 MASQUERADE  tcp  --  *      enp0s3  192.168.42.0/24      0.0.0.0/0            multiport dports 80,443</pre>
</div>
</div>
</li>
<li>
<p>As configurações realizadas até aqui estão todas em memória&#8201;&#8212;&#8201;em caso de <em>reboot</em> da máquina <code>ns1</code>, elas serão perdidas. Para gravar as regras e integrá-las ao sistema de <em>init</em> do SO, o pacote <code>iptables-persistent</code> é uma excelente opção. Instale-o com:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install iptables-persistent</pre>
</div>
</div>
<div class="paragraph">
<p>Na instalação do pacote, quando perguntado, responda:</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 65%;">
<caption class="title">Table 4. Configurações do iptables-persistent</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pergunta</th>
<th class="tableblock halign-left valign-top">Resposta</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Salvar as regras IPv4 atuais?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sim</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Salvar as regras IPv6 atuais?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sim</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>As regras IPv4 e IPv6 serão gravadas nos arquivos <code>/etc/iptables/rules.v4</code> e <code>/etc/iptables/rules.v6</code>, respectivamente. Em caso de alterações futuras nas configurações do firewall, é possível gravá-las de forma fácil com o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent save
[....] Saving netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save
done.</pre>
</div>
</div>
<div class="paragraph">
<p>Se quiser limpar todas as regras de firewall e começar do zero, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent flush
[....] Flushing netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables flush
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables flush
done.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -L -vn
Chain INPUT (policy ACCEPT 13 packets, 1558 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 11 packets, 1068 bytes)
 pkts bytes target     prot opt in     out     source               destination</pre>
</div>
</div>
<div class="paragraph">
<p>Se cometer qualquer erro durante o processo de configuração ou simplesmente quiser recarregar o conjunto de regras gravado em <code>/etc/iptables/rules.v4</code>, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent reload
[....] Loading netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables start
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables start
done.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -L -vn
Chain INPUT (policy DROP 70 packets, 19740 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0
  111  5861 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
    0     0 ACCEPT     icmp --  *      *       10.0.42.0/24         0.0.0.0/0            icmptype 255
    0     0 ACCEPT     icmp --  *      *       192.168.42.0/24      0.0.0.0/0            icmptype 255
    0     0 ACCEPT     tcp  --  *      *       192.168.42.0/24      0.0.0.0/0            tcp dpt:22

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
    0     0 ACCEPT     tcp  --  *      enp0s3  10.0.42.0/24         0.0.0.0/0            multiport dports 80,443
    0     0 ACCEPT     tcp  --  *      enp0s3  192.168.42.0/24      0.0.0.0/0            multiport dports 80,443

Chain OUTPUT (policy ACCEPT 120 packets, 12617 bytes)
 pkts bytes target     prot opt in     out     source               destination</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_configuração_do_servidor_dns_primário">4) Configuração do servidor DNS primário</h3>
<div class="paragraph">
<p>Iremos agora configurar a máquina <code>ns1</code> como o servidor DNS primário da rede; para tanto, usaremos os programas NSD e Unbound.</p>
</div>
<div class="paragraph">
<p>O NSD (<em>Name Server Daemon</em>) é um servidor DNS <em>open-source</em> desenvolvido pela NLNet de Amsterdã em parceria com a RIPE NCC, o registro regional de Internet da Europa, oeste da Ásia e ex-países da União Soviética. Ele foi projetado para atuar exclusivamente como um servidor DNS autoritativo, não implementando portanto funções de <em>cache</em> recursiva como sua contraparte mais famosa, o BIND. A ideia por trás disso é aumentar a variabilidade de implementações DNS disponíveis, aumentando a resiliência do sistema DNS contra falhas de software e <em>exploits</em>.</p>
</div>
<div class="paragraph">
<p>O Unbound, por outro lado, é um <em>resolver</em> DNS com funções de validação, <em>cache</em> e recursividade também implementado pela NLNet Labs. Como se pode observar, então, ele faz as funções complementares às do NSD. Por sua percepção como sendo um software mais moderno, enxuto e seguro que seus concorrentes, o Unbound foi adotado como o <em>resolver</em> padrão do sistema-base dos sistemas FreeBSD e OpenBSD em 2014.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O primeiro passo, naturalmente, é instalar os pacotes dos programas mencionados:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install nsd unbound dnsutils</pre>
</div>
</div>
</li>
<li>
<p>Vamos começar configurando o <strong>NSD</strong>. Primeiro, pare o <em>daemon</em>:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl stop nsd</pre>
</div>
</div>
<div class="paragraph">
<p>O programa pode ser controlado no terminal usando o comando <code>nsd-control</code>&#8201;&#8212;&#8201;para tanto, é necessário gerar as chaves TLS de controle com o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nsd-control-setup
setup in directory /etc/nsd
nsd_server.key exists
nsd_control.key exists
create nsd_server.pem (self signed certificate)
create nsd_control.pem (signed client certificate)
Signature ok
subject=CN = nsd-control
Getting CA Private Key
Setup success. Certificates created.</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a criação das chaves com o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -1 /etc/nsd | grep '.key\|.pem'
nsd_control.key
nsd_control.pem
nsd_server.key
nsd_server.pem</pre>
</div>
</div>
</li>
<li>
<p>Faça um backup do arquivo de configuração original <code>/etc/nsd/nsd.conf</code>:</p>
<div class="literalblock">
<div class="content">
<pre># mv /etc/nsd/nsd.conf /etc/nsd/nsd.conf.orig</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, crie o arquivo novo <code>/etc/nsd/nsd.conf</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">server:
  ip-address: 127.0.0.1
  ip-address: 10.0.42.1
  do-ip4: yes
  port: 8053
  username: nsd
  zonesdir: "/etc/nsd/zones"

  logfile: "/var/log/nsd.log"
  pidfile: "/run/nsd/nsd.pid"
  hide-version: yes
  version: "intnet DNS"
  identity: "unidentified server"

remote-control:
  control-enable: yes
  control-interface: 127.0.0.1
  control-port: 8952
  server-key-file: "/etc/nsd/nsd_server.key"
  server-cert-file: "/etc/nsd/nsd_server.pem"
  control-key-file: "/etc/nsd/nsd_control.key"
  control-cert-file: "/etc/nsd/nsd_control.pem"

key:
  name: "inkey"
  algorithm: sha512
  secret: "TSIGKEY"

pattern:
  name: "inslave"
  notify: 10.0.42.2@8053 inkey
  provide-xfr: 10.0.42.2 inkey

zone:
  name: "intnet"
  include-pattern: "inslave"
  zonefile: "intnet.zone"

zone:
  name: "42.0.10.in-addr.arpa"
  include-pattern: "inslave"
  zonefile: "10.0.42.zone"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Abaixo, destacamos e explicamos algumas das diretivas mais relevantes do arquivo acima:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>server/ip-address</code>: define os endereços de rede nos quais o NSD irá escutar&#8201;&#8212;&#8201;atenderemos requisições de <em>localhost</em> e do servidor DNS secundário, que será instalado na DMZ a seguir. O controle de quais <em>hosts</em> estarão autorizados a consultar o NSD será feito via diretivas <code>notify</code> e <code>provide-xfr</code>, bem como restrição via regra de firewall.</p>
</li>
<li>
<p><code>server/port</code>: define a porta em que o NSD irá escutar; como iremos instalar o Unbound na mesma máquina (escutando na porta 53/UDP), escolhemos a porta alternativa 8053 para evitar conflitos de <em>bind</em>.</p>
</li>
<li>
<p><code>server/username</code>: usuário com o qual o NSD irá operar. É possível aplicar um controle adicional além da redução de privilégios para um usuário comum, o uso de <em>chroot</em>, que não faremos nesta atividade.</p>
</li>
<li>
<p><code>server/zonesdir</code>: diretório em que serão armazenados os arquivos de zonas do NSD.</p>
</li>
<li>
<p><code>server/hide-version</code>, <code>server/version</code> e <code>server/identity</code>: os três controles objetivam mascarar o software rodando na máquina local, dificultando a tarefa de <em>banner grabbing</em> e identificação de <em>exploits</em> por parte de eventuais atacantes.</p>
</li>
<li>
<p><code>remote-control/control-enable</code> e <code>remote-control/interface</code>: define que o NSD poderá ser controlado "remotamente", mas logo depois restringe o IP de escuta para 127.0.0.1, efetivamente autorizando conexão de controle exclusivamente a partir de <em>localhost</em>.</p>
</li>
<li>
<p><code>key/secret</code>: define uma chave secreta que servidores primário e secundário deverão possuir em comum para que a transferência de zona seja feita com sucesso. Faremos a geração dessa chave e sua substituição de forma automática no arquivo a seguir.</p>
</li>
<li>
<p><code>pattern</code>: define um conjunto de diretivas que serão inseridas em diversas zonas a seguir (efetivamente, como uma <em>macro</em>). No caso, estamos indicando que o servidor 10.0.42.2 será notificado de alterações de zona (<code>notify</code>), e transferências de zona partir desse endereço serão autorizadas (<code>provide-xfr</code>).</p>
</li>
<li>
<p><code>zone/intnet</code>: define um arquivo de zona direta para o qual o servidor NSD será autoritativo, o nome de domínio <code>intnet</code>. A sintaxe do arquivo é idêntica à usada no software BIND.</p>
</li>
<li>
<p><code>zone/42.0.10-in-addr.arpa</code>: define um arquivo de zona reversa para o qual o servidor NSD será autoritativo, a faixa de endereços <code>10.0.42.0/24</code>. A sintaxe do arquivo é idêntica à usada no software BIND.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>A transferência de zonas entre servidor primário e secundário é assegurada, além dos controles de interface de escuta e regras de firewall, por uma chave secreta TSIG (<em>Transaction SIGnature</em>) em formato Base64. Para inseri-la no arquivo use o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># tsigkey_t=$( dd if=/dev/urandom of=/dev/stdout count=1 bs=32 2&gt; /dev/null| base64 ); sed -i "s|TSIGKEY|$tsigkey_t|" /etc/nsd/nsd.conf ; unset tsigkey_t</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a inserção da chave com:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># grep 'secret:' /etc/nsd/nsd.conf
  secret: "i7IoB5VDHVOCW9wvuOGQuFLNu8hzfAblVAbCD1SbPL4="</pre>
</div>
</div>
<div class="paragraph">
<p>Lembre-se que precisaremos dessa mesma chave quando estivermos configurando o servidor secundário.</p>
</div>
</li>
<li>
<p>Crie o diretório de zonas <code>/etc/nsd/zones</code>:</p>
<div class="literalblock">
<div class="content">
<pre># mkdir /etc/nsd/zones</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, crie o arquivo novo <code>/etc/nsd/zones/intnet.zone</code>, com as configuração de zona direta para o domínio <code>intnet.</code>, com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$TTL 86400 ; (1 day)
$ORIGIN intnet.

@       IN   SOA   ns1.intnet.  admin.intnet. (
                   2018111000   ;serial (YYYYMMDDnn)
                   14400        ;refresh (4 hours)
                   1800         ;retry (30 minutes)
                   1209600      ;expire (2 weeks)
                   3600         ;negative cache TTL (1 hour)
                   )

@       IN   NS                 ns1.intnet.
@       IN   NS                 ns2.intnet.

@       IN   MX    10           mx1.intnet.
@       IN   MX    20           mx2.intnet.

ns1     IN    A                 10.0.42.1
ns2     IN    A                 10.0.42.2

mx1     IN    A                 10.0.42.91
mx2     IN    A                 10.0.42.92

fw      IN    CNAME             ns1</code></pre>
</div>
</div>
<div class="paragraph">
<p>A sintaxe é exatamente a mesma utilizada para um arquivo de zonas do BIND. Note que:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Definimos a máquina <code>ns1.intnet.</code> como o servidor autoritativo para o domínio <code>intnet.</code>, com email de contato <code>admin@intnet</code>.</p>
</li>
<li>
<p>O serial é <code>2018111000</code>&#8201;&#8212;&#8201;este é um número que deve identificar a versão do arquivo de zonas, e incrementado a cada atualização. O formato escolhido para esse <em>serial</em> foi <code>ANO-MES-DIA-VERSAO</code>, de forma que versões do arquivo em datas futuras terão sempre um valor superior ao de versões antigas.</p>
</li>
<li>
<p>Os servidores DNS responsáveis pelo domínio são <code>ns1.intnet</code> e <code>ns2.intnet.</code>.</p>
</li>
<li>
<p>Os servidores de e-mail (MX&#8201;&#8212;&#8201;<em>mail exchange</em>) do domínio são <code>mx1.intnet.</code> e <code>mx2.intnet.</code>. Ambos são servidores fictícios, que não implantaremos neste curso, e mostrados aqui apenas para demonstrar a sintaxe desse tipo de entrada no arquivo de zonas.</p>
</li>
<li>
<p>Configuram-se registros A (<em>address</em>) para as máquinas mencionadas.</p>
</li>
<li>
<p>Configura-se um registro CNAME (<em>canonical name</em>) para a máquina <code>ns1.intnet.</code>, <code>fw.intnet.</code>. Com isso, os usuário poderão referir-se a essa máquina também pelo seu "apelido".</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Vamos para o arquivo de zona reversa. Crie o arquivo novo <code>/etc/nsd/zones/10.0.42.zone</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$TTL 86400 ; (1 day)
$ORIGIN 42.0.10.in-addr.arpa.

@       IN   SOA   ns1.intnet.  admin.intnet. (
                   2018111000   ;serial (YYYYMMDDnn)
                   14400        ;refresh (4 hours)
                   1800         ;retry (30 minutes)
                   1209600      ;expire (2 weeks)
                   3600         ;negative cache TTL (1 hour)
                   )

@       IN   NS                 ns1.intnet.
@       IN   NS                 ns2.intnet.

@       IN   MX    10           mx1.intnet.
@       IN   MX    20           mx2.intnet.

1       IN   PTR                ns1.intnet.
2       IN   PTR                ns2.intnet.

91      IN   PTR                mx1.intnet.
92      IN   PTR                mx2.intnet.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nada muito diferente neste arquivo em relação ao anterior&#8201;&#8212;&#8201;note apenas que os registros inseridos aqui são do tipo PTR (<em>pointer</em>), fazendo o mapeamento reverso entre endereços IP e nomes de domínio. Note, ainda, que o <em>ORIGIN</em> do arquivo é definido como <code>42.0.10.in-addr.arpa.</code>, já que somos o servidor autoritativo para a faixa 10.0.42.0/24.</p>
</div>
</li>
<li>
<p>Vamos verificar se a sintaxe dos arquivos de configuração não possui erros:</p>
<div class="literalblock">
<div class="content">
<pre># nsd-checkconf /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, basta reiniciar o serviço e verificar sua correta operação:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nsd-control start</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># tail /var/log/nsd.log
[2018-11-13 17:17:26.763] nsd[2012]: notice: nsd starting (NSD 4.1.14)
[2018-11-13 17:17:26.780] nsd[2014]: notice: nsd started (NSD 4.1.14), pid 2013</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ss -tunlp | grep 8053
udp    UNCONN     0      0      10.0.42.1:8053                  *:*                   users:(("nsd",pid=648,fd=5),("nsd",pid=647,fd=5),("nsd",pid=646,fd=5))
udp    UNCONN     0      0      127.0.0.1:8053                  *:*                   users:(("nsd",pid=648,fd=4),("nsd",pid=647,fd=4),("nsd",pid=646,fd=4))
tcp    LISTEN     0      128    10.0.42.1:8053                  *:*                   users:(("nsd",pid=648,fd=7),("nsd",pid=647,fd=7),("nsd",pid=646,fd=7))
tcp    LISTEN     0      128    127.0.0.1:8053                  *:*                   users:(("nsd",pid=648,fd=6),("nsd",pid=647,fd=6),("nsd",pid=646,fd=6))</pre>
</div>
</div>
</li>
<li>
<p>Vamos colocar o servidor à prova: teste a resolução direta de nomes usando a ferramenta <code>dig</code>. Lembre-se que o NSD está operando na porta 8053/UDP, e não na porta padrão:</p>
<div class="literalblock">
<div class="content">
<pre># dig @127.0.0.1 -p 8053 fw.intnet +noadditional +noquestion

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; @127.0.0.1 -p 8053 fw.intnet +noadditional +noquestion
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64874
;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 2
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; ANSWER SECTION:
fw.intnet.              86400   IN      CNAME   ns1.intnet.
ns1.intnet.             86400   IN      A       10.0.42.1

;; AUTHORITY SECTION:
intnet.                 86400   IN      NS      ns1.intnet.
intnet.                 86400   IN      NS      ns2.intnet.

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8053(127.0.0.1)
;; WHEN: Mon Nov 12 09:19:30 -02 2018
;; MSG SIZE  rcvd: 120</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente! Todas as seções de resposta parecem corretas, tanto ANSWER quando AUTHORITY. Vamos verificar a resolução reversa:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig @127.0.0.1 -p 8053 -x 10.0.42.2 +noadditional +noquestion

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; @127.0.0.1 -p 8053 -x 10.0.42.2 +noadditional +noquestion
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 4272
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; ANSWER SECTION:
2.42.0.10.in-addr.arpa. 86400   IN      PTR     ns2.intnet.

;; AUTHORITY SECTION:
42.0.10.in-addr.arpa.   86400   IN      NS      ns1.intnet.
42.0.10.in-addr.arpa.   86400   IN      NS      ns2.intnet.

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8053(127.0.0.1)
;; WHEN: Mon Nov 12 09:19:47 -02 2018
;; MSG SIZE  rcvd: 107</pre>
</div>
</div>
</li>
<li>
<p>Agora que o NSD está configurado, vamos implementar o <strong>Unbound</strong>. Primeiro, pare o <em>daemon</em> se estiver rodando:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl stop unbound</pre>
</div>
</div>
<div class="paragraph">
<p>Assim como no caso do NSD, o Unbound pode ser controlado via <code>unbound-control</code>&#8201;&#8212;&#8201;gere as chaves de controle:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># unbound-control-setup
setup in directory /etc/unbound
unbound_server.key exists
unbound_control.key exists
create unbound_server.pem (self signed certificate)
create unbound_control.pem (signed client certificate)
Signature ok
subject=CN = unbound-control
Getting CA Private Key
Setup success. Certificates created.</pre>
</div>
</div>
<div class="paragraph">
<p>Faça um backup do arquivo de configuração original <code>/etc/unbound/unbound.conf</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mv /etc/unbound/unbound.conf /etc/unbound/unbound.conf.orig</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, crie o arquivo novo <code>/etc/unbound/unbound.conf</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">server:
  interface: 127.0.0.1
  interface: 10.0.42.1
  interface: 192.168.42.1
  port: 53

  access-control: 127.0.0.0/8 allow
  access-control: 10.0.42.0/24 allow
  access-control: 192.168.42.0/24 allow

  cache-min-ttl: 300
  cache-max-ttl: 14400

  local-zone: "intnet" nodefault
  domain-insecure: "intnet"

  local-zone: "10.in-addr.arpa." nodefault
  domain-insecure: "10.in-addr.arpa."

  verbosity: 1
  prefetch: yes
  hide-version: yes
  hide-identity: yes
  use-caps-for-id: yes
  rrset-roundrobin: yes
  minimal-responses: yes
  do-not-query-localhost: no

stub-zone:
  name: "intnet"
  stub-addr: 127.0.0.1@8053

stub-zone:
  name: "42.0.10.in-addr.arpa."
  stub-addr: 127.0.0.1@8053

forward-zone:
  name: "."
  forward-addr: 8.8.8.8
  forward-addr: 8.8.4.4

include: "/etc/unbound/unbound.conf.d/*.conf"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Abaixo, destacamos e explicamos algumas das diretivas mais relevantes do arquivo acima:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>server/interface</code>: define os endereços de rede nos quais o Unbound irá escutar&#8201;&#8212;&#8201;atenderemos requisições de <em>localhost</em> e das sub-redes DMZ e Intranet.</p>
</li>
<li>
<p><code>server/port</code>: o Unbound irá escutar na porta padrão, 53/UDP.</p>
</li>
<li>
<p><code>server/access-control</code>: define que as sub-redes declaradas (<em>localhost</em>, DMZ e Intranet, novamente) terão permissão para utilizar os serviços de resolução de nomes.</p>
</li>
<li>
<p><code>server/local-zone</code> e <code>server/domain-insecure</code>: define opções para as zonais locais <code>intnet.</code> e <code>42.0.10.in-addr.arpa.</code>, e que a cadeia de confiança DNSSEC não será verificada para esses domínios.</p>
</li>
<li>
<p><code>server/hide-version</code> e <code>server/hide-identity</code>: controles que objetivam mascarar o software rodando na máquina local, dificultando a tarefa de <em>banner grabbing</em> e identificação de <em>exploits</em> por parte de eventuais atacantes.</p>
</li>
<li>
<p><code>stub-zone</code> e <code>stub-zone/stub-addr</code>: declara zonas autoritativas locais que devem ser consultadas para os domínios especificados, para as quais o registro público DNS não será usado. Usaremos o servidor NSD rodando em <em>localhost</em>, consultando a porta 8053/UDP.</p>
</li>
<li>
<p><code>forward-zone</code> e <code>forward-zone/forward-addr</code>: define servidores nos quais o Unbound irá buscar recursão caso não consiga resolver um nome. Como está sendo declarado o nome de zona <code>"."</code>,  todas as pesquisas serão redirecionadas para os servidores indicados em <code>forward-addr</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Vamos verificar o funcionamento do <em>daemon</em>. Inicie o Unbound usando o <code>unbound-control</code>:</p>
<div class="literalblock">
<div class="content">
<pre># unbound-control start</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique seu funcionamento usando o <code>ss</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ss -unlp | grep :53
UNCONN     0      0      192.168.42.1:53                    *:*                   users:(("unbound",pid=2084,fd=7))
UNCONN     0      0      10.0.42.1:53                       *:*                   users:(("unbound",pid=2084,fd=5))
UNCONN     0      0      127.0.0.1:53                       *:*                   users:(("unbound",pid=2084,fd=3))</pre>
</div>
</div>
<div class="paragraph">
<p>Reconfigure o DNS <em>system-wide</em>, no arquivo <code>/etc/resolv.conf</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/resolv.conf
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/resolv.conf
domain intnet.
search intnet.
nameserver 10.0.42.1
nameserver 10.0.42.2</pre>
</div>
</div>
<div class="paragraph">
<p>Devido ao fato de estarmos usando DHCP na interface de saída (<code>enp0s3</code>), o arquivo <code>/etc/resolv.conf</code> poderá ser sobrescrito sempre que as interfaces de rede forem reiniciadas, ou após o <em>reboot</em> da máquina. Para evitar isso, marque o arquivo como imutável:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># chattr +i /etc/resolv.conf</pre>
</div>
</div>
</li>
<li>
<p>Feito! Vamos testar a resolução de domínios internos <code>unbound</code> com a ferramenta <code>dig</code>.</p>
<div class="literalblock">
<div class="content">
<pre># dig fw.intnet +noquestion +noadditional

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; fw.intnet +noquestion +noadditional
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 63613
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; ANSWER SECTION:
fw.intnet.              86400   IN      CNAME   ns1.intnet.
ns1.intnet.             86400   IN      A       10.0.42.1

;; Query time: 0 msec
;; SERVER: 10.0.42.1#53(10.0.42.1)
;; WHEN: Mon Nov 12 09:39:55 -02 2018
;; MSG SIZE  rcvd: 72</pre>
</div>
</div>
<div class="paragraph">
<p>E quanto a nomes de domínio externos, usando recursão? Vejamos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig openbsd.org +noquestion +noadditional

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; openbsd.org +noquestion +noadditional
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 5694
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; ANSWER SECTION:
openbsd.org.            21599   IN      A       129.128.5.194

;; Query time: 420 msec
;; SERVER: 10.0.42.1#53(10.0.42.1)
;; WHEN: Mon Nov 12 09:40:33 -02 2018
;; MSG SIZE  rcvd: 56</pre>
</div>
</div>
</li>
<li>
<p>Ainda não acabou! Lembre-se que nossas regras de firewall configuradas no começo desta sessão estão extremamente restritivas, então temos que criar exceções para que a consulta de nomes funcione. Vamos ver os tipos de acesso que precisamos liberar:</p>
<div class="openblock">
<div class="content">
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>O NSD será consultado apenas pelo Unbound em <em>localhost</em> (não é necessário criar regras neste caso), e pelo servidor DNS secundário em 10.0.42.2. Como nesse caso será feita transferência de zonas entre os servidores, é necessário liberar tráfego nos protocolos TCP e UDP na porta 8053.</p>
</li>
<li>
<p>O Unbound local será consultado por todas as máquinas da DMZ e Intranet, na porta 53/UDP.</p>
</li>
<li>
<p>Os clientes da Intranet devem conseguir consultar o Unbound rodando no servidor DNS secundário, porta 53/UDP. Não é necessário criar uma regra para a DMZ, neste caso, pois as máquinas estão na mesma sub-rede e portanto seu tráfego não passa pelo firewall (na <em>chain</em> FORWARD).</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Vamos ao requisito (a):</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -s 10.0.42.2/32 -p tcp -m tcp --dport 8053 -j ACCEPT</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -s 10.0.42.2/32 -p udp -m udp --dport 8053 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, o requisito (b):</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -s 10.0.42.0/24,192.168.42.0/24 -p udp -m udp --dport 53 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>E, finalmente, o critério (c) estabelecido inicialmente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 192.168.42.0/24 -d 10.0.42.2/32 -p udp -m udp --dport 53 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Salve as regras na configuração do firewall local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent save
[....] Saving netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save
done.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_configuração_do_dnssec">5) Configuração do DNSSEC</h3>
<div class="paragraph">
<p>Vamos agora configurar o DNSSEC em nosso servidor autoritativo, de forma a produzir consultas assinadas digitalmente. Evidentemente, como estamos configurando um domínio fictício não iremos conseguir propagar a assinatura pela cadeia de confiança raiz, mas esta atividade servirá como um exemplo caso você queira fazê-lo em sua organização posteriormente.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, vamos instalar as ferramentas de suporte para gestão/geração de chaves DNSSEC:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install ldnsutils haveged</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar as chaves de assinatura de zona (ZSK, ou <em>Zone Signing Key</em>) e chave (KSK, ou <em>Key Signing Key</em>). O KSK é um par de chaves público/privada usado para gerar uma assinatura digital para o ZSK. O ZSK, por sua vez, é um par de chaves público/privada para gerar uma assinatura digital conhecida como RRSIG (<em>Resource Record Signature</em>) para cada um dos RRSETs (<em>Resource Record Sets</em>) da zona. O website da Cloudflare (<a href="https://www.cloudflare.com/dns/dnssec/how-dnssec-works/" class="bare">https://www.cloudflare.com/dns/dnssec/how-dnssec-works/</a>) possui uma excelente explicação sobre o sistema DNSSEC que pode ser usada para consulta.</p>
<div class="paragraph">
<p>Primeiro, entre no diretório <code>/etc/nsd</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cd /etc/nsd/</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, vamos gerar o ZSK/KSK e armazenar seus nomes em uma variável temporária. Os algoritmos escolhidos estão de acordo com as melhores práticas recomendadas na RFC 6944 (<a href="https://tools.ietf.org/html/rfc6944" class="bare">https://tools.ietf.org/html/rfc6944</a>).</p>
</div>
<div class="literalblock">
<div class="content">
<pre># export ZSK=$( ldns-keygen -a RSASHA512 -b 2048 intnet )</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># export KSK=$( ldns-keygen -k -a RSASHA512 -b 2048 intnet )</pre>
</div>
</div>
<div class="paragraph">
<p>Podemos remover o registro DS (<em>Delegation of Signing</em>) auto-gerado, já que iremos regerá-lo futuramente sob demanda.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># rm Kintnet.*.ds</pre>
</div>
</div>
<div class="paragraph">
<p>Vejamos como ficaram as chaves ZSK/KSK para o domínio:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -1 Kintnet.*
Kintnet.+010+14936.key
Kintnet.+010+14936.private
Kintnet.+010+42867.key
Kintnet.+010+42867.private</pre>
</div>
</div>
<div class="paragraph">
<p>Para identificar qual dessas chaves é a ZSK e qual é a KSK, consulte as variáveis do <em>shell</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># echo $ZSK
Kintnet.+010+14936</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># echo $KSK
Kintnet.+010+42867</pre>
</div>
</div>
</li>
<li>
<p>Agora, vamos assinar a zona <code>intnet.zone</code> com o comando <code>ldns-signzone</code>:</p>
<div class="literalblock">
<div class="content">
<pre># ldns-signzone -n -p -s $(head -n 1000 /dev/urandom | sha1sum | cut -b 1-16) /etc/nsd/zones/intnet.zone $ZSK $KSK</pre>
</div>
</div>
<div class="paragraph">
<p>O que ocorreu? Verifique o conteúdo do diretório <code>/etc/nsd/zones</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -1 /etc/nsd/zones
10.0.42.zone
intnet.zone
intnet.zone.signed</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos configurar o NSD para usar a zona assinada. Para isso, basta substituir o caminho de busca do arquivo de zona direta <code>/etc/nsd/zones/intnet.zone</code> por sua contraparte assinada:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/intnet\.zone/intnet\.zone\.signed/' /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep -B3 intnet.zone.signed /etc/nsd/nsd.conf
zone:
  name: "intnet"
  include-pattern: "inslave"
  zonefile: "intnet.zone.signed"</pre>
</div>
</div>
<div class="paragraph">
<p>Para informar ao NSD que o arquivo de zonas mudou, basta usar o programa <code>nsd-control</code> como mostrado a seguir:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nsd-control reconfig
reconfig start, read /etc/nsd/nsd.conf
ok</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># nsd-control reload intnet
ok</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar se nossa configuração surtiu efeito. Primeiro, pesquise pelos registros DNSKEY do domínio no NSD em <em>localhost</em>, verificando as chaves ZSK e KSK:</p>
<div class="literalblock">
<div class="content">
<pre># dig -p 8053 @localhost DNSKEY intnet. +multiline +norec +noquestion

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; -p 8053 @localhost DNSKEY intnet. +multiline +norec +noquestion
; (2 servers found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 18768
;; flags: qr aa; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; ANSWER SECTION:
intnet.                 86400 IN DNSKEY 256 3 10 (
                                AwEAAerseiw1VUd7L90iBA4IgztUXpkw/k/6kKIHx5Qm
                                Cm1HvtLTT/dSFk9JOHVBoQ2Rpk0LQBc+WZsnqz6dQZJn
                                b9FkGzsAh39BnP8gOA1d+SfaGGkceEteQfgi3rKz5dnk
                                EWgOonWk2vGOJ5oPDvcy4aUQqfTACY9Tk0qeWZT7enfy
                                gdrg4AjaTKBdJ4kruBj2z3FKXBolDYO3HTPmosKe94Xr
                                muiLQa3uHFvFvu6k/X0mH1kCS+lb91R/OF60mG40iW4/
                                z8aLNSKPUuwJNddvZ0I14F7SwN7YGaVpoY11DAsxmbS5
                                1lGxp6Fc0fWQpAfT4WG9/mbyHj29kZnP/Oxktsk=
                                ) ; ZSK; alg = RSASHA512; key id = 14936
intnet.                 86400 IN DNSKEY 257 3 10 (
                                AwEAAdIo8BoUEY6ab3YBbs24FEj8Vt9aRByAFyKJk0sH
                                BiNIy9I1vXZIGB+5wlIKPzT4ZVd3oYO3MDExxDYZ1HVS
                                D1magCRBzLF2oeTCWY3kLz/9ls23RV9r5IMY68aPHMg0
                                tDBJ8IZTC9SbO+os3L9jazwpoL22Akl34YN6iIC6kXpQ
                                gN3TtNorzD8DIHkBvJ9NrpKYJjzt0g8oTyg0La3xTNcO
                                6q51Q4eVBnlcXbbJ6gquSFzAnoJ9qzq5JUnbvAB9I4yv
                                Spo3RGCX3lZFmsDvsDfnwkXShyeEPdGTr6m/mbqPrceW
                                R53QLOWnZq1KrczPwTlKjgtzwg+F7ol8YDdQOwU=
                                ) ; KSK; alg = RSASHA512; key id = 42867

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8053(127.0.0.1)
;; WHEN: Mon Nov 12 11:13:56 -02 2018
;; MSG SIZE  rcvd: 587</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito! Aparentemente, nossas chaves foram registradas e estão sendo utilizadas com sucesso. O Unbound, no entanto, ainda possui algumas entradas na <em>cache</em> desatualizadas, prévias à configuração do DNSSEC, que foram mantidas pelas consultas anteriores. Para limpá-las, basta usar o comando <code>unbound-control flush_zone</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># unbound-control flush_zone intnet.
ok removed 4 rrsets, 2 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Agora sim, faça uma consulta via Unbound usando DNSSEC:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig fw.intnet +dnssec +multiline +noquestion

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; fw.intnet +dnssec +multiline +noquestion
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 47390
;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags: do; udp: 4096
;; ANSWER SECTION:
fw.intnet.              86355 IN CNAME ns1.intnet.
fw.intnet.              86355 IN RRSIG CNAME 10 2 86400 (
                                20181210130559 20181112130559 14936 intnet.
                                u2DBcjAp91qYSYvspczvWiW8QuIX24aAoFTzfM8hJdUQ
                                3VcjekyJeQQfNPIM4+rE9ZdTywADS4nKCFl/XqkHwFST
                                kitVm9So17I4GBJ+sgpKkpoKEwh6IfbUB563Mmfj9jIQ
                                SvuR0dP0ot9QV+DXWCFLD02tvXTOBSltBT9Nogx1h926
                                5lkSZ0F+5x0Ss1Law5Rpn8ZKyAAwCYS0UNJIqB8XzIqb
                                eSblG5Q4Si7Qwrccv7Ll6DscBbh1gjmnCAYCE63XF3SN
                                s0N9SgTgfzibgVaVGw+S1SoVYjvxDVd5ZW/tpQxhx4kY
                                Wt/c+541nj7xmFT58/dnoo8t6Meo/JCKgw== )
ns1.intnet.             86297 IN A 10.0.42.1
ns1.intnet.             86297 IN RRSIG A 10 2 86400 (
                                20181210130559 20181112130559 14936 intnet.
                                bmwQPD9b/GwUX2ZvpP6baOzyEXNW/ghcc9rqzZSWwUYn
                                VfX+UqRwzon/2lxJfYO1uJh0v8noO2S5+zb7saroDsCi
                                9/Oaukw+iAvwrZh6VO1dHDr6WjAlS4hi9MxmfJ94NwD7
                                txB5WLG39KM0V/EpH+v4L6ser4v+oYFSer7a6EsZxCcD
                                nfciKtN5L/QUWVMacduxpRM16+MI83bEf/ulC82xIThf
                                2cVVdsDA4xfZvAOcYS/IXUauYXaj9fkE2TlVoyIC1UIM
                                XE6CSbulo2iWc+V+lj5tkP9kctmqit3rfegWXJlQ4es3
                                4fsxR64+Weqre/iTMpVxVss/TLus7g7OiA== )

;; Query time: 0 msec
;; SERVER: 10.0.42.1#53(10.0.42.1)
;; WHEN: Mon Nov 12 11:17:12 -02 2018
;; MSG SIZE  rcvd: 660</pre>
</div>
</div>
<div class="paragraph">
<p>Caso fosse desejável exportar a configuração DNS para um <em>registrar</em> hierarquicamente superior (fechando a cadeia de verificação DNS), pode-se gerar os registros DS das chaves com o comando abaixo.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldns-key2ds -n -1 /etc/nsd/zones/intnet.zone.signed &amp;&amp; ldns-key2ds -n -2 /etc/nsd/zones/intnet.zone.signed
intnet. 86400   IN      DS      42867 10 1 5b8c2c011bd011618f7e339667c075587e65ab05
intnet. 86400   IN      DS      42867 10 2 424bcf7d7c09df8be1520c4230680b5c33a63598b4c6185c7884592ad3bce63b</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_automatizando_assinatura_dnssec_após_alterações">6) Automatizando assinatura DNSSEC após alterações</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>É claro, seria muito inconveniente ter que realizar todos os passos que fizemos na atividade (5) a cada alteração no servidor DNS. Vamos automatizar a assinatura de zonas e reinício dos <em>daemons</em> relevantes com um <em>script shell</em>. Crie o arquivo novo <code>/root/scripts/signzone-intnet.sh</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

ZSK="ZSKSTUB"
KSK="KSKSTUB"
ZONE_FILE="/etc/nsd/zones/intnet.zone"

cd /etc/nsd

ldns-signzone -n \
  -p \
  -s $(head -n 1000 /dev/random | sha1sum | cut -b 1-16) \
  $ZONE_FILE \
  $ZSK \
  $KSK

nsd-control reconfig
nsd-control reload intnet
nsd-control reload 42.0.10.in-addr.arpa
unbound-control flush_zone intnet.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note que é necessário substituir as variáveis <code>ZSKSTUB</code> e <code>KSKSTUB</code> com os valores da variáveis <code>$ZSK</code> e <code>$KSK</code> no seu <em>shell</em> corrente, como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i "s/ZSKSTUB/${ZSK}/" /root/scripts/signzone-intnet.sh</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i "s/KSKSTUB/${KSK}/" /root/scripts/signzone-intnet.sh</pre>
</div>
</div>
</li>
<li>
<p>Teste a assinatura de zonas usando o <em>script</em>:</p>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 4 rrsets, 2 messages and 0 key entries</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ao atualizar arquivos de zona, não se esqueça que além de adicionar registros A, CNAME ou PTR conforme necessário, é também <strong>imprescindível</strong> incrementar o valor do <em>serial</em> do arquivo, próximo do topo no registro SOA. Se isso não for feito, o NSD não irá detectar que o arquivo de zona foi atualizado e suas modificações não serão propagadas.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_7_reconfiguração_da_vm_debian_template">7) Reconfiguração da VM <strong><em>debian-template</em></strong></h3>
<div class="paragraph">
<p>Agora que temos um firewall e servidores DNS na rede é interessante que alteremos a configuração padrão da VM <code>debian-template</code> para que as novas máquinas, clonadas a partir dela, já estejam corretamente ajustadas para operar em nosso <em>datacenter</em> simulado.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ligue a máquina <code>debian-template</code> e acesse o terminal como o usuário <code>root</code>.</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
</li>
<li>
<p>Com a máquina <code>debian-template</code> ligada, acesse na janela principal do Virtualbox o menu <em>Settings</em> &gt; <em>Network</em> &gt; <em>Adapter 1</em> &gt; <em>Attached to</em> e altere a opção para <em>Host-only Adapter</em>. O nome da rede <em>host-only</em> escolhido deve ser o mesmo alocado para a interface de rede da máquina virtual <code>ns1</code> que está conectada à DMZ. Seguindo o exemplo mostrado no início desta sessão, portanto, a rede escolhida seria a <code>Virtualbox Host-Only Ethernet Adapter #2</code>.</p>
</li>
<li>
<p>De volta ao terminal da máquina <code>debian-template</code>, vamos configurar a rede: edite o arquivo <code>/etc/network/interfaces</code> como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># nano /etc/network/interfaces
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/network/interfaces
source /etc/network/interfaces.d/*

auto lo enp0s3

iface lo inet loopback

iface enp0s3 inet static
address 10.0.42.253/24
gateway 10.0.42.1</pre>
</div>
</div>
<div class="paragraph">
<p>Para garantir que nenhum endereço IP antigo, primário, se mantenha alocado às interfaces, execute o comando <code>flush</code> e em seguida reinicie a rede do sistema:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ip addr flush label 'enp0s*' ; systemctl restart networking</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que as interfaces estão com os endereços corretamente alocados:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ip addr show label 'enp0s*' | grep 'inet ' | awk '{print $2,$NF}'
10.0.42.253/24 enp0s3</pre>
</div>
</div>
</li>
<li>
<p>Agora, configure a resolução de nomes no arquivo <code>/etc/resolv.conf</code>:</p>
<div class="literalblock">
<div class="content">
<pre># nano /etc/resolv.conf
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/resolv.conf
domain intnet.
search intnet.
nameserver 10.0.42.1
nameserver 10.0.42.2</pre>
</div>
</div>
</li>
<li>
<p>Vamos alterar o <em>script</em> <code>/root/scripts/changehost.sh</code> para que possamos configurar, de uma vez só, informações como endereço IP e <em>hostname</em> na máquina clonada. Apague todo o conteúdo do <em>script</em> original e substitua-o pelo seguinte:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash


# exibir uso do script e sair
function usage() {
  echo "  Usage: $0 -h HOSTNAME -i IPADDR -g GATEWAY"
  echo "  Netmask is assumed as /24."
  exit 1
}


# testar sintaxe valida de HOSTNAME
function valid_host() {
  if [[ "$nhost" =~ [^a-z0-9-] ]]; then
    echo "  [*] HOSTNAME must be lowercase alphanumeric: [a-z0-9]*"
    usage
  elif [ ${#nhost} -gt 63 ]; then
    echo "  [*] HOSTNAME must have &lt;63 chars"
    usage
  fi
}


# testar sintaxe valida de IPADDR/GATEWAY
function valid_ip() {
  local  ip=$1
  local  stat=1

  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    OIFS=$IFS
    IFS='.'
    ip=($ip)
    IFS=$OIFS
    [[ ${ip[0]} -le 255 &amp;&amp; \
       ${ip[1]} -le 255 &amp;&amp; \
       ${ip[2]} -le 255 &amp;&amp; \
       ${ip[3]} -le 255 ]]
        stat=$?
  fi

  if [ $stat -ne 0 ] ; then
    echo "  [*] Invalid syntax for $2"
    usage
  fi
}


while getopts ":g:h:i:" opt; do
  case "$opt" in
    g)
      ngw=${OPTARG}
      ;;
    h)
      nhost=${OPTARG}
      ;;
    i)
      nip=${OPTARG}
      ;;
    *)
      usage
      ;;
  esac
done

# testar se parametros foram informados
[ -z $ngw ]   &amp;&amp; { echo "  [*] No gateway?"; usage; }
[ -z $nhost ] &amp;&amp; { echo "  [*] No hostname?"; usage; }
[ -z $nip ]   &amp;&amp; { echo "  [*] No ipaddr?"; usage; }

# testar sintaxe de parametros
valid_ip $nip "IPADDR"
valid_ip $ngw "GATEWAY"
valid_host $nhost

# alterar endereco ip/gateway
iff="/etc/network/interfaces"
cip="$( egrep '^address ' $iff | awk -F'[ /]' '{print $2}' )"
cgw="$( egrep '^gateway ' $iff | awk '{print $NF}' )"
sed -i "s|${cip}|${nip}|g" $iff
sed -i "s|${cgw}|${ngw}|g" $iff
ip addr flush label 'enp0s*'

# alterar hostname local
chost="$( hostname -s )"
sed -i "s/${chost}/${nhost}/g" /etc/hosts
sed -i "s/${chost}/${nhost}/g" /etc/hostname

invoke-rc.d hostname.sh restart
invoke-rc.d networking restart
hostnamectl set-hostname $nhost

# re-gerar chaves SSH
rm -f /etc/ssh/ssh_host_* 2&gt; /dev/null
dpkg-reconfigure openssh-server &amp;&gt; /dev/null</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em relação ao <em>script</em> original, algumas diferenças: adicionou-se um <em>loop</em> para leitura de opções a partir da linha de comando (<em>hostname</em>, endereço IP e <em>gateway</em> a serem utilizados pela nova máquina), verificação de sintaxe dessas opções e efetiva alteração do endereço IP e <em>gateway</em> no arquivo <code>/etc/network/interfaces</code>.</p>
</div>
<div class="paragraph">
<p>Feito isso, desligue a máquina <code>debian-template</code>.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_8_criação_da_vm_de_dns_secundário">8) Criação da VM de DNS secundário</h3>
<div class="paragraph">
<p>Vamos agora criar a segunda máquina de nosso <em>datacenter</em> simulado, a máquina <code>ns2</code>. Ela atuará como um servidor DNS secundário sob o endereço IP 10.0.42.2/24, dentre outras funções que serão configuradas em sessões posteriores.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Clone a máquina <code>debian-template</code> seguindo os mesmos passos da atividade (6) da sessão 1. Para o nome da máquina, escolha <code>ns2</code>.</p>
</li>
<li>
<p>Ligue a máquina <code>ns2</code> e, após o <em>boot</em>, faça login como o usuário <code>root</code>. Usando o script <code>/root/scripts/changehost.sh</code>, efetue a configuração automática da máquina:</p>
<div class="literalblock">
<div class="content">
<pre># ip addr show label 'enp0s*' | grep 'inet ' | awk '{print $2,$NF}' ; hostname ; whoami
10.0.42.253/24 enp0s3
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h ns2 -i 10.0.42.2 -g 10.0.42.1</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ip addr show label 'enp0s*' | grep 'inet ' | awk '{print $2,$NF}' ; hostname ; whoami
10.0.42.2/24 enp0s3
ns2
root</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_9_configuração_do_dns_secundário">9) Configuração do DNS secundário</h3>
<div class="paragraph">
<p>A configuração do NSD como um servidor DNS secundário é bastante similar à do servidor primário, com algumas poucas diferenças na seção <code>pattern</code> do arquivo original. Já a configuração do Unbound, por outro lado, é absolutamente idêntica. Vamos ao trabalho:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Instale os pacotes relevantes:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install nsd unbound dnsutils</pre>
</div>
</div>
<div class="paragraph">
<p>Durante a pós-configuração do Unbound o sistema pode demorar um pouco a retornar para o <em>shell</em>&#8201;&#8212;&#8201;seja paciente, em alguns segundos a instalação será concluída.</p>
</div>
</li>
<li>
<p>Primeiro, o <strong>NSD</strong>. Queremos copiar o arquivo <code>/etc/nsd/nsd.conf</code> da máquina <code>ns1</code> e fazer as alterações necessárias&#8201;&#8212;&#8201;no entanto, o acesso SSH à essa máquina pela DMZ está proibido pelas configurações de firewall que fizemos no começo desta sessão. Assim sendo, vamos fazer a cópia no sentido oposto: da máquina <code>ns1</code> para a máquina <code>ns2</code>.</p>
<div class="paragraph">
<p>Logue como <code>root</code> na máquina <code>ns1</code> e copie o arquivo usando o <code>scp</code>, como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># scp /etc/nsd/nsd.conf aluno@ns2:~
The authenticity of host 'ns2 (10.0.42.2)' can't be established.
ECDSA key fingerprint is SHA256:jxd7SPFgwNSsaMS7ApIEMpdAmxEnWeJ83s/K4h2XV5o.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'ns2,10.0.42.2' (ECDSA) to the list of known hosts.
aluno@ns2's password:
nsd.conf                                                                           100%  909     2.5MB/s   00:00</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito, o arquivo foi copiado para <code>/home/aluno/nsd.conf</code> na máquina <code>ns2</code>&#8201;&#8212;&#8201;note que não fizemos o login remoto com o usuário <code>root</code> pois esse acesso não é permitido pela política padrão do <em>daemon</em> <code>sshd</code> no Debian.</p>
</div>
</li>
<li>
<p>De volta à máquina <code>ns2</code> como o usuário <code>root</code>, pare o NSD e gere as chaves TLS de controle:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl stop nsd</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># nsd-control-setup
setup in directory /etc/nsd
nsd_server.key exists
nsd_control.key exists
create nsd_server.pem (self signed certificate)
create nsd_control.pem (signed client certificate)
Signature ok
subject=CN = nsd-control
Getting CA Private Key
Setup success. Certificates created.</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos fazer o backup do arquivo de configuração original:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mv /etc/nsd/nsd.conf /etc/nsd/nsd.conf.orig</pre>
</div>
</div>
<div class="paragraph">
<p>Copie o arquivo <code>/home/aluno/nsd.conf</code> para a pasta <code>/etc/nsd</code> e ajuste suas permissões:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cp /home/aluno/nsd.conf /etc/nsd</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># chown root. /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -ld /etc/nsd/nsd.conf
-rw-r--r-- 1 root root 909 nov 12 12:14 /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente. Temos agora que editar o arquivo com as configurações do servidor secundário, o que faremos através do uso do <code>sed</code> nos comandos a seguir:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^\( *ip-address:\) 10\.0\.42\.1/\1 10\.0\.42\.2/' /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i '/^ *zonesdir:/d' /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/\"inslave\"/\"inmaster\"/' /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^\( *\)notify:[0-9@. ]*\(.*\)/\1allow-notify: 10\.0\.42\.1 \2/' /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^\( *\)provide-xfr:[0-9. ]*\(.*\)/\1request-xfr: AXFR 10\.0\.42\.1@8053 \2/' /etc/nsd/nsd.conf</pre>
</div>
</div>
<div class="paragraph">
<p>O que esses comandos fizeram, afinal? O comando <code>diff</code> pode ser usado para comparar arquivos, evidenciando as diferenças entre eles:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># diff -u /home/aluno/nsd.conf /etc/nsd/nsd.conf
--- /home/aluno/nsd.conf        2018-11-12 20:51:45.040000000 -0200
+++ /etc/nsd/nsd.conf   2018-11-12 20:55:34.156000000 -0200
@@ -1,10 +1,9 @@
 server:
   ip-address: 127.0.0.1
-  ip-address: 10.0.42.1
+  ip-address: 10.0.42.2
   do-ip4: yes
   port: 8053
   username: nsd
-  zonesdir: "/etc/nsd/zones"

   logfile: "/var/log/nsd.log"
   pidfile: "/run/nsd/nsd.pid"
@@ -27,17 +26,17 @@
   secret: "i7IoB5VDHVOCW9wvuOGQuFLNu8hzfAblVAbCD1SbPL4="

 pattern:
-  name: "inslave"
-  notify: 10.0.42.2@8053 inkey
-  provide-xfr: 10.0.42.2 inkey
+  name: "inmaster"
+  allow-notify: 10.0.42.1 inkey
+  request-xfr: AXFR 10.0.42.1@8053 inkey

 zone:
   name: "intnet"
-  include-pattern: "inslave"
+  include-pattern: "inmaster"
   zonefile: "intnet.zone.signed"

 zone:
   name: "42.0.10.in-addr.arpa"
-  include-pattern: "inslave"
+  include-pattern: "inmaster"
   zonefile: "10.0.42.zone"</pre>
</div>
</div>
<div class="paragraph">
<p>Não se esqueça de remover o arquivo <code>/home/aluno/nsd.conf</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># rm /home/aluno/nsd.conf</pre>
</div>
</div>
</li>
<li>
<p>Inicie o <em>daemon</em> do NSD usando o <code>nsd-control</code>:</p>
<div class="literalblock">
<div class="content">
<pre># nsd-control start</pre>
</div>
</div>
<div class="paragraph">
<p>Note que não foi necessário criar o diretório de zonas no servidor secundário, <code>/etc/nsd/zones</code>, já que as zonas transferidas ficam mantidas no diretório <code>/var/lib/nsd</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -1 /var/lib/nsd
nsd.db
xfrd.state</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos testar? Tente efetuar uma resolução direta de nomes no servidor local usando a ferramenta <code>dig</code>, também testando o funcionamento do DNSSEC:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig @127.0.0.1 -p 8053 ns1.intnet +dnssec +noadditional +noquestion +multiline +noauthority

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; @127.0.0.1 -p 8053 ns1.intnet +dnssec +noadditional +noquestion +multiline +noauthority
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 29660
;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 3, ADDITIONAL: 3
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags: do; udp: 4096
;; ANSWER SECTION:
ns1.intnet.             86400 IN A 10.0.42.1
ns1.intnet.             86400 IN RRSIG A 10 2 86400 (
                                20181210223558 20181112223558 14936 intnet.
                                TdK1Ivm1Ykdk1MBaMQSqNHANV14FQbfdBCgiOznMc7wT
                                vqZPa2TBMTe2GYvcjbWd2WzH4o88pOAzwmCxMnnAxGJ4
                                7IglUx4GlQKTG/hx/5vxpFYgczJLAKpt/HEMfrInYVyP
                                qvCFpCyUudgA7kV8w05+BvBiK4IQAWZCiH8GcC3ERFoC
                                B/ZNE/f8YnMyi2sNqdN8Mhtkgz2vMZnACiLrifnV7hlI
                                3uvqn0fQetnDWLF/xSeHoAE4WMZ6KwMgutUT1H9lQwOg
                                Ci5PemGKnOn2Va4ARzvQeTzBdLHZlVi04X25NHIeKZTj
                                8Sx1vRnBwPfT8qlyI1oaOozuiLSyrII3Mw== )

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8053(127.0.0.1)
;; WHEN: Mon Nov 12 20:58:05 -02 2018
;; MSG SIZE  rcvd: 985</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente. E quanto à resolução reversa?</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig @127.0.0.1 -p 8053 -x 10.0.42.2 +noadditional +noquestion

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; @127.0.0.1 -p 8053 -x 10.0.42.2 +noadditional +noquestion
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 44932
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; ANSWER SECTION:
2.42.0.10.in-addr.arpa. 86400   IN      PTR     ns2.intnet.

;; AUTHORITY SECTION:
42.0.10.in-addr.arpa.   86400   IN      NS      ns1.intnet.
42.0.10.in-addr.arpa.   86400   IN      NS      ns2.intnet.

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8053(127.0.0.1)
;; WHEN: Mon Nov 12 20:58:17 -02 2018
;; MSG SIZE  rcvd: 107</pre>
</div>
</div>
</li>
<li>
<p>Agora, vamos configurar o <strong>Unbound</strong>. Como feito anteriormente, logue como <code>root</code> na máquina <code>ns1</code> e copie desta vez o arquivo <code>/etc/unbound/unbound.conf</code> usando o <code>scp</code>, como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># scp /etc/unbound/unbound.conf aluno@ns2:~
aluno@ns2's password:
unbound.conf                                                                       100%  820     2.4MB/s   00:00</pre>
</div>
</div>
<div class="paragraph">
<p>O arquivo foi copiado para <code>/home/aluno/unbound.conf</code> na máquina <code>ns2</code>, como objetivado.</p>
</div>
</li>
<li>
<p>De volta a <code>ns2</code> como o usuário <code>root</code>, pare o <em>daemon</em> do Unbound e configure as chaves de controle:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl stop unbound</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># unbound-control-setup
setup in directory /etc/unbound
unbound_server.key exists
unbound_control.key exists
create unbound_server.pem (self signed certificate)
create unbound_control.pem (signed client certificate)
Signature ok
subject=CN = unbound-control
Getting CA Private Key
Setup success. Certificates created.</pre>
</div>
</div>
<div class="paragraph">
<p>Faça o backup do arquivo de configuração original:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mv /etc/unbound/unbound.conf /etc/unbound/unbound.conf.orig</pre>
</div>
</div>
<div class="paragraph">
<p>Copie o arquivo <code>/home/aluno/unbound.conf</code> para a pasta <code>/etc/unbound</code> e ajuste suas permissões:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cp /home/aluno/unbound.conf /etc/unbound</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># chown root. /etc/unbound/unbound.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -ld /etc/unbound/unbound.conf
-rw-r--r-- 1 root root 820 nov 12 22:15 /etc/unbound/unbound.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo com as configurações do servidor secundário via <code>sed</code>, como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^\( *interface: 10\.0\.42\.\)1/\12/' /etc/unbound/unbound.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i '/^ *interface: 192.*/d' /etc/unbound/unbound.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Use o comando <code>diff</code> para verificar as diferenças entre o arquivo original e as alterações feitas com o <code>sed</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># diff -u /home/aluno/unbound.conf /etc/unbound/unbound.conf
--- /home/aluno/unbound.conf    2018-11-12 22:13:47.276000000 -0200
+++ /etc/unbound/unbound.conf   2018-11-12 22:24:48.564000000 -0200
@@ -1,7 +1,6 @@
 server:
   interface: 127.0.0.1
-  interface: 10.0.42.1
-  interface: 192.168.42.1
+  interface: 10.0.42.2
   port: 53

   access-control: 127.0.0.0/8 allow</pre>
</div>
</div>
<div class="paragraph">
<p>Remova o arquivo de configuração do Unbound no diretório <code>/home/aluno</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># rm /home/aluno/unbound.conf</pre>
</div>
</div>
</li>
<li>
<p>Vamos proceder aos testes. Inicie o Unbound usando o comando <code>unbound-control</code>:</p>
<div class="literalblock">
<div class="content">
<pre># unbound-control start</pre>
</div>
</div>
<div class="paragraph">
<p>Teste uma resolução direta qualquer no servidor Unbound local, solicitando DNSSEC:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig @127.0.0.1 mx1.intnet +dnssec +multiline +noquestion +noadditional

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; @127.0.0.1 mx1.intnet +dnssec +multiline +noquestion +noadditional
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 53007
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags: do; udp: 4096
;; ANSWER SECTION:
mx1.intnet.             86388 IN A 10.0.42.91
mx1.intnet.             86388 IN RRSIG A 10 2 86400 (
                                20181210223558 20181112223558 14936 intnet.
                                YPluG8EXq3WwlKIlMpeXc+C1C3AZhC+P1ej+6I5ax9Aw
                                xQ+Zp6lwMXz64e7nPN2mjNa1PcAVuUNc8gE77U5dohhI
                                Al++b4+1mPHLzN6EY4UuSsWqkE5NacSaUngmhV52Mrwj
                                cwXtmJgJm9vhSTLKnUSYhSwFWZlC2FxI96kTQhtzJuDd
                                KI7SVpYsNZPGiKwj5r9F8Wr/sKpCc0PgVnseewyPmNGY
                                5pJEV3Ox6XgzQk0qjatoO4IxSj3CqX6ghU+MykcU2L+n
                                56LfqqrV+R6TzzVst9/bFC7UgSXjF4v9eDKvPc86mcGn
                                J9giG3w+07D2+jv7Ap6RfQWnx1zBy5CWFA== )

;; Query time: 0 msec
;; SERVER: 127.0.0.1#53(127.0.0.1)
;; WHEN: Mon Nov 12 22:45:11 -02 2018
;; MSG SIZE  rcvd: 349</pre>
</div>
</div>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_3_autenticação_centralizada">Sessão 3: Autenticação centralizada</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retomando o cenário apresentado na introdução da primeira sessão, num ambiente em que a virtualização é usada em larga escala, teremos diversas máquinas virtuais operando cada qual com seus serviços alocados. Imagine, hipoteticamente, que temos centenas de VMs dentro do <em>datacenter</em>. Vários desafios podem surgir à mente, mas tente responder a seguinte pergunta: com relação à gestão de contas, o que fazer quando um novo colaborar é integrado à equipe? Ou, por outro lado, quando um funcionário é desligado da empresa?</p>
</div>
<div class="paragraph">
<p>Ora, se temos centenas de VMs, é fácil supor que teremos que logar nas diferentes máquinas que novo colaborador (ou o antigo) deverá acessar e criar uma conta de usuário para ele&#8201;&#8212;&#8201;além disso, adicioná-lo a grupos e editar permissões relevantes. Fazer esse procedimento inúmeras vezes é claramente um processo que pode gerar erros de configuração, então poderia-se pensar em automatizá-lo, digamos, via <em>shell scripts</em>. Uma boa solução, mas não a ideal neste caso.</p>
</div>
<div class="paragraph">
<p>Sistemas de autenticação centralizados, como NIS (<em>Network Information Service</em>) ou LDAP (<em>Lightweight Directory Access Protocol</em>) são excelentes ferramentas para facilitar a gestão em cenários como o apresentado&#8201;&#8212;&#8201;adicionando o usuário em um único ponto, é possível distribuir essa configuração para dezenas, ou centenas, de máquinas de forma instantânea. O gerenciamento de grupos no sistema centralizado também permite atribuir permissionamento de forma fácil, ou removê-lo quando necessário.</p>
</div>
<div class="paragraph">
<p>Nesta sessão, iremos configurar um sistema de autenticação centralizado para o nosso laboratório usando LDAP, no qual gerenciaremos usuários e grupos, e faremos a integração desse sistema de autenticação com o Linux através do PAM (<em>Pluggable Authentication Modules</em>). Em lugar de fazer o controle de senhas dos usuários diretamente via <code>/etc/shadow</code> ou no LDAP, criaremos um sistema de autoridade certificadora (<em>Certificate Authority</em>) para o SSH, com o qual os usuários farão login nos servidores usando chaves assimétricas assinadas pela CA. Finalmente, para controlar ataques de força-bruta contra os servidores, usaremos o programa Fail2Ban para realizar o bloqueio automático de atacantes no firewall de host das máquinas.</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão_2">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>A figura abaixo mostra a topologia de rede que será utilizada nesta sessão, com as máquinas relevantes em destaque.</p>
</div>
<div id="img-topologia3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/Topologia_SEG10_S3.png" alt="Topologia SEG10 S3">
</div>
<div class="title">Figure 27. Topologia de rede desta sessão</div>
</div>
<div class="paragraph">
<p>Teremos três máquinas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ns1</code>, com <em>alias</em> <code>fw</code>, atuando como firewall de rede e DNS primário. Endereços IP via DHCP (interface <em>bridge</em>), 10.0.42.1/24 (interface DMZ) e 192.168.42.1/24 (interface Intranet).</p>
</li>
<li>
<p><code>ns2</code>, com <em>alias</em> <code>ldap</code>, localizada na DMZ e atuando como DNS secundário, servidor LDAP de autenticação centralizada e repositório de chaves SSH-CA. Endereço IP 10.0.42.2/24.</p>
</li>
<li>
<p><code>client</code>, localizada na Intranet e usada a partir de agora como ponto de partida para logins remotos nos diferentes servidores do <em>datacenter</em> simulado. Endereço IP 192.168.42.2/24.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Observe que a topologia acima prevê a criação de um novo <em>alias</em> de rede para a máquina <code>ns2</code>, o nome <code>ns2</code>. Antes de começar, vamos ajustar nossa configuração DNS para refletir essa situação: acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo de zonas <code>/etc/nsd/zones/intnet.zone</code>, inserindo uma entrada CNAME para a máquina <code>ns2</code>, como se segue. <strong>Não se esqueça</strong> de incrementar o valor do serial no topo do arquivo!</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/intnet.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep '^ldap ' /etc/nsd/zones/intnet.zone
ldap    IN    CNAME             ns2</pre>
</div>
</div>
<div class="paragraph">
<p>Assine o arquivo de zonas usando o <em>script</em> criado na sessão anterior:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash /root/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 0 rrsets, 0 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que a entrada foi criada com sucesso, usando o comando <code>dig</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig @127.0.0.1 ldap.intnet +noall +answer

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; @127.0.0.1 ldap.intnet +noall +answer
; (1 server found)
;; global options: +cmd
ldap.intnet.            86138   IN      CNAME   ns2.intnet.
ns2.intnet.             86138   IN      A       10.0.42.2</pre>
</div>
</div>
<div class="paragraph">
<p>Certifique-se que a transferência de zonas entre o servidor DNS primário e secundário está funcionando corretamente&#8201;&#8212;&#8201;repita a consulta, desta vez no servidor <code>ns2</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig @10.0.42.2 ldap.intnet +noquestion

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; @10.0.42.2 ldap.intnet +noquestion
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48391
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; ANSWER SECTION:
ldap.intnet.            86207   IN      CNAME   ns2.intnet.
ns2.intnet.             86207   IN      A       10.0.42.2

;; Query time: 0 msec
;; SERVER: 10.0.42.2#53(10.0.42.2)
;; WHEN: Tue Nov 13 18:28:16 -02 2018
;; MSG SIZE  rcvd: 74</pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_2_configuração_do_servidor_ldap">2) Configuração do servidor LDAP</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O servidor LDAP, como explicitado na topologia desta sessão, será a máquina <code>ns2</code>. Acesse-a como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos, primeiramente, instalar o servidor LDAP através dos pacotes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get install slapd ldap-utils ldapscripts</pre>
</div>
</div>
<div class="paragraph">
<p>Durante a instalação, será solicitada uma senha administrativa para o LDAP, que iremos redefinir em breve. Informe <code>rnpesr</code>.</p>
</div>
</li>
<li>
<p>Agora, vamos reconfigurar o servidor LDAP para definir alguns parâmetros que não foram questionados durante a instalação via <code>apt-get</code>. Execute:</p>
<div class="literalblock">
<div class="content">
<pre># dpkg-reconfigure -plow slapd</pre>
</div>
</div>
<div class="paragraph">
<p>Informe as seguintes opções:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Configurações do pacote slapd</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pergunta</th>
<th class="tableblock halign-left valign-top">Opção</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Omitir a configuração do servidor OpenLDAP?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Não</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nome de domínio DNS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">intnet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nome da organização</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">seg10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Senha do administrador</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rnpesr (repetir)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Backend da base de dados a ser usado</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MDB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Você deseja que a base de dados seja removida quando o pacote slapd for expurgado ("purged")</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Não</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Move a base de dados antiga</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sim</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Durante a configuração, será criada uma base LDAP (semi) vazia, apenas com a raiz <code>dc=intnet</code> e o usuário administrativo <code>cn=admin,dc=intnet</code>. Iremos popular esta base brevemente.</p>
</div>
</li>
<li>
<p>Agora, vamos instalar o <code>nslcd</code>, um <em>daemon</em> LDAP local para resolução de diretivas de autenticação. Execute:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install nslcd</pre>
</div>
</div>
<div class="paragraph">
<p>Durante a instalação do pacote, informe as seguintes opções:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Configurações do pacote nslcd</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pergunta</th>
<th class="tableblock halign-left valign-top">Opção</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">URI do servidor LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ldapi:///</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Base de buscas do servidor LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dc=intnet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Serviços de nome para configurar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">passwd, group, shadow</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note que informamos que a localização do servidor LDAP é local, já que ele está instalado na máquina corrente. Além disso, iremos configurar as bases de contas (<code>passwd</code>), grupos (<code>group</code>) e senhas (<code>shadow</code>) junto ao LDAP.</p>
</div>
</li>
<li>
<p>Vamos configurar as opções padrão dos binários de linha de comando do <code>ldap-utils</code> (como os comandos <code>ldapsearch</code> e <code>ldapadd</code>, por exemplo). Edite manualmente ou use o <code>sed</code> para editar as linhas apropriadas do arquivo <code>/etc/ldap/ldap.conf</code>:</p>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^#\(BASE\).*/\1 dc=intnet/' /etc/ldap/ldap.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^#\(URI\).*/\1 ldapi\:\/\/\//' /etc/ldap/ldap.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que os valores editados estão corretos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># grep -v '^#' /etc/ldap/ldap.conf | sed '/^$/d'
BASE dc=intnet
URI ldapi:///
TLS_CACERT      /etc/ssl/certs/ca-certificates.crt</pre>
</div>
</div>
</li>
<li>
<p>A seguir, vamos configurar o <code>ldapscripts</code>, um conjunto de ferramentas auxiliares que facilitam enormemente a configuração e uso de bases LDAP via linha de comando. Primeiro, edite manualmente ou use o <code>sed</code> para ajustar o arquivo <code>/etc/ldapscripts/ldapscripts.conf</code>, informando o <em>bind DN</em> do usuário administrativo na base LDAP, como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^\(BINDDN=\).*/\1\"cn=admin,dc=intnet\"/' /etc/ldapscripts/ldapscripts.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Depois, informe a senha do usuário administrativo no arquivo <code>/etc/ldapscripts/ldapscripts.passwd</code>. Execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># echo -n "rnpesr" &gt; /etc/ldapscripts/ldapscripts.passwd</pre>
</div>
</div>
<div class="paragraph">
<p>Como a senha do usuário administrativo do LDAP está embutida em texto claro nesse arquivo, é fundamental garantir que suas permissões estão suficientemente estritas. Verifique:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -ld /etc/ldapscripts/ldapscripts.passwd
-rw-r----- 1 root root 6 out 29 09:16 /etc/ldapscripts/ldapscripts.passwd</pre>
</div>
</div>
</li>
<li>
<p>Vamos inicializar a base LDAP usando o <code>ldapscripts</code>. Execute:</p>
<div class="literalblock">
<div class="content">
<pre># ldapinit -s</pre>
</div>
</div>
</li>
<li>
<p>Será que funcionou? Consulte a base LDAP sem autenticação, e liste seu conteúdo:</p>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -x -LLL
dn: dc=intnet
objectClass: top
objectClass: dcObject
objectClass: organization
o: seg10
dc: intnet

dn: cn=admin,dc=intnet
objectClass: simpleSecurityObject
objectClass: organizationalRole
cn: admin
description: LDAP administrator

dn: ou=People,dc=intnet
objectClass: top
objectClass: organizationalUnit
ou: People

dn: ou=Groups,dc=intnet
objectClass: top
objectClass: organizationalUnit
ou: Groups

dn: ou=Hosts,dc=intnet
objectClass: top
objectClass: organizationalUnit
ou: Hosts

dn: ou=Idmap,dc=intnet
objectClass: organizationalUnit
ou: Idmap</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito! Temos configurada a raiz <code>dc=intnet</code> e usuário administrativo <code>cn=admin,dc=intnet</code> como anteriormente, e o comando <code>ldapinit</code> se encarregou de criar DNs para armazenar usuários, grupos, <em>hosts</em> e mapeamentos de identidade na base LDAP. Podemos prosseguir.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_habilitando_logs_do_ldap">3) Habilitando logs do LDAP</h3>
<div class="paragraph">
<p>Por padrão, o <em>daemon</em> <code>slapd</code> envia logs para a <em>facility</em> <code>local4</code> do sistema. Porém, após a instalação via <code>apt-get</code>, seu <em>log level</em> (nível de criticidade dos eventos registrados) é configurado para <code>none</code>&#8201;&#8212;&#8201;ou seja, nenhum evento é registrado. Evidentemente, essa situação não é interessante ao configurar o servidor, pois será muito difícil identificar as fontes de problemas se não tivermos nenhum log para consultar. Vamos corrigir isso.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, crie um diretório específico para o armazenamento de LDIFs. LDIFs são uma sigla para LDAP <em>Data Interchange Format</em>, arquivos de texto plano que podem ser usados para representar informações em uma base LDAP. Algo equivalente a arquivos <em>dump</em> de bases SQL, em comparação livre.</p>
<div class="literalblock">
<div class="content">
<pre># mkdir /root/ldif</pre>
</div>
</div>
</li>
<li>
<p>Crie neste diretório um LDIF de nome <code>/root/ldif/slapdlog.ldif</code>, com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dn: cn=config
changeType: modify
replace: olcLogLevel
olcLogLevel: stats</code></pre>
</div>
</div>
<div class="paragraph">
<p>O LDIF acima irá alterar o valor do parâmetro <code>olcLogLevel</code>, que define o <em>log level</em> do <code>slapd</code>, para <code>stats.</code> Para aplicar essa configuração, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapmodify -Y external -H ldapi:/// -f /root/ldif/slapdlog.ldif</pre>
</div>
</div>
</li>
<li>
<p>O próximo passo é informar ao <code>rsyslog</code> que as mensagens enviadas para a <em>facility</em> <code>local4</code> devem ser enviadas para um arquivo específico. Crie o arquivo novo <code>/etc/rsyslog.d/slapd.conf</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$template slapdtmpl,"[%$DAY%-%$MONTH%-%$YEAR% %timegenerated:12:19:date-rfc3339%] %app-name% %syslogseverity-text% %msg%\n"
local4.*    /var/log/slapd.log;slapdtmpl</code></pre>
</div>
</div>
</li>
<li>
<p>Em seguida, reinicie ambos os <em>daemons</em> do <code>rsyslog</code> e do <code>slapd</code>:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl restart rsyslog.service</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart slapd.service</pre>
</div>
</div>
</li>
<li>
<p>Verifique que os registros de eventos do <code>slapd</code> estão sendo, de fato, enviados para o arquivo <code>/var/log/slapd.log</code>:</p>
<div class="literalblock">
<div class="content">
<pre># tail /var/log/slapd.log
[13-11-2018 18:35:18] slapd debug  daemon: shutdown requested and initiated.
[13-11-2018 18:35:18] slapd debug  slapd shutdown: waiting for 0 operations/tasks to finish
[13-11-2018 18:35:18] slapd debug  slapd stopped.
[13-11-2018 18:35:18] slapd debug  @(#) $OpenLDAP: slapd  (May 23 2018 04:25:19) $#012#011Debian OpenLDAP Maintainers &lt;pkg-openldap-devel@lists.alioth.debian.org&gt;
[13-11-2018 18:35:18] slapd debug  slapd starting</pre>
</div>
</div>
</li>
<li>
<p>A rotação de logs deve ser habilitada, caso contrário os arquivos de log poderão ficar excessivamente grandes. Crie o arquivo novo <code>/etc/logrotate.d/slapd</code>, com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">/var/log/slapd.log {
  missingok
  notifempty
  compress
  daily
  rotate 30
  sharedscripts
  postrotate
    systemctl restart rsyslog.service
  endscript
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como o <code>logrotate</code> é invocado via <code>cron</code>, não é necessário reiniciar nenhum serviço neste caso.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_edição_de_índices_e_permissões_no_ldap">4) Edição de índices e permissões no LDAP</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Para maior performance durante as consultas ao LDAP, é recomendável aumentar os parâmetros de indexação de alguns atributos. Crie o arquivo <code>/root/ldif/olcDbIndex.ldif</code>, com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dn: olcDatabase={1}mdb,cn=config
changetype: modify
replace: olcDbIndex
olcDbIndex: objectClass eq
olcDbIndex: cn pres,sub,eq
olcDbIndex: sn pres,sub,eq
olcDbIndex: uid pres,sub,eq
olcDbIndex: displayName pres,sub,eq
olcDbIndex: default sub
olcDbIndex: uidNumber eq
olcDbIndex: gidNumber eq
olcDbIndex: mail,givenName eq,subinitial
olcDbIndex: dc eq</code></pre>
</div>
</div>
<div class="paragraph">
<p>O LDIF acima irá alterar o valor do parâmetro <code>olcDbIndex</code>, que define quais parâmetros serão indexados pelo <code>slapd</code> e quais tipos de busca serão suportados. Para aplicar essa configuração, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapmodify -Y EXTERNAL -H ldapi:/// -f /root/ldif/olcDbIndex.ldif</pre>
</div>
</div>
</li>
<li>
<p>É interessante permitir que usuários possam alterar seus parâmetros <code>loginShell</code> e entrada <code>gecos</code> (informações de conta do usuário) via comandos <code>chsh</code> e <code>chfn</code>. Para fazer isso, crie o arquivo novo <code>/root/ldif/olcAccess.ldif</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dn: olcDatabase={1}mdb,cn=config
changetype: modify
add: olcAccess
olcAccess: {1}to attrs=loginShell,gecos
  by dn="cn=admin,dc=intnet" write
  by self write
  by * read</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para aplicar a configuração, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapmodify -Y EXTERNAL -H ldapi:/// -f /root/ldif/olcAccess.ldif</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_adição_de_grupos_e_usuários_no_ldap">5) Adição de grupos e usuários no LDAP</h3>
<div class="paragraph">
<p>Agora sim, vamos começar a criar usuários e grupos em nossa base LDAP. Imagine que iremos criar um grupo de nome <code>sysadm</code>, no qual estarão todos os administradores de sistema que têm permissão para acessar servidores não-críticos. Nesse grupo, iremos criar o usuário <code>luke</code>, com senha <code>seg10luke</code>. Como proceder?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, crie o grupo usando o comando <code>ldapaddgroup</code>:</p>
<div class="literalblock">
<div class="content">
<pre># ldapaddgroup sysadm
Successfully added group sysadm to LDAP</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que o grupo foi corretamente criado usando o <code>ldapsearch</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -x -LLL 'cn=sysadm'
dn: cn=sysadm,ou=Groups,dc=intnet
objectClass: posixGroup
cn: sysadm
gidNumber: 10000
description: Group account</pre>
</div>
</div>
</li>
<li>
<p>A seguir, crie o usuário <code>luke</code>, informando seu grupo primário como <code>sysadm</code>:</p>
<div class="literalblock">
<div class="content">
<pre># ldapadduser luke sysadm
Successfully added user luke to LDAP
Successfully set password for user luke</pre>
</div>
</div>
<div class="paragraph">
<p>Novamente, consulte o <code>ldapsearch</code> para checar se o usuário foi criado com sucesso:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -x -LLL 'cn=luke'
dn: uid=luke,ou=People,dc=intnet
objectClass: account
objectClass: posixAccount
cn: luke
uid: luke
uidNumber: 10000
gidNumber: 10000
homeDirectory: /home/luke
loginShell: /bin/bash
gecos: luke
description: User account</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>ldapid</code> também é uma boa opção neste cenário, fornecendo saída bastante similar à do comando <code>id</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapid luke
uid=10000(luke) gid=10000(sysadm) groups=10000(sysadm),10000(sysadm)</pre>
</div>
</div>
</li>
<li>
<p>Vamos configurar a senha do usuário <code>luke</code> como <code>seg10luke</code>:</p>
<div class="literalblock">
<div class="content">
<pre># ldapsetpasswd luke
Changing password for user uid=luke,ou=People,dc=intnet
New Password:
Retype New Password:
Successfully set password for user uid=luke,ou=People,dc=intnet</pre>
</div>
</div>
<div class="paragraph">
<p>Para verificar, cheque que o campo <code>userPassword</code> do usuário está preenchido com um <em>hash</em> de senha. Para o comando <code>ldapsearch</code> funcionar, temos que informar um <em>bind DN</em> administrativo e senha correspondente, já que este atributo não é legível sem autenticação:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -x -LLL -D 'cn=admin,dc=intnet' -W 'cn=luke' userPassword
Enter LDAP Password:
dn: uid=luke,ou=People,dc=intnet
userPassword:: e1NTSEF9NHdUSWZRcUhGR0o5VU5jNS9tVnhoaGJzNFVvNkFzMmE=</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>ldapfinger</code> também é uma boa opção para consultar as informações do usuário (e seu <em>hash</em> de senha), já que faz parte do <code>ldapscripts</code> e utiliza as credenciais administrativas que configuramos anteriormente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapfinger luke
dn: uid=luke,ou=People,dc=intnet
objectClass: account
objectClass: posixAccount
cn: luke
uid: luke
uidNumber: 10000
gidNumber: 10000
homeDirectory: /home/luke
loginShell: /bin/bash
gecos: luke
description: User account
userPassword:: e1NTSEF9NEU0aFI2N3lCNGplUHdXRHNHVEZYZTBEYm5YdGxDTUg=</pre>
</div>
</div>
</li>
<li>
<p>Apesar de termos informado o grupo <code>sysadm</code> como grupo primário do usuário <code>luke</code>, do ponto de vista do grupo esse usuário ainda não o integra. O comando <code>ldapaddusertogroup</code> faz esse trabalho:</p>
<div class="literalblock">
<div class="content">
<pre># ldapaddusertogroup luke sysadm
Successfully added user luke to group cn=sysadm,ou=Groups,dc=intnet</pre>
</div>
</div>
<div class="paragraph">
<p>Para verificar o pertencimento, use o comando <code>ldapsearch</code>, consultando os atributos <code>memberUid</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -x -LLL 'cn=sysadm'
dn: cn=sysadm,ou=Groups,dc=intnet
objectClass: posixGroup
cn: sysadm
gidNumber: 10000
description: Group account
memberUid: luke</pre>
</div>
</div>
<div class="paragraph">
<p>O <code>ldapgid</code>, parte da suíte <code>ldapscripts</code>, também é uma alternativa interessante:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapgid sysadm
gid=10000(sysadm) users(primary)=10000(luke) users(secondary)=10000(luke)</pre>
</div>
</div>
</li>
<li>
<p>Como já mencionado algumas vezes, o <code>ldapscripts</code> oferece um conjunto de programas que facilitam bastante as tarefas corriqueiras de manipulação da base LDAP via linha de comando. Apesar de termos trabalhado um bom número desses programas, listamos abaixo alguns outros que não foram utilizados. Consulte suas páginas de manual para mais informações sobre como operá-los:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Deleção de entradas:</p>
<div class="ulist">
<ul>
<li>
<p><code>/usr/sbin/ldapdeletegroup</code></p>
</li>
<li>
<p><code>/usr/sbin/ldapdeleteuser</code></p>
</li>
<li>
<p><code>/usr/sbin/ldapdeleteuserfromgroup</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Modificação de entradas:</p>
<div class="ulist">
<ul>
<li>
<p><code>/usr/sbin/ldapmodifygroup</code></p>
</li>
<li>
<p><code>/usr/sbin/ldapmodifyuser</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Renomear entradas:</p>
<div class="ulist">
<ul>
<li>
<p><code>/usr/sbin/ldaprenamegroup</code></p>
</li>
<li>
<p><code>/usr/sbin/ldaprenameuser</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Configurar grupo primário de um usuário:</p>
<div class="ulist">
<ul>
<li>
<p><code>/usr/sbin/ldapsetprimarygroup</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_integração_e_teste_do_sistema_de_autenticação_com_ldap">6) Integração e teste do sistema de autenticação com LDAP</h3>
<div class="paragraph">
<p>Agora, vamos integrar o sistema de autenticação do Linux com a base LDAP que configuramos anteriormente usando o PAM (<em>Pluggable Authentication Modules</em>). Felizmente, muito do trabalho de configuração já foi feito automaticamente pelos <em>scripts</em> de instalação do <code>apt-get</code> quando instalamos o pacote <code>nslcd</code>. Faltam apenas alguns poucos passos.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Quando um usuário do LDAP efetua login em uma máquina pela primeira vez, seu diretório <em>home</em> não existe, naturalmente. Vamos configurar o PAM para criar esse diretório automaticamente. Crie o arquivo novo <code>/usr/share/pam-configs/mkhomedir</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">Name: Create home directory during login
Default: yes
Priority: 900
Session-Type: Additional
Session:
        required        pam_mkhomedir.so umask=0022 skel=/etc/skel</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pam-auth-update</pre>
</div>
</div>
<div class="paragraph">
<p>Durante a configuração do PAM, na pergunta "Perfis PAM para habilitar", mantenha todas as caixas marcadas e selecione OK.</p>
</div>
<div class="paragraph">
<p>Verifique que a configuração surtiu efeito pesquisando pelo termo <code>mkhomedir</code> nos arquivos de configuração do PAM, em <code>/etc/pam.d</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># grep -ri mkhomedir /etc/pam.d
/etc/pam.d/common-session:session       required        pam_mkhomedir.so umask=0022 skel=/etc/skel
/etc/pam.d/common-session-noninteractive:session        required        pam_mkhomedir.so umask=0022 skel=/etc/skel</pre>
</div>
</div>
</li>
<li>
<p>Reinicie os <em>daemons</em> <code>nslcd</code> e <code>nscd</code> para que a <em>cache</em> de usuários, grupos e senhas do LDAP seja atualizada:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nslcd.service</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nscd.service</pre>
</div>
</div>
</li>
<li>
<p>Será que funcionou? Pesquise a lista de usuários do sistema e busque pelo usuário recém-criado <code>luke</code>:</p>
<div class="literalblock">
<div class="content">
<pre># getent passwd | grep luke
luke:*:10000:10000:luke:/home/luke:/bin/bash</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente! E quando ao grupo <code>sysadm</code>?</p>
</div>
<div class="literalblock">
<div class="content">
<pre># getent group | grep sysadm
sysadm:*:10000:luke</pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, consulte se o usuário <code>luke</code> é reconhecido como membro de <code>sysadm</code> pelo sistema:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># groups luke
luke : sysadm</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar: tente logar via <code>ssh</code> na máquina local usando o usuário <code>luke</code>:</p>
<div class="literalblock">
<div class="content">
<pre># ssh luke@localhost
The authenticity of host 'localhost (::1)' can't be established.
ECDSA key fingerprint is SHA256:mI2LM9Nxt5ltC7/VnlEgB+JBdqFbKxUj1FhhvLijcv4.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'localhost' (ECDSA) to the list of known hosts.
luke@localhost's password:
Creating directory '/home/luke'.</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito. Note que o diretório <code>/home/luke</code> foi criado automaticamente, como esperado. Faça as verificações pós-login de costume:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami
luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ pwd
/home/luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ id
uid=10000(luke) gid=10000(sysadm) grupos=10000(sysadm)</pre>
</div>
</div>
</li>
<li>
<p>Falta testar se o usuário consegue alterar sua senha diretamente via console, sem necessidade de edição direta à base LDAP. Primeiro, verifique o <em>hash</em> da senha atual&#8201;&#8212;&#8201;note que iremos usar o próprio DN do usuário <code>luke</code> como <em>bind DN</em> durante a conexão LDAP, motivo pelo qual deve-se informar a senha desse usuário, e não do administrador:</p>
<div class="literalblock">
<div class="content">
<pre>$ ldapsearch -x -LLL -D 'uid=luke,ou=People,dc=intnet' -W 'uid=luke' userPassword
Enter LDAP Password:
dn: uid=luke,ou=People,dc=intnet
userPassword:: e1NTSEF9K29BcE55S3AwRU9XM0sreWVPeFNoZUJjdFhBbVJyVEg=</pre>
</div>
</div>
<div class="paragraph">
<p>Use o comando <code>passwd</code> para alterar a senha para um outro valor qualquer:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ passwd
(current) LDAP Password:
Nova senha:
Redigite a nova senha:
passwd: senha atualizada com sucesso</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique novamente o <em>hash</em> da senha do usuário <code>luke</code> e compare os dois valores:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ldapsearch -x -LLL -D 'uid=luke,ou=People,dc=intnet' -W 'uid=luke' userPassword
Enter LDAP Password:
dn: uid=luke,ou=People,dc=intnet
userPassword:: e1NTSEF9b0REb2lVbWgvR0swMm9qaGJoZWJ2ZGtNYzFKTE1kazk=</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito, os <em>hashes</em> são diferentes; ou seja, a alteração de senha via <code>passwd</code> funcionou normalmente. Retorne a senha do usuário <code>luke</code> ao valor anterior, para evitar confusões no futuro.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_7_configurando_uma_autoridade_certificadora_ca_para_o_ssh">7) Configurando uma autoridade certificadora (CA) para o SSH</h3>
<div class="paragraph">
<p>Até o momento, instalamos e configuramos uma base LDAP, e testamos sua integração com os sistemas de autenticação do sistema usando o <code>ssh</code>. Porém, a todo momento, tivemos que digitar as senhas dos usuários para nos autenticar&#8201;&#8212;&#8201;será que podemos fazer isso de uma forma mais segura?</p>
</div>
<div class="paragraph">
<p>Nesta atividade iremos configurar uma autoridade certificadora para o <code>ssh</code>, com a qual assinaremos pares de chaves de <em>hosts</em> e de usuários. De posse dessas chaves, não será mais necessário informar senhas durante o login, tornando o processo significativamente mais seguro (desde que se tome cuidado para não perder a chave privada, como veremos).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, verifique que você está logado como usuário <code>root</code> na máquina <code>ns2</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
</li>
<li>
<p>Vamos adicionar um novo usuário à base LDAP, <code>sshca</code>, que será responsável por realizar os processos de assinaturas de chaves de <em>hosts</em> e usuários. Esse usuário irá pertencer ao grupo <code>setup</code>, um grupo especial para atividades de configuração de sistemas. Sua senha será <code>seg10sshca</code>.</p>
<div class="paragraph">
<p>Vamos por partes. Primeiro, crie o grupo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapaddgroup setup
Successfully added group setup to LDAP</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, o usuário:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapadduser sshca setup
Successfully added user sshca to LDAP
Successfully set password for user sshca</pre>
</div>
</div>
<div class="paragraph">
<p>Adicione o usuário ao grupo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapaddusertogroup sshca setup
Successfully added user sshca to group cn=setup,ou=Groups,dc=intnet</pre>
</div>
</div>
<div class="paragraph">
<p>E, finalmente, configure a senha do usuário <code>sshca</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsetpasswd sshca
Changing password for user uid=sshca,ou=People,dc=intnet
New Password:
Retype New Password:
Successfully set password for user uid=sshca,ou=People,dc=intnet</pre>
</div>
</div>
</li>
<li>
<p>Faça login com o usuário recém-criado no sistema local:</p>
<div class="literalblock">
<div class="content">
<pre># ssh sshca@localhost
sshca@localhost's password:
Creating directory '/home/sshca'.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami
sshca</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ pwd
/home/sshca</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar dois pares de chaves para a CA (<em>Certificate Authority</em>, ou autoridade certificadora) do <code>ssh</code>: uma para assinar chaves de <em>hosts</em>, denominada <code>server_ca</code>, e outra para assinar chaves de usuários, denominada <code>user_ca</code>. Iremos criar chaves RSA de 4096 bits, e devemos escolher uma senha bastante segura para a chave privada&#8201;&#8212;&#8201;já que, com ela, pode-se assinar quaisquer chaves <code>ssh</code> que autorizarão máquinas a se passarem por membros do nosso <em>datacenter</em> e usuários a logarem em qualquer servidor integrado.</p>
<div class="paragraph">
<p>Como estamos em um ambiente de laboratório, não iremos utilizar senhas para as chaves privadas de modo a agilizar a execução das atividades.</p>
</div>
<div class="paragraph">
<p>Para criar a chave de assinatura de <em>hosts</em>, <code>server_ca</code>, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh-keygen -f server_ca -t rsa -b 4096 -N ''
Generating public/private rsa key pair.
Your identification has been saved in server_ca.
Your public key has been saved in server_ca.pub.
The key fingerprint is:
SHA256:op2g5J5DN/1pPy8RUHxnAdh51NHP/2Pmyo3Vq5Qlvjo sshca@ns2
The key's randomart image is:
+---[RSA 4096]----+
|         o.o.+o+o|
|        . o + + o|
|         . . + ..|
|          .     o|
|  . ... S  . . ..|
| o..o+.o  . . + o|
| .o...o. . . + .o|
| ...    + oEo =+o|
|  o.   . ..=+**+.|
+----[SHA256]-----+</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que o par de chaves foi criado com sucesso:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls
server_ca  server_ca.pub</pre>
</div>
</div>
<div class="paragraph">
<p>Para criar a chave de assinatura de usuários, <code>user_ca</code>, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh-keygen -f user_ca -t rsa -b 4096 -N ''
Generating public/private rsa key pair.
Your identification has been saved in user_ca.
Your public key has been saved in user_ca.pub.
The key fingerprint is:
SHA256:T6dFFMQiJnbGCLg0rj1tzaT4mfqagBn80YQaBGuWpuM sshca@ns2
The key's randomart image is:
+---[RSA 4096]----+
|o. ... o   o+.   |
|..= . + * ...    |
|.O + o = . ..    |
|* = o .    .     |
|+= + *  S . o    |
|++= = o  o +     |
|+E = o    o      |
| . .+            |
|  ++.            |
+----[SHA256]-----+</pre>
</div>
</div>
<div class="paragraph">
<p>Cheque que todos os quatro arquivos de chaves pública/privada foram criados:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls
server_ca  server_ca.pub  user_ca  user_ca.pub</pre>
</div>
</div>
</li>
<li>
<p>Dada a grande sensibilidade das chaves privadas das CAs nesse sistema de autenticação que estamos configurando, é fundamental garantir também que, além de terem uma senha forte configurada, suas permissões estejam corretamente ajustadas.</p>
<div class="paragraph">
<p>Verifique as permissões das chaves usando o comando <code>ls</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls -l *_ca*
-rw------- 1 sshca setup 1766 out 28 08:39 server_ca
-rw-r--r-- 1 sshca setup  392 out 28 08:39 server_ca.pub
-rw------- 1 sshca setup 1766 out 28 08:40 user_ca
-rw-r--r-- 1 sshca setup  392 out 28 08:40 user_ca.pub</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_8_configurando_a_ssh_ca_no_servidor_ldap">8) Configurando a SSH-CA no servidor LDAP</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos configurar o servidor LDAP para interoperar com a CA <code>ssh</code> que configuramos na atividade anterior. Volte ao usuário <code>root</code> na máquina <code>ns2</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="paragraph">
<p>Crie um novo arquivo, <code>/root/scripts/sshsign.sh</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

CA_USER="sshca"
CA_ADDR="10.0.42.2"
CA_USER_PASS="seg10sshca"
SSH_OPTS="-o PreferredAuthentications=password -o PubkeyAuthentication=no"


function cleanup() {
  sed -i '/^HostCertificate/d' /etc/ssh/sshd_config
  sed -i '/^TrustedUserCAKeys/d' /etc/ssh/sshd_config

  rm -f ~/.ssh/known_hosts       \
    /etc/ssh/ssh_host_*      \
    /etc/ssh/ssh_known_hosts \
    /etc/ssh/user_ca.pub 2&gt; /dev/null
  dpkg-reconfigure openssh-server &amp;&gt; /dev/null

  systemctl restart sshd.service
}


# resetar sistema para estado conhecido
cleanup

# escanear chave do host ssh-ca
[ -d ~/.ssh ] || { mkdir ~/.ssh; chmod 700 ~/.ssh; }
if ! ssh-keygen -F ${CA_ADDR} 2&gt;/dev/null 1&gt;/dev/null; then
  ssh-keyscan -t rsa -T 10 ${CA_ADDR} 2&gt; /dev/null &gt;&gt; ~/.ssh/known_hosts
fi

# iterar em todas as pubkeys SSH
for pkeypath in /etc/ssh/ssh_host_*.pub; do
  pkeyname="$( echo "${pkeypath}" | awk -F'/' '{print $NF}' )"
  certname="$( echo "${pkeyname}" | sed 's/\(\.pub$\)/-cert\1 /' )"
  echo "Signing ${pkeyname} key..."

  # copiar pubkey
  sshpass -p "${CA_USER_PASS}" \
    scp ${SSH_OPTS} ${pkeypath} ${CA_USER}@${CA_ADDR}:~

  # assinar pubkey, validade [-5 min -&gt; 3 anos]
  identity="$(hostname --fqdn)"
  principals="$(hostname),$(hostname --fqdn),$(hostname -I | tr ' ' ',' | sed 's/,$//')"
  sshpass -p "${CA_USER_PASS}" \
    ssh ${SSH_OPTS} ${CA_USER}@${CA_ADDR} \
      ssh-keygen -s server_ca \
      -I "${identity}" \
      -n "${principals}" \
      -V -5m:+1095d \
      -h \
      ${pkeyname} 2&gt; /dev/null

  # copiar pubkey assinada de volta
  sshpass -p "${CA_USER_PASS}" \
    scp ${SSH_OPTS} ${CA_USER}@${CA_ADDR}:${certname} /etc/ssh/

  # remover temporarios do diretorio remoto
  sshpass -p "${CA_USER_PASS}" \
    ssh ${SSH_OPTS} ${CA_USER}@${CA_ADDR} \
      rm ${pkeyname} ${certname}

  # remover pubkey RSA antiga e configurar ssh para apresentar pubkey assinada
  rm -f ${pkeypath} 2&gt; /dev/null
  echo "HostCertificate /etc/ssh/${certname}" &gt;&gt; /etc/ssh/sshd_config
done

# copiar pubkey da server_ca e configurar reconhecimento de chaves de host assinadas
echo "Configuring host key trust..."
echo "@cert-authority * $(sshpass -p "${CA_USER_PASS}" ssh ${SSH_OPTS} ${CA_USER}@${CA_ADDR} cat server_ca.pub)" &gt; /etc/ssh/ssh_known_hosts

# copiar pubkey da user_ca e configurar reconhecimento de chaves de usuario assinadas
echo "Configuring user key trust..."
sshpass -p "${CA_USER_PASS}" \
  scp ${SSH_OPTS} ${CA_USER}@${CA_ADDR}:~/user_ca.pub /etc/ssh/
echo "TrustedUserCAKeys /etc/ssh/user_ca.pub" &gt;&gt; /etc/ssh/sshd_config

echo "All done!"
systemctl restart sshd.service</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você deve estar se perguntando: o que esse <em>script</em> faz? Vamos ver:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>(Linhas 3-6) Definimos o usuário <code>sshca</code> e o IP <code>10.0.42.2</code> (o servidor <code>ns2</code> local no qual estamos logados no momento) como a origem das chaves da CA que utilizaremos a seguir. Configuramos a senha do usuário <code>sshca</code> de forma <em>hardcoded</em> para agilizar o processo de execução do <em>script</em> e informamos que os logins SSH serão feitos sempre via senha, não chaves assimétricas.</p>
</li>
<li>
<p>(Linhas 9-20) Função que reseta a situação do SSH no servidor para um estado conhecido, em caso de falha ou encerramento abrupto do usuário durante a execução do <em>script</em>.</p>
</li>
<li>
<p>(Linhas 27-30) Escaneamos a chave do servidor <code>10.0.42.2</code> e armazenamos no arquivo <code>~/.ssh/known_hosts</code>, evitando que o usuário tenha que confirmar que confia no <em>host</em> remoto antes de logar.</p>
</li>
<li>
<p>(Linhas 33-35) Iteramos sobre todas as chaves públicas no diretório <code>/etc/ssh</code> (RSA, ECDSA e ED25519), extraindo <em>strings</em> para usar à frente.</p>
</li>
<li>
<p>(Linhas 39-40) Copiamos a chave pública do <em>host</em> sendo processadao pelo <em>loop</em> para o servidor da CA.</p>
</li>
<li>
<p>(Linhas 43-52) Assinamos a chave pública do <em>host</em> sendo processadao pelo <em>loop</em> usando a chave <code>server_ca</code>, com validade de 3 anos.</p>
</li>
<li>
<p>(Linhas 55-56) Copiamos a chave pública assinada sendo processadao pelo <em>loop</em> de volta para a máquina local.</p>
</li>
<li>
<p>(Linhas 59-61) Removemos chaves pública não-assinada e assinada sendo processadao pelo <em>loop</em> da pasta do usuário <code>sshca</code> no servidor <code>10.0.42.2</code>, para evitar confusão em assinaturas futuras.</p>
</li>
<li>
<p>(Linhas 64-65) Removemos a chave pública sendo processadao pelo <em>loop</em> não-assinada e mantemos apenas a assinada, configurando o servidor <code>ssh</code> para apresentá-la para clientes.</p>
</li>
<li>
<p>(Linha 70) Configuramos a chave <code>server_ca.pub</code> como uma CA confiável para <em>hosts</em> remotos; a partir deste momento, quaisquer logins de cliente <code>ssh</code> da máquina local para <em>hosts</em> assinados não terão que confirmar relação de confiança antes de prosseguir.</p>
</li>
<li>
<p>(Linhas 74-76) Copiamos a chave <code>user_ca.pub</code> e a configuramos como uma CA confiável para usuários; a partir deste momento, qualquer usuário que apresente uma chave assinada pela CA terá seu login autorizado sem necessitar digitação de senha.</p>
</li>
<li>
<p>(Linha 79) Reiniciamos o servidor <code>ssh</code> para aplicar as configurações realizadas.</p>
</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<p>Vamos instalar o <code>sshpass</code>, dependência para que o <em>script</em> acima funcione corretamente.</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install sshpass</pre>
</div>
</div>
</li>
<li>
<p>Vamos configurar a máquina <code>ns2</code> para operar com a CA do <code>ssh</code>: execute o <em>script</em> criado no passo (1).</p>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/sshsign.sh
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
<div class="paragraph">
<p>Note que não foi necessário passar quaisquer parâmetros de linha de comando para o <em>script</em>. Ele autodetecta o <em>hostname</em> e endereços da máquina local e os configura como <em>principals</em> (conjunto de endereços/<em>hostnames</em> válidos para uma determinada chave; linha 44 do <em>script</em>).</p>
</div>
</li>
<li>
<p>Vamos verificar que o <em>script</em> fez seu trabalho corretamente. Cheque as linhas finais do arquivo <code>/etc/ssh/sshd_config</code>:</p>
<div class="literalblock">
<div class="content">
<pre># tail -n4 /etc/ssh/sshd_config
HostCertificate /etc/ssh/ssh_host_ecdsa_key-cert.pub
HostCertificate /etc/ssh/ssh_host_ed25519_key-cert.pub
HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub
TrustedUserCAKeys /etc/ssh/user_ca.pub</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que apenas chaves públicas assinadas existem no diretório <code>/etc/ssh</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -1 /etc/ssh/ssh_host_*.pub
/etc/ssh/ssh_host_ecdsa_key-cert.pub
/etc/ssh/ssh_host_ed25519_key-cert.pub
/etc/ssh/ssh_host_rsa_key-cert.pub</pre>
</div>
</div>
<div class="paragraph">
<p>Compare o conteúdo dos arquivos de chave pública <code>/home/sshca/server_ca.pub</code> e de chave da CA confiável <code>/etc/ssh/ssh_known_hosts</code>&#8201;&#8212;&#8201;eles devem ser iguais:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/ssh/ssh_known_hosts
@cert-authority * ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC+ZP47AOiRPcakZiLm+szvxWF5HKNa+BauaYXt5A6XjuUUJIYXXdTdzrq+d4rx379jxk5E+RHvPls1Y+5Cvn2/EpBgx20TXoT9+O0Nn7pemHd7qkDb2JqPzoHzjViG033L8UociItit13UVMlvB2+miW4RPMHhLjJpJT2BoWzvkBtJdukO/SA+3EYpIZAj8kyFfkp9+2A/A+OCREWoh5EkcjREAQRay+pc/j3sWDYrymu65OamPwGAe3Ih9/TmflUiwdHaNfJMY0BqpJsdFyUJeS36asjRhLtZltfLNTyY1gOq3XglLZb76YaQWOoIhzwqQ2WNSt72cY7s8p97loX5LTBSjNw6Kq0rOpKY3XmkyP2A5+L+CFxRxpl0obOkqiZqK/oT4cFE72EBaSg0XfFej19rd/AqqFSEHpbK4GjZzBAEID932DrgcR6ud74k1TDemQgWZ5dge0wEKMfeNVzUXhAPuxeIyQ6E+DxuayHIrUKZ7T36ZVz5N56TXnr+iaaejqpJfuSKZxC8YT9ZmRiHeZ+edze+R6QPiV76QUIQqzocO+OlWPHUZ2zVINV76DZARqxzZuKWW7JzA1+kTJ3VW3zGaOs53n36lfThb39ULHplsJUPfUGiun8cK7onzIbkRibbVu/kmrNG8nr2Z4GHMGpQ6KvYyGZNFIwioGMu6Q== sshca@ns2</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /home/sshca/server_ca.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC+ZP47AOiRPcakZiLm+szvxWF5HKNa+BauaYXt5A6XjuUUJIYXXdTdzrq+d4rx379jxk5E+RHvPls1Y+5Cvn2/EpBgx20TXoT9+O0Nn7pemHd7qkDb2JqPzoHzjViG033L8UociItit13UVMlvB2+miW4RPMHhLjJpJT2BoWzvkBtJdukO/SA+3EYpIZAj8kyFfkp9+2A/A+OCREWoh5EkcjREAQRay+pc/j3sWDYrymu65OamPwGAe3Ih9/TmflUiwdHaNfJMY0BqpJsdFyUJeS36asjRhLtZltfLNTyY1gOq3XglLZb76YaQWOoIhzwqQ2WNSt72cY7s8p97loX5LTBSjNw6Kq0rOpKY3XmkyP2A5+L+CFxRxpl0obOkqiZqK/oT4cFE72EBaSg0XfFej19rd/AqqFSEHpbK4GjZzBAEID932DrgcR6ud74k1TDemQgWZ5dge0wEKMfeNVzUXhAPuxeIyQ6E+DxuayHIrUKZ7T36ZVz5N56TXnr+iaaejqpJfuSKZxC8YT9ZmRiHeZ+edze+R6QPiV76QUIQqzocO+OlWPHUZ2zVINV76DZARqxzZuKWW7JzA1+kTJ3VW3zGaOs53n36lfThb39ULHplsJUPfUGiun8cK7onzIbkRibbVu/kmrNG8nr2Z4GHMGpQ6KvYyGZNFIwioGMu6Q== sshca@ns2</pre>
</div>
</div>
<div class="paragraph">
<p>Observer, finalmente, que os arquivos <code>/home/sshca/user_ca.pub</code> e <code>/etc/ssh/user_ca.pub</code> também devem ser idênticos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># diff /home/sshca/user_ca.pub /etc/ssh/user_ca.pub</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note que tanto no caso de assinatura de chaves de <em>host</em> como de chaves de usuário, futuramente, estamos fazendo o acesso no sentido <strong>máquina remota</strong> &#8594; <strong>servidor da CA</strong>, que não é o ideal. Em produção, o correto seria tornar o acesso ao servidor da CA o mais controlado possível, e fazer as assinaturas de chaves apenas de forma local, ou com acessos no sentido <strong>servidor da CA</strong> &#8594; <strong>máquina remota</strong>.</p>
</div>
<div class="paragraph">
<p>Outro aspecto relevante de segurança que sacrificamos em nosso cenário para agilizar a execução das atividades foi a configuração das chaves privadas de assinatura de <em>hosts</em> e usuários sem senha: em produção, é altamente recomendado que essas chaves sejam criadas com senhas fortes, para mitigar a possibilidade de assinatura indevida de chaves em caso de vazamento das mesmas.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_9_automatizando_a_assinatura_de_chaves_ssh_de_usuários">9) Automatizando a assinatura de chaves SSH de usuários</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos agora fazer a segunda "perna" da configuração da CA <code>ssh</code>&#8201;&#8212;&#8201;assinar chaves de usuários. Na linha da atividade anterior, iremos usar um <em>script</em> para assinar chaves de usuários; porém, como o cenário de chaves de usuário é mais flexível que o de máquinas, iremos estabelecer algumas premissas para o funcionamento do <em>script</em>:</p>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Deve-se estar logado com o mesmo nome do usuário com o qual se deseja assinar a chave.</p>
</li>
<li>
<p>Deve-se ter conectividade com o servidor <code>ns2</code>, no endereço <code>10.0.42.2</code>.</p>
</li>
<li>
<p>O nome de chave será fixo (<code>~/.ssh/id_rsa</code>).</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Devido à primeira limitação, é conveniente que o <em>script</em> esteja localizado dentro da pasta do usuário&#8201;&#8212;&#8201;e, como se sabe, ao criar novos usuários o conteúdo da pasta <code>/etc/skel</code> é copiado para dentro de seu <em>home</em>. Assim, crie a pasta <code>/etc/skel/scripts</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkdir /etc/skel/scripts</pre>
</div>
</div>
<div class="paragraph">
<p>Dentro dela, crie o arquivo novo, <code>/etc/skel/scripts/sshsign_user.sh</code>, com o conteúdo que se segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

CA_USER="sshca"
CA_ADDR="10.0.42.2"
CA_USER_PASS="seg10sshca"
SSH_OPTS="-o PreferredAuthentications=password -o PubkeyAuthentication=no"

# testar se chave ja foi assinada
if [ -f ~/.ssh/id_rsa-cert.pub ]; then
  echo "Key already signed, bailing."
  exit 1
fi

# escanear chave do host ssh-ca, se necessario
rm -f ~/.ssh/known_hosts 2&gt; /dev/null
[ -d ~/.ssh ] || { mkdir ~/.ssh; chmod 700 ~/.ssh; }
if ! ssh-keygen -F ${CA_ADDR} 2&gt;/dev/null 1&gt;/dev/null; then
  ssh-keyscan -t rsa -T 10 ${CA_ADDR} 2&gt; /dev/null &gt;&gt; ~/.ssh/known_hosts
fi

# gerar par de chaves RSA, se inexistentes
[ -f ~/.ssh/id_rsa.pub ] || ssh-keygen -f ~/.ssh/id_rsa -t rsa -b 4096 -N '' &amp;&gt; /dev/null

# copiar pubkey RSA
sshpass -p "${CA_USER_PASS}" \
  scp ${SSH_OPTS} ~/.ssh/id_rsa.pub ${CA_USER}@${CA_ADDR}:~

# assinar pubkey RSA, validade [-5 min -&gt; 1 ano]
echo "Signing ~/.ssh/id_rsa.pub key..."
user="$( whoami )"
sshpass -p "${CA_USER_PASS}" \
  ssh ${SSH_OPTS} ${CA_USER}@${CA_ADDR} \
    ssh-keygen -s user_ca \
    -I ${user} \
    -n ${user} \
    -V -5m:+1095d \
    id_rsa.pub 2&gt; /dev/null

# copiar pubkey assinada de volta
sshpass -p "${CA_USER_PASS}" \
  scp ${SSH_OPTS} ${CA_USER}@${CA_ADDR}:~/id_rsa-cert.pub ~/.ssh/

# remover temporarios do diretorio remoto
sshpass -p "${CA_USER_PASS}" \
  ssh ${SSH_OPTS} ${CA_USER}@${CA_ADDR} \
    rm id_rsa.pub id_rsa-cert.pub

# copiar pubkey da server_ca e configurar reconhecimento de chaves de host assinadas
echo "@cert-authority * $(sshpass -p "${CA_USER_PASS}" ssh ${SSH_OPTS} ${CA_USER}@${CA_ADDR} cat server_ca.pub)" &gt; ~/.ssh/known_hosts

# remover pubkey RSA antiga
rm -f ~/.ssh/id_rsa.pub 2&gt; /dev/null

echo "All done!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como o <em>script</em> guarda grandes semelhanças com o anterior, iremos destacar apenas os pontos de divergência:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>(Linhas 9-12) Testamos se a chave RSA do usuário já foi assinada anteriormente; se positivo, o programa se encerra.</p>
</li>
<li>
<p>(Linha 22) Caso o usuário não possua um par de chaves criado, cria-se automaticamente um par RSA de 4096 bits, sem senha.</p>
</li>
<li>
<p>(Linhas 30-37) A chave usada para assinar a chave pública do usuário desta vez é a <code>user_ca</code>. A validade é ajustada para um ano.</p>
</li>
<li>
<p>(Linha 49) De forma similar ao que foi feito anteriormente, copia-se a chave <code>server_ca.pub</code> como uma CA confiável para <em>hosts</em> remotos; a partir deste momento, logins de cliente <code>ssh</code> deste usuário para <em>hosts</em> assinados não terão que confirmar relação de confiança antes de prosseguir.</p>
</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<p>Vamos testar o funcionamento do <em>script</em> com o usuário <code>luke</code>. Remova o diretório dele para garantir que o conteúdo do <code>/etc/skel</code> será copiado no próximo login:</p>
<div class="literalblock">
<div class="content">
<pre># rm -rf /home/luke</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, logue como o usuário <code>luke</code> usando os comandos <code>su</code> ou <code>ssh</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami ; pwd
luke
/home/luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls ~/scripts
sshsign_user.sh</pre>
</div>
</div>
</li>
<li>
<p>Execute o <em>script</em>:</p>
<div class="literalblock">
<div class="content">
<pre>$ bash ~/scripts/sshsign_user.sh
Signing ~/.ssh/id_rsa.pub key...
All done!</pre>
</div>
</div>
<div class="paragraph">
<p>Note que, novamente, não foi necessário passar quaisquer parâmetros de linha de comando para o <em>script</em>. Ele utiliza o <em>username</em> do usuário informado pelo comando <code>whoami</code> como <em>principal</em> da chave.</p>
</div>
</li>
<li>
<p>Vamos verificar o funcionamento do <em>script</em>. Verifique que os arquivos de chave foram criados:</p>
<div class="literalblock">
<div class="content">
<pre>$ ls ~/.ssh/
id_rsa  id_rsa-cert.pub  known_hosts</pre>
</div>
</div>
<div class="paragraph">
<p>Cheque o conteúdo do arquivo <code>~/.ssh/known_hosts</code>, que deve conter informações da CA <code>ssh</code> para chaves de <em>host</em> assinadas:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/.ssh/known_hosts
@cert-authority * ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC+ZP47AOiRPcakZiLm+szvxWF5HKNa+BauaYXt5A6XjuUUJIYXXdTdzrq+d4rx379jxk5E+RHvPls1Y+5Cvn2/EpBgx20TXoT9+O0Nn7pemHd7qkDb2JqPzoHzjViG033L8UociItit13UVMlvB2+miW4RPMHhLjJpJT2BoWzvkBtJdukO/SA+3EYpIZAj8kyFfkp9+2A/A+OCREWoh5EkcjREAQRay+pc/j3sWDYrymu65OamPwGAe3Ih9/TmflUiwdHaNfJMY0BqpJsdFyUJeS36asjRhLtZltfLNTyY1gOq3XglLZb76YaQWOoIhzwqQ2WNSt72cY7s8p97loX5LTBSjNw6Kq0rOpKY3XmkyP2A5+L+CFxRxpl0obOkqiZqK/oT4cFE72EBaSg0XfFej19rd/AqqFSEHpbK4GjZzBAEID932DrgcR6ud74k1TDemQgWZ5dge0wEKMfeNVzUXhAPuxeIyQ6E+DxuayHIrUKZ7T36ZVz5N56TXnr+iaaejqpJfuSKZxC8YT9ZmRiHeZ+edze+R6QPiV76QUIQqzocO+OlWPHUZ2zVINV76DZARqxzZuKWW7JzA1+kTJ3VW3zGaOs53n36lfThb39ULHplsJUPfUGiunhistory8cK7onzIbkRibbVu/kmrNG8nr2Z4GHMGpQ6KvYyGZNFIwioGMu6Q== sshca@ns2</pre>
</div>
</div>
</li>
<li>
<p>Agora sim, vamos testar. Tente logar na máquina local usando o endereço IP ou <em>hostname</em> (o endereço especial <em>localhost</em> não é registrado como um <em>principal</em> válido na chave de <em>host</em>).</p>
<div class="literalblock">
<div class="content">
<pre>$ ssh luke@ns2
Linux ns2 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

Last login: Tue Nov 13 18:40:31 2018 from ::1
luke@ns2:~$</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito! Não tivemos que digitar a senha do usuário ou confirmar a relação de confiança com o servidor, como esperado.</p>
</div>
</li>
<li>
<p>Todos as características do sistema que queríamos testar estão funcionais. Claro que devemos levar em consideração que todos os testes foram feitos dentro da máquina <code>ns2</code>&#8201;&#8212;&#8201;não testamos o funcionamento de contas de usuário via LDAP na rede, ou a autenticação de login remoto usando a CA do <code>ssh</code>.</p>
<div class="paragraph">
<p>Retorne ao usuário <code>root</code> na máquina <code>ns2</code> e remova o diretório do usuário <code>luke</code>. Vamos prosseguir com a configuração do <em>template</em> e de um cliente Linux para testar as funcionalidades.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># rm -rf /home/luke</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_10_configurando_o_template_para_funcionar_com_ldapssh_ca">10) Configurando o template para funcionar com LDAP/SSH-CA</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Como mencionado anteriormente, iremos configurar a VM <code>debian-template</code> para funcionar com os sistemas de autenticação do LDAP e SSH-CA. Assim, todas as máquinas que forem derivadas futuramente desse <em>template</em> estarão automaticamente integradas com o sistema de autenticação do nosso <em>datacenter</em> hipotético.</p>
<div class="paragraph">
<p>Ligue a VM <code>debian-template</code> e faça login como o usuário <code>root</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
</li>
<li>
<p>Crie o arquivo novo <code>/root/scripts/sshsign.sh</code>, e cole dentro dele o conteúdo do <em>script</em> que discutimos no passo (1) da atividade (8).</p>
<div class="literalblock">
<div class="content">
<pre># nano /root/scripts/sshsign.sh
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls /root/scripts/
changehost.sh  sshsign.sh  syncdirs.sh</pre>
</div>
</div>
</li>
<li>
<p>Agora, crie o diretório <code>/etc/skel/scripts</code>, e dentro dele crie o arquivo novo <code>/etc/skel/scripts/sshsign_user.sh</code>, com conteúdo idêntico ao do <em>script</em> que foi apresentado no passo (1) da atividade (9).</p>
<div class="literalblock">
<div class="content">
<pre># mkdir /etc/skel/scripts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/skel/scripts/sshsign_user.sh
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls /etc/skel/scripts/
sshsign_user.sh</pre>
</div>
</div>
</li>
<li>
<p>Instale as dependências para funcionamento dos <em>scripts</em> criados anteriormente e também para integração do sistema de autenticação PAM com o LDAP.</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install sshpass nslcd</pre>
</div>
</div>
<div class="paragraph">
<p>Durante a instalação do pacote <code>nslcd</code>, informe as seguintes opções:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Configurações do pacote nslcd</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pergunta</th>
<th class="tableblock halign-left valign-top">Opção</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">URI do servidor LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ldap://ldap.intnet/</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Base de buscas do servidor LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dc=intnet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Serviços de nome para configurar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">passwd, group, shadow</p></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Assim como configurado antes, informe ao PAM que diretórios <em>home</em> inexistentes de usuários do LDAP devem ser criados automaticamente. Crie o arquivo novo <code>/usr/share/pam-configs/mkhomedir</code>, e cole dentro dele o conteúdo do arquivo discutido durante o passo (1) da atividade (6).</p>
<div class="literalblock">
<div class="content">
<pre># nano /usr/share/pam-configs/mkhomedir
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># pam-auth-update</pre>
</div>
</div>
<div class="paragraph">
<p>Durante a configuração do PAM, na pergunta "Perfis PAM para habilitar", mantenha todas as caixas marcadas e selecione OK.</p>
</div>
</li>
<li>
<p>Finalmente, vamos alterar o <em>script</em> <code>/root/scripts/changehost.sh</code>, criado durante a sessão (1) deste curso, para invocar automaticamente o <em>script</em> <code>/root/scripts/sshsign.sh</code> ao final e reiniciar os <em>daemons</em> do <code>nslcd</code> e <code>nscd</code>. Altere o conteúdo deste arquivo para:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash


# exibir uso do script e sair
function usage() {
  echo "  Usage: $0 -h HOSTNAME -i IPADDR -g GATEWAY"
  echo "  Netmask is assumed as /24."
  exit 1
}


# testar sintaxe valida de HOSTNAME
function valid_host() {
  if [[ "$nhost" =~ [^a-z0-9-] ]]; then
    echo "  [*] HOSTNAME must be lowercase alphanumeric: [a-z0-9]*"
    usage
  elif [ ${#nhost} -gt 63 ]; then
    echo "  [*] HOSTNAME must have &lt;63 chars"
    usage
  fi
}


# testar sintaxe valida de IPADDR/GATEWAY
function valid_ip() {
  local  ip=$1
  local  stat=1

  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    OIFS=$IFS
    IFS='.'
    ip=($ip)
    IFS=$OIFS
    [[ ${ip[0]} -le 255 &amp;&amp; \
       ${ip[1]} -le 255 &amp;&amp; \
       ${ip[2]} -le 255 &amp;&amp; \
       ${ip[3]} -le 255 ]]
        stat=$?
  fi

  if [ $stat -ne 0 ] ; then
    echo "  [*] Invalid syntax for $2"
    usage
  fi
}


while getopts ":g:h:i:" opt; do
  case "$opt" in
    g)
      ngw=${OPTARG}
      ;;
    h)
      nhost=${OPTARG}
      ;;
    i)
      nip=${OPTARG}
      ;;
    *)
      usage
      ;;
  esac
done

# testar se parametros foram informados
[ -z $ngw ]   &amp;&amp; { echo "  [*] No gateway?"; usage; }
[ -z $nhost ] &amp;&amp; { echo "  [*] No hostname?"; usage; }
[ -z $nip ]   &amp;&amp; { echo "  [*] No ipaddr?"; usage; }

# testar sintaxe de parametros
valid_ip $nip "IPADDR"
valid_ip $ngw "GATEWAY"
valid_host $nhost

# alterar endereco ip/gateway
iff="/etc/network/interfaces"
cip="$( egrep '^address ' $iff | awk -F'[ /]' '{print $2}' )"
cgw="$( egrep '^gateway ' $iff | awk '{print $NF}' )"
sed -i "s|${cip}|${nip}|g" $iff
sed -i "s|${cgw}|${ngw}|g" $iff
ip addr flush label 'enp0s*'

# alterar hostname local
chost="$( hostname -s )"
sed -i "s/${chost}/${nhost}/g" /etc/hosts
sed -i "s/${chost}/${nhost}/g" /etc/hostname

invoke-rc.d hostname.sh restart
invoke-rc.d networking restart
hostnamectl set-hostname $nhost

# assinar chaves SSH
bash /root/scripts/sshsign.sh

# reiniciar sistema de autenticacao LDAP
systemctl restart nslcd.service
systemctl restart nscd.service

for table in `ls -1 /var/cache/nscd` ; do
  nscd --invalidate $table
done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ao invocar este <em>script</em> após a criação de uma nova VM, iremos não apenas alterar seu endereço IP, <em>gateway</em> e <em>hostname</em> mas também integrá-la com o sistema de autenticação remota do LDAP e SSH-CA em um único comando, como veremos a seguir.</p>
</div>
<div class="paragraph">
<p>Findo este passo, desligue a máquina <code>debian-template</code>.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_11_ajuste_das_regras_de_firewall">11) Ajuste das regras de firewall</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Observando os acessos feitos pelo <em>script</em> em <code>/root/scripts/sshsign.sh</code>, note que a máquina efetuando as assinaturas de chave necessita conseguir alcançar a máquina <code>ns2</code> pela rede, e logar via SSH com o usuário <code>sshca</code>. Mais além, as autenticações via rede são feitas junto ao servidor OpenLDAP, operando com o <em>daemon</em> <code>slapd</code>. Nenhum desses requisitos foi previsto em nossas regras de firewall originais, então temos que ajustá-las para permitir que máquinas da DMZ e Intranet consigam realizar esses acessos.</p>
<div class="paragraph">
<p>Vamos listar os requerimentos de regras:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Máquinas na DMZ devem conseguir acessar a máquina <code>ns2</code> nas portas 22/TCP (SSH) e 389/TCP (LDAP). Como essas máquinas estão todas na mesma sub-rede, os acessos não passam pelo firewall e nenhuma configuração adicional se faz necessária.</p>
</li>
<li>
<p>Máquinas na Intranet devem conseguir acessar a máquina <code>ns2</code> nas portas 22/TCP (SSH) e 389/TCP (LDAP). Como esse tráfego passa <strong>através do</strong> firewall, devemos inserir regras na <em>chain</em> FORWARD.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Logue como <code>root</code> na máquina <code>ns1</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Basta criar uma regra para atender o requisito (b), como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 192.168.42.0/24 -d 10.0.42.2/32 -p tcp -m multiport --dports 22,389 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Salve as regras na configuração do firewall local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent save
[....] Saving netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save
done.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_12_configurando_um_cliente_linux">12) Configurando um cliente Linux</h3>
<div class="paragraph">
<p>Nesta atividade iremos criar uma máquina cliente Linux para utilizarmos como ponto de partida para os logins <code>ssh</code> nos diferentes servidores que configuraremos durante este curso. O nome da máquina será <code>client</code>, alocada para a Intranet com o endereço IP 192.168.42.2/24. Iremos integrá-la com os sistemas de autenticação do LDAP e SSH-CA, e testar login remoto na máquina <code>ns2</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Clone a máquina <code>debian-template</code> seguindo os mesmos passos da atividade (6) da sessão 1. Para o nome da máquina, escolha <code>client</code>.</p>
</li>
<li>
<p>Após a clonagem, na janela principal do Virtualbox, clique com o botão direito sobre a VM <code>client</code> e depois em <em>Settings</em>.</p>
<div class="paragraph">
<p>Em <em>Network</em> &gt; <em>Adapter 1</em> &gt; <em>Attached to</em> &gt; <em>Host-only Adapter</em>, altere o nome da rede <em>host-only</em> para o mesmo da interface da VM <code>ns1</code> que está alocada à Intranet. Seguindo o exemplo mostrado no início da sessão 2, a rede escolhida seria a <code>Virtualbox Host-Only Ethernet Adapter #3</code>.</p>
</div>
<div class="paragraph">
<p>Clique em <em>OK</em>, e ligue a máquina <code>client</code>.</p>
</div>
</li>
<li>
<p>Logue como o usuário <code>root</code>&#8201;&#8212;&#8201;o primeiro login poderá demorar um pouco até que a tentativa de autenticação via rede no servidor LDAP, neste momento inatingível, incorra em <em>timeout</em>. Feito o login, use o script <code>/root/scripts/changehost.sh</code> para configurar a máquina de forma automática:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h client -i 192.168.42.2 -g 192.168.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname
client</pre>
</div>
</div>
</li>
<li>
<p>Se tudo tiver funcionado corretamente, a máquina <code>client</code> já estará integrada aos sistemas de autenticação LDAP e SSH-CA. Faça login como o usuário <code>luke</code> usando os comandos <code>su</code> ou <code>ssh</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami ; pwd
client
luke
/home/luke</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar um par de chaves para esse usuário e assiná-las. Como o conteúdo do diretório <em>home</em> foi copiado diretamente do <code>/etc/skel</code>, temos à disposição o <em>script</em> para essa tarefa na pasta <code>~/scripts/sshsign_user.sh</code>. Execute-o:</p>
<div class="literalblock">
<div class="content">
<pre>$ bash ~/scripts/sshsign_user.sh
Signing ~/.ssh/id_rsa.pub key...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar? Tente logar usando o usuário <code>luke</code> na máquina <code>ns2</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ ssh luke@ns2
Creating directory '/home/luke'.
Linux ns2 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

Last login: Tue Nov 13 21:05:01 2018 from 127.0.0.1
luke@ns2:~$</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami ; pwd
ns2
luke
/home/luke</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente! Conseguimos logar sem ter que confirmar a relação de confiança com o servidor e sem digitar senha, como esperado.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_13_configurando_o_firewall_para_funcionar_com_ldapssh_ca">13) Configurando o firewall para funcionar com LDAP/SSH-CA</h3>
<div class="paragraph">
<p>Suponha, agora, que queremos integrar o firewall no sistema de autenticação LDAP/SSH-CA, mas com um maior nível de restrição. Sendo uma máquina crítica, não podemos permitir que qualquer usuário faça login nessa máquina, sendo necessário implementar controles mais estritos.</p>
</div>
<div class="paragraph">
<p>O primeiro passo, naturalmente, é fazer a integração com os sistemas de autenticação. Vamos fazer isso:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Logue como usuário <code>root</code> na máquina <code>ns1</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
</li>
<li>
<p>Instale as dependências para funcionamento dos <em>scripts</em> e integração do sistema de autenticação.</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install sshpass nslcd</pre>
</div>
</div>
<div class="paragraph">
<p>Novamente, durante a instalação do pacote <code>nslcd</code>, informe as seguintes opções:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Configurações do pacote nslcd</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pergunta</th>
<th class="tableblock halign-left valign-top">Opção</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">URI do servidor LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ldap://ldap.intnet/</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Base de buscas do servidor LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dc=intnet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Serviços de nome para configurar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">passwd, group, shadow</p></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Configure a criação automática de diretórios, com o arquivo novo <code>/usr/share/pam-configs/mkhomedir</code>. Para maior conveniência, você pode copiar o arquivo diretamente da máquina <code>ns2</code> para o local apropriado usando o comando <code>scp</code>, como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># scp -o StrictHostKeyChecking=no aluno@ns2:/usr/share/pam-configs/mkhomedir /usr/share/pam-configs/
Warning: Permanently added 'ns2,10.0.42.2' (ECDSA) to the list of known hosts.
aluno@ns2's password:
mkhomedir                                                                          100%  170   449.4KB/s   00:00</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># pam-auth-update</pre>
</div>
</div>
<div class="paragraph">
<p>Durante a configuração do PAM, na pergunta "Perfis PAM para habilitar", mantenha todas as caixas marcadas e selecione OK.</p>
</div>
</li>
<li>
<p>Crie o arquivo novo <code>/root/scripts/sshsign.sh</code> e cole o conteúdo do <em>script</em> de assinatura de chaves de <em>host</em> que utilizamos anteriormente:</p>
<div class="literalblock">
<div class="content">
<pre># nano /root/scripts/sshsign.sh
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls /root/scripts/
changehost.sh  signzone-intnet.sh  sshsign.sh  syncdirs.sh</pre>
</div>
</div>
<div class="paragraph">
<p>Execute-o:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/sshsign.sh
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_14_restringindo_login_por_grupos_e_usuários">14) Restringindo login por grupos e usuários</h3>
<div class="paragraph">
<p>Agora sim, com a integração concluída, imagine o seguinte cenário: não queremos que usuários do grupo <code>sysadm</code>, do qual faz parte o usuário <code>luke</code>, possam logar no firewall. Esse permissão será dada apenas a membros do grupo <code>fwadm</code>, que criaremos a seguir. Um desses usuários é o colaborador <code>han</code>, cuja senha será <code>seg10han</code>. Como configurar esse tipo de restrição?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, vamos criar o grupo e usuário. Logue na máquina <code>ns2</code> como usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
</li>
<li>
<p>Crie o grupo:</p>
<div class="literalblock">
<div class="content">
<pre># ldapaddgroup fwadm
Successfully added group fwadm to LDAP</pre>
</div>
</div>
<div class="paragraph">
<p>Usuário:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapadduser han fwadm
Successfully added user han to LDAP
Successfully set password for user han</pre>
</div>
</div>
<div class="paragraph">
<p>Adicione o usuário ao grupo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapaddusertogroup han fwadm
Successfully added user han to group cn=fwadm,ou=Groups,dc=intnet</pre>
</div>
</div>
<div class="paragraph">
<p>E, finalmente, configure a senha do usuário <code>han</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsetpasswd han
Changing password for user uid=han,ou=People,dc=intnet
New Password:
Retype New Password:
Successfully set password for user uid=han,ou=People,dc=intnet</pre>
</div>
</div>
</li>
<li>
<p>De volta ao firewall, como usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo <code>/etc/nslcd.conf</code>, configurando a opção <code>pam_authz_search</code>. Essa opção permite que sejam definidos filtros de busca para o <code>nslcd</code>, através dos quais podemos restringir que usuários e/ou grupos podem logar na máquina local. No caso, queremos que apenas membros do grupo <code>fwadm</code> possam logar, portanto adicionamos a seguinte linha ao final do arquivo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># echo 'pam_authz_search (&amp;(objectClass=posixGroup)(cn=fwadm)(memberUid=$username))' &gt;&gt; /etc/nslcd.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Podemos customizar o filtro acima para incluir apenas usuários específicos, ou mesmo DNs que possuam um atributo qualquer (por exemplo, e-mails com um determinado sufixo). Tome sempre cuidado para não filtrar todos os usuários disponíveis no LDAP acidentalmente&#8201;&#8212;&#8201;é importante, nesses casos, sempre manter uma conta local (como <code>aluno</code> ou <code>root</code>, no nosso caso específico) com acesso ao sistema.</p>
</div>
<div class="paragraph">
<p>Reinicie os serviços do <code>nslcd</code> e <code>nscd</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nslcd.service</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nscd.service</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que o usuário <code>han</code> é visto como membro do grupo <code>fwadm</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># groups han
han : fwadm</pre>
</div>
</div>
<div class="paragraph">
<p>Ocasionalmente, reiniciar o <code>nscd</code> não é suficiente para que ele detecte novas alterações na base de usuários/grupos do LDAP. Nesse caso, podemos invalidar as <em>caches</em> das tabelas do <code>nscd</code> com o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nscd --invalidate TABLE</pre>
</div>
</div>
<div class="paragraph">
<p>As tabelas disponíveis podem ser consultadas na página de manual do <code>nscd</code>, ou vistas diretamente dentro da pasta <code>/var/cache/nscd</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -1 /var/cache/nscd/
group
hosts
netgroup
passwd
services</pre>
</div>
</div>
<div class="paragraph">
<p>Para invalidar todas as <em>caches</em> do <code>nscd</code>, podemos executar por exemplo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># for table in `ls -1 /var/cache/nscd` ; do nscd --invalidate $table ; done</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar a efetividade do controle aplicado. Na máquina <code>client</code>, faça login como o usuário <code>luke</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
luke</pre>
</div>
</div>
<div class="paragraph">
<p>Tente logar via <code>ssh</code> na máquina <code>ns1</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh luke@ns1
LDAP authorisation check failed
Authentication failed.</pre>
</div>
</div>
<div class="paragraph">
<p>Como o usuário <code>luke</code> não pertence ao grupo <code>fwadm</code>, o acesso é negado. Observando o log de <em>debug</em> do <code>nslcd</code>, podemos ver que a pesquisa com o filtro aplicado anteriormente não retorna resultados:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nslcd: [95f874] &lt;authz="luke"&gt; DEBUG: trying pam_authz_search "(&amp;(objectClass=posixGroup)(cn=fwadm)(memberUid=luke))"
nslcd: [95f874] &lt;authz="luke"&gt; DEBUG: myldap_search(base="dc=intnet", filter="(&amp;(objectClass=posixGroup)(cn=fwadm)(memberUid=luke))")
nslcd: [95f874] &lt;authz="luke"&gt; DEBUG: ldap_result(): end of results (0 total)
nslcd: [95f874] &lt;authz="luke"&gt; pam_authz_search "(&amp;(objectClass=posixGroup)(cn=fwadm)(memberUid=luke))" found no matches</pre>
</div>
</div>
</li>
<li>
<p>Vamos fazer o mesmo procedimento com o usuário <code>han</code>. Logue-se como <code>han</code> na máquina <code>client</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
han</pre>
</div>
</div>
<div class="paragraph">
<p>Como é a primeira vez que estamos usando este usuário, gere um par de chaves assinadas para ele:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bash ~/scripts/sshsign_user.sh
Signing ~/.ssh/id_rsa.pub key...
All done!</pre>
</div>
</div>
<div class="paragraph">
<p>Tente logar via <code>ssh</code> na máquina <code>ns1</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh han@ns1
Creating directory '/home/han'.
Linux ns1 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

han@ns1:~$</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami ; pwd
ns1
han
/home/han</pre>
</div>
</div>
<div class="paragraph">
<p>Observando o log de <em>debug</em> do <code>nslcd</code>, podemos ver que a pesquisa com o filtro aplicado anteriormente retorna como resultado o grupo <code>cn=fwadm,ou=Groups,dc=intnet</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nslcd: [138641] &lt;authz="han"&gt; DEBUG: trying pam_authz_search "(&amp;(objectClass=posixGroup)(cn=fwadm)(memberUid=han))"
nslcd: [138641] &lt;authz="han"&gt; DEBUG: myldap_search(base="dc=intnet", filter="(&amp;(objectClass=posixGroup)(cn=fwadm)(memberUid=han))")
nslcd: [138641] &lt;authz="han"&gt; DEBUG: ldap_result(): cn=fwadm,ou=Groups,dc=intnet
nslcd: [138641] &lt;authz="han"&gt; DEBUG: pam_authz_search found "cn=fwadm,ou=Groups,dc=intnet"</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_15_restringindo_logins_ssh_apenas_via_chaves_assimétricas">15) Restringindo logins SSH apenas via chaves assimétricas</h3>
<div class="paragraph">
<p>Apesar de o controle que aplicamos na atividade anterior ser interessante, ainda não resolvemos o problema completamente. Como é possível tentar login na máquina <code>ns1</code> usando senha, é possível que um atacante tente login por força-bruta, adivinhando a senha do usuário <code>han</code>, até conseguir. Vamos resolver isso.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, vamos constatar o problema. Logue na máquina <code>client</code> como o usuário <code>han</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
han</pre>
</div>
</div>
<div class="paragraph">
<p>Para evitar que o cliente <code>ssh</code> use nossa chave assinada, passe as opções abaixo para o comando. Em seguida, digite a senha correta do usuário <code>han</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no han@ns1
han@ns1's password:
Linux ns1 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

Last login: Wed Nov 14 00:26:13 2018 from 192.168.42.2
han@ns1:~$</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns1
han</pre>
</div>
</div>
<div class="paragraph">
<p>Note que conseguimos fazer o login usando senha normalmente, sem usar a chave assinada pela CA.</p>
</div>
</li>
<li>
<p>Logue como <code>root</code> na máquina <code>ns1</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Iremos aplicar o controle sobre a opção <code>PasswordAuthentication</code> do <code>sshd</code>, desativando-o. Assim, não será mais possível logar via senha, apenas via chaves assimétricas. Execute o comando abaixo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^#\(PasswordAuthentication\).*/\1 no/' /etc/ssh/sshd_config</pre>
</div>
</div>
<div class="paragraph">
<p>E reinicie o <code>sshd</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart sshd.service</pre>
</div>
</div>
</li>
<li>
<p>De volta à máquina <code>client</code>, como <code>han</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
han</pre>
</div>
</div>
<div class="paragraph">
<p>Tente novamente logar usando senha:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no han@ns1
Permission denied (publickey).</pre>
</div>
</div>
<div class="paragraph">
<p>Note que a permissão foi negada, pois apenas o método <code>publickey</code> é aceito para autenticação. Remova as opções do <code>ssh</code> e tente novamente, desta vez usando chaves:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh han@ns1
Linux ns1 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

Last login: Wed Nov 14 00:27:39 2018 from 192.168.42.2
han@ns1:~$</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns1
han</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_16_bloqueando_tentativas_de_brute_force_contra_o_ssh">16) Bloqueando tentativas de brute force contra o SSH</h3>
<div class="paragraph">
<p>Não podemos aplicar o mesmo tipo de controle que fizemos na máquina <code>ns1</code> (o firewall da rede) no servidor <code>ns2</code> (o servidor LDAP)&#8201;&#8212;&#8201;nosso <em>script</em> de assinatura de chaves de <em>host</em> e de usuário utiliza login via senha com o usuário <code>sshca</code> para operar. A alteração dos <em>scripts</em> para usarem chaves e a correspondente restrição a login usando senhas teria implicações muito negativas na segurança do sistema, neste momento. Vamos implementar um controle diferente, então: proteção contra ataques de força-bruta usando a ferramenta Fail2ban.</p>
</div>
<div class="paragraph">
<p>O Fail2ban opera através da análise de eventos de log (normalmente registrados no diretório <code>/var/log</code>) e seu processamento através de expressões regulares. Caso um evento "case" (ou seja, ocorra um <em>match</em>) com uma expressão regular configurada, o Fail2ban irá adicionar uma unidade ao contador de violações de um determinado <em>host</em> remoto. Se esse <em>host</em> ultrapassar o número de violações configuradas em um dado período, o Fail2ban irá então tomar alguma ação configurada pelo administrador (registrar um evento nos logs, enviar um e-mail para o administrador ou até mesmo bloquear de forma automática o <em>host</em> no firewall local).</p>
</div>
<div class="paragraph">
<p>Várias expressões regulares já vêm pré-configuradas no Fail2ban, para as ferramentas mais populares (como o <code>sshd</code>, o servidor web Apache ou o servidor SMTP Postfix). Caso se deseje configurar expressões regulares para ferramentas customizadas, também é possível fazê-lo.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Logue como o usuário <code>root</code> na máquina <code>ns2</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
</li>
<li>
<p>Instale a ferramenta <code>fail2ban</code>:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install fail2ban</pre>
</div>
</div>
</li>
<li>
<p>Note que, por padrão, apenas a <em>jail</em> <code>sshd</code> vem habilitada no Debian. Não teremos que fazer qualquer alteração nesse sentido, já que é justamente o serviço <code>ssh</code> que queremos proteger.</p>
<div class="literalblock">
<div class="content">
<pre># cat /etc/fail2ban/jail.d/defaults-debian.conf
[sshd]
enabled = true</pre>
</div>
</div>
</li>
<li>
<p>As opções padrão do Fail2ban ficam configuradas no arquivo <code>/etc/fail2ban/jail.conf</code>, seção <code>[DEFAULT]</code>. Em particular, temos interesse nas seguintes configurações:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>findtime</code>: Intervalo em que o Fail2ban irá registrar violações de <em>hosts</em> remotos.</p>
</li>
<li>
<p><code>maxretry</code>: Número de violações máximo permitido dentro do período <code>findtime</code> definido acima. Caso este valor seja ultrapassado, o Fail2ban irá tomar a ação configurada pelo administrador.</p>
</li>
<li>
<p><code>bantime</code>: Período em que o <em>host</em> remoto será afetado pela ação configurada. Caso esta ação seja, por exemplo, um bloqueio no firewall local, o <em>host</em> ficará banido pelo tempo especificado aqui.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Os valores padrão para as variáveis acima são os que se seguem:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/fail2ban/jail.conf | sed -n -e '/^\[DEFAULT\]/,/^\[/p' | grep '^maxretry\|^bantime\|^findtime'
bantime  = 600
findtime  = 600
maxretry = 5</pre>
</div>
</div>
</li>
<li>
<p>Vamos configurar o seguinte cenário: caso um atacante seja detectado pelo Fail2ban com mais de 3 violações (<code>maxretry</code>) num período de dez minutos (<code>findtime</code>), então iremos bani-lo via regra no firewall local (ação <code>iptables-multiport</code>) por dez minutos (<code>bantime</code>). Como o <code>findtime</code> e o <code>bantime</code> padrão estão corretos, iremos apenas configurar as duas outras variáveis, como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># echo "maxretry = 3" &gt;&gt; /etc/fail2ban/jail.d/defaults-debian.conf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># echo "banaction = iptables-multiport" &gt;&gt; /etc/fail2ban/jail.d/defaults-debian.conf</pre>
</div>
</div>
<div class="paragraph">
<p>O arquivo <code>/etc/fail2ban/jail.d/defaults-debian.conf</code> ficou assim, portanto:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/fail2ban/jail.d/defaults-debian.conf
[sshd]
enabled = true
maxretry = 3
banaction = iptables-multiport</pre>
</div>
</div>
</li>
<li>
<p>Uma outra configuração necessária é comentar uma linha do arquivo <code>/etc/fail2ban/filter.d/sshd.conf</code> que contém uma expressão regular para detectar entradas no seguinte formato no arquivo <code>/var/log/auth.log</code>:</p>
<div class="literalblock">
<div class="content">
<pre>Oct 30 12:03:47 ldap sshd[6677]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.42.2  user=sshca</pre>
</div>
</div>
<div class="paragraph">
<p>Em sistemas com autenticação LDAP, como é o nosso caso, a linha acima é inserida em tentativas de login mesmo em caso de sucesso, como reportado em <a href="https://github.com/fail2ban/fail2ban/issues/106" class="bare">https://github.com/fail2ban/fail2ban/issues/106</a> . Para corrigir esse falso positivo, basta executar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^\(.*pam_unix.*\)/#\1/' /etc/fail2ban/filter.d/sshd.conf</pre>
</div>
</div>
</li>
<li>
<p>Reinicie o Fail2ban para aplicar as configurações que realizamos:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl restart fail2ban.service</pre>
</div>
</div>
</li>
<li>
<p>O Fail2ban criará novas <em>chains</em> no firewall para inserção de regras de banimento, quando adequado. Observe que o firewall está, até este momento, sem regras de BLOCK ou REJECT:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -L -vn
Chain INPUT (policy ACCEPT 37 packets, 5021 bytes)
 pkts bytes target     prot opt in     out     source               destination
   26  1820 f2b-sshd   tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            multiport dports 22

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 13 packets, 1152 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain f2b-sshd (1 references)
 pkts bytes target     prot opt in     out     source               destination
   26  1820 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, vamos fazer uma simulação de ataque ao <code>sshd</code>. Monitore o arquivo <code>/var/log/fail2ban.log</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># tail -n5 -f /var/log/fail2ban.log
2018-11-14 00:31:44,246 fail2ban.filter         [2099]: INFO    Set findtime = 600
2018-11-14 00:31:44,246 fail2ban.filter         [2099]: INFO    Set jail log file encoding to UTF-8
2018-11-14 00:31:44,246 fail2ban.filter         [2099]: INFO    Set maxlines = 10
2018-11-14 00:31:44,277 fail2ban.server         [2099]: INFO    Jail sshd is not a JournalFilter instance
2018-11-14 00:31:44,281 fail2ban.jail           [2099]: INFO    Jail 'sshd' started</pre>
</div>
</div>
</li>
<li>
<p>Logue na máquina <code>client</code> como o usuário <code>han</code>, por exemplo:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
han</pre>
</div>
</div>
<div class="paragraph">
<p>Para disparar o filtro do Fail2ban na máquina <code>ns2</code>, não poderemos usar o login via chaves assimétricas, que obterá sucesso. Faça login usando senha como mostrado no comando a seguir; digite senhas incorretas para ativar a detecção do Fail2ban:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no han@ns2
han@ns2's password:
Permission denied, please try again.
han@ns2's password:
Permission denied, please try again.
han@ns2's password:
Permission denied (publickey,password).</pre>
</div>
</div>
<div class="paragraph">
<p>Tente logar novamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no han@ns2
ssh: connect to host ns2 port 22: Connection refused</pre>
</div>
</div>
<div class="paragraph">
<p>A máquina foi bloqueada, como esperado.</p>
</div>
</li>
<li>
<p>De volta à máquina <code>ns2</code>, como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="paragraph">
<p>Note que os eventos de senha incorreta foram registrados pelo Fail2ban, bem como o banimento:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>2018-11-14 00:34:01,944 fail2ban.filter         [2099]: INFO    [sshd] Found 192.168.42.2
2018-11-14 00:34:04,830 fail2ban.filter         [2099]: INFO    [sshd] Found 192.168.42.2
2018-11-14 00:34:08,081 fail2ban.filter         [2099]: INFO    [sshd] Found 192.168.42.2
2018-11-14 00:34:08,534 fail2ban.actions        [2099]: NOTICE  [sshd] Ban 192.168.42.2</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que a regra de REJECT foi inserida automaticamente pelo Fail2ban no firewall local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -L f2b-sshd -vn
Chain f2b-sshd (1 references)
 pkts bytes target     prot opt in     out     source               destination
    1    60 REJECT     all  --  *      *       192.168.42.2         0.0.0.0/0            reject-with icmp-port-unreachable
  612 70528 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0</pre>
</div>
</div>
<div class="paragraph">
<p>Para remover o banimento de um endereço IP antes que o tempo total do <code>bantime</code> tenha transcorrido, é possível usar o comando <code>fail2ban-client</code>, como mostrado a seguir:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># fail2ban-client set sshd unbanip 192.168.42.2
192.168.42.2</pre>
</div>
</div>
<div class="paragraph">
<p>Note que a regra de firewall é apagada, como esperado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -L f2b-sshd -vn
Chain f2b-sshd (1 references)
 pkts bytes target     prot opt in     out     source               destination
  395 25992 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0</pre>
</div>
</div>
</li>
<li>
<p>De volta à máquina <code>client</code>, como <code>han</code>, podemos tentar o login via senha novamente&#8201;&#8212;&#8201;desta vez, digite a senha correta:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
han</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no han@ns2
han@ns2's password:
Creating directory '/home/han'.
Linux ns2 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

han@ns2:~$</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns2
han</pre>
</div>
</div>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_4_controles_de_segurança">Sessão 4: Controles de segurança</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Estando configurado nosso sistema de autenticação centralizado, quais seriam os próximos passos para realizar o <em>hardening</em> do ambiente? Nesta sessão, iremos tratar de algumas configurações mais simples, num escopo particular, mas que somadas tornarão o <em>datacenter</em> muito mais resiliente contra ataques, além de mais funcional. Iremos verificar se as senhas escolhidas pelos usuários são de fato seguras, implementar <em>quotas</em> de disco em um servidor de arquivos Linux, permitir controle mais granular de permissões de arquivos através de ACLs (<em>Access Control Lists</em>) e realizar um controle refinado de autorizações administrativas usando o comando <code>sudo</code>.</p>
</div>
<div class="paragraph">
<p>Vamos ao trabalho?</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão_3">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>A figura abaixo mostra a topologia de rede que será utilizada nesta sessão, com as máquinas relevantes em destaque.</p>
</div>
<div id="img-topologia4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/Topologia_SEG10_S4.png" alt="Topologia SEG10 S4">
</div>
<div class="title">Figure 28. Topologia de rede desta sessão</div>
</div>
<div class="paragraph">
<p>Teremos agora quatro máquinas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ns1</code>, com <em>alias</em> <code>fw</code>, atuando como firewall de rede e DNS primário. Endereços IP via DHCP (interface <em>bridge</em>), 10.0.42.1/24 (interface DMZ) e 192.168.42.1/24 (interface Intranet).</p>
</li>
<li>
<p><code>ns2</code>, com <em>alias</em> <code>ldap</code>, localizada na DMZ e atuando como DNS secundário, servidor LDAP de autenticação centralizada e repositório de chaves SSH-CA. Endereço IP 10.0.42.2/24.</p>
</li>
<li>
<p><code>nfs</code>, com <em>alias</em> <code>files</code>, localizada na DMZ e atuando como servidor de arquivos NFS. Endereço IP 10.0.42.3/24.</p>
</li>
<li>
<p><code>client</code>, localizada na Intranet e usada como ponto de partida para logins remotos nos diferentes servidores do <em>datacenter</em> simulado. Endereço IP 192.168.42.2/24.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Na topologia há a previsão de criação de dois novos registros DNS, um mapeamento direto para o nome <code>nfs</code> e um <em>alias</em> dessa mesma máquina para o nome <code>files</code>. Vamos ajustar o DNS: acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo de zonas <code>/etc/nsd/zones/intnet.zone</code>, inserindo uma entrada A e outra CNAME para a máquina <code>nfs</code>, como se segue. <strong>Não se esqueça</strong> de incrementar o valor do serial no topo do arquivo!</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/intnet.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep nfs /etc/nsd/zones/intnet.zone
nfs     IN    A                 10.0.42.3
files   IN    CNAME             nfs</pre>
</div>
</div>
<div class="paragraph">
<p>Desta vez também será necessário alterar o arquivo de mapeamento reverso <code>/etc/nsd/zones/10.0.42.zone</code> com um registro PTR para a nova máquina. Novamente, lembre-se de incrementar o <strong>serial</strong> neste arquivo também.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/10.0.42.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep nfs /etc/nsd/zones/10.0.42.zone
3       IN   PTR                nfs.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>Assine o arquivo de zonas usando o <em>script</em> criado anteriormente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash /root/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 0 rrsets, 0 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que as entradas foram criadas com sucesso, usando o comando <code>dig</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig nfs.intnet +short
10.0.42.3</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># dig files.intnet +short
nfs.intnet.
10.0.42.3</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># dig -x 10.0.42.3 +short
nfs.intnet.</pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_2_requisitos_de_senha_na_base_ldap">2) Requisitos de senha na base LDAP</h3>
<div class="paragraph">
<p>Uma preocupação frequente dos analistas de segurança é quanto às senhas dos usuários: será que elas tem um tamanho apropriado, não utilizam palavras constantes em <em>wordlists</em>, contém caracteres especiais? Apesar de termos configurado o acesso aos nossos servidores usando chaves assimétricas via SSH-CA (e, no caso da máquina <code>ns1</code>, aplicado restrição de acesso exclusivamente via chaves), não é interessante que nos despreocupemos totalmente da segurança de senhas dos usuários&#8201;&#8212;&#8201;afinal, os logins na máquina <code>ns2</code> ainda podem usar senhas, por exemplo.</p>
</div>
<div class="paragraph">
<p>Podemos utilizar o <em>policy overlay</em> do <code>slapd</code> (documentação em <a href="https://www.openldap.org/doc/admin24/overlays.html" class="bare">https://www.openldap.org/doc/admin24/overlays.html</a> ou <code>man 5 slapo-ppolicy</code>) para implementar alguns controles no diretório LDAP para exigir aspectos mínimos de qualidade das senhas dos usuários, tais como:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>pwdInHistory</code>: Histórico de senhas, mantém uma lista de senhas passadas que impede que o usuário as repita. O número de senhas mantidas em histórico é configurável.</p>
</li>
<li>
<p><code>pwdMaxAge</code>: Tempo máximo de validade da senha.</p>
</li>
<li>
<p><code>pwdMinAge</code>: Tempo mínimo de validade da senha, para evitar que o usuário circule pelo histórico rapidamente e apague o registro de uma senha que queira repetir.</p>
</li>
<li>
<p><code>pwdMinLength</code>: Tamanho mínimo da senha do usuário, em caracteres.</p>
</li>
<li>
<p><code>pwdMaxFailure</code>: Número máximo de tentativas de <em>bind</em> com senha incorreta antes que a conta do usuário seja travada.</p>
</li>
<li>
<p><code>pwdCheckQuality</code>: Define uma função externa para checagem de qualidade da senha do usuário&#8201;&#8212;&#8201;esta é uma extensão não-padrão da política de senhas do diretório LDAP, e não iremos configurá-la. O website <a href="http://ltb-project.org/wiki/documentation/openldap-ppolicy-check-password" class="bare">http://ltb-project.org/wiki/documentation/openldap-ppolicy-check-password</a> disponibiliza um software customizado que pode ser usado para implementar esse tipo de política.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Faça login como <code>root</code> na máquina <code>ns2</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="paragraph">
<p>Para habilitar esses controles em nossa base LDAP, o primeiro passo é carregar o arquivo LDIF do <em>schema</em> com as informações de políticas de senhas:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapadd -Y external -H ldapi:/// -f /etc/ldap/schema/ppolicy.ldif
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
adding new entry "cn=ppolicy,cn=schema,cn=config"</pre>
</div>
</div>
</li>
<li>
<p>Em seguida, iremos adicionar o módulo <code>/usr/lib/ldap/ppolicy.la</code> à lista de módulos carregados pelo <code>slapd</code> em seu início. Crie o arquivo novo <code>/root/ldif/olcModuleLoad.ldif</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: ppolicy.la</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para aplicar as modificações desse LDIF à base LDAP, basta executar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapmodify -Y EXTERNAL -H ldapi:/// -f ~/ldif/olcModuleLoad.ldif
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
modifying entry "cn=module{0},cn=config"</pre>
</div>
</div>
</li>
<li>
<p>A próxima etapa é configurar o <em>overlay</em> de políticas de senhas para controlar os atributos <code>userPassword</code> de nossa base <code>cn=intnet</code>. Crie o arquivo novo <code>/root/ldif/olcOverlayPpolicy.ldif</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dn: olcOverlay=ppolicy,olcDatabase={1}mdb,cn=config
objectClass: olcOverlayConfig
objectClass: olcPPolicyConfig
olcOverlay: ppolicy
olcPPolicyDefault: cn=passwordDefault,ou=Policies,dc=intnet
olcPPolicyHashCleartext: FALSE
olcPPolicyUseLockout: FALSE
olcPPolicyForwardUpdates: FALSE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note que estamos indicando que o <em>overlay</em> <code>ppolicy</code> será aplicado sobre a base <code>{1}mdb</code>, que é exatamente a base com raiz em <code>dc=intnet</code>, como podemos confirmar através do comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -Y external -H ldapi:/// -LLL -b 'cn=config' '(&amp;(objectClass=olcDatabaseConfig)(olcSuffix=dc=intnet))' dn 2&gt; /dev/null
dn: olcDatabase={1}mdb,cn=config</pre>
</div>
</div>
<div class="paragraph">
<p>Caso estivéssemos fazendo esta configuração em um ambiente que possua várias bases LDAP carregadas dentro de um mesmo <em>daemon</em> <code>slapd</code>, seria necessário determinar o número da base MDB e editar o arquivo mostrado anteriormente.</p>
</div>
<div class="paragraph">
<p>Para aplicar as modificações desse LDIF à base LDAP, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapadd -Y EXTERNAL -H ldapi:/// -f ~/ldif/olcOverlayPpolicy.ldif
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
adding new entry "olcOverlay=ppolicy,olcDatabase={1}mdb,cn=config"</pre>
</div>
</div>
</li>
<li>
<p>Agora, vamos definir a política de senhas da base <code>dc=intnet</code>. Crie o arquivo novo <code>/root/ldif/passwordDefault.ldif</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dn: ou=Policies,dc=intnet
ou: Policies
objectClass: organizationalUnit

dn: cn=passwordDefault,ou=Policies,dc=intnet
objectClass: pwdPolicy
objectClass: person
objectClass: top
cn: passwordDefault
sn: passwordDefault
pwdAttribute: userPassword
pwdCheckQuality: 2
pwdMinAge: 0
pwdMaxAge: 2592000
pwdMinLength: 8
pwdInHistory: 5
pwdMaxFailure: 3
pwdFailureCountInterval: 0
pwdLockout: TRUE
pwdLockoutDuration: 0
pwdAllowUserChange: TRUE
pwdExpireWarning: 0
pwdGraceAuthNLimit: 0
pwdMustChange: FALSE
pwdSafeModify: FALSE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estamos, em ordem:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Criando uma entrada <code>ou=Policies,dc=intnet</code> para armazenar políticas da base <code>dc=intnet</code>.</p>
</li>
<li>
<p>Dentro desta OU, criando o CN <code>cn=passwordDefault,ou=Policies,dc=intnet</code> que define a política de senhas da base. Configurações mais relevantes:</p>
<div class="ulist">
<ul>
<li>
<p><code>pwdAttribute</code> define o atributo que será verificado, que armazena senhas de usuários.</p>
</li>
<li>
<p><code>pwdCheckQuality</code> ativa a checagem de qualidade de senhas; como não estamos habilitando nenhum módulo externo, apenas a checagem de comprimento será aplicada.</p>
</li>
<li>
<p><code>pwdMinAge</code> define o tempo mínimo de validade de senhas; como queremos testar o histórico de senhas, explicado a seguir, não iremos ativar essa opção.</p>
</li>
<li>
<p><code>pwdMaxAge</code> define o tempo máximo de validade da senha, em segundos; ajustamos esse valor para 30 dias.</p>
</li>
<li>
<p><code>pwdMinLength</code> define o tamanho mínimo de senha, 8 caracteres.</p>
</li>
<li>
<p><code>pwdInHistory</code> define que iremos guardar o <em>hash</em> das 5 senhas mais recentes de cada usuário, que não poderão repeti-las.</p>
</li>
<li>
<p><code>pwdMaxFailure</code> define que usuários que errarem a senha consecutivamente mais de 3 vezes terão suas contas bloqueadas.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Para aplicar o LDIF à base LDAP temos que nos autenticar na raiz <code>dc=intnet</code>, como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapadd -D 'cn=admin,dc=intnet' -W -f ~/ldif/passwordDefault.ldif
Enter LDAP Password:
adding new entry "ou=Policies,dc=intnet"

adding new entry "cn=passwordDefault,ou=Policies,dc=intnet"</pre>
</div>
</div>
</li>
<li>
<p>Reinicie o <code>slapd</code> para aplicar as configurações:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl restart slapd.service</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar nossos controles&#8201;&#8212;&#8201;logue na máquina <code>client</code> como o usuário <code>luke</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
luke</pre>
</div>
</div>
<div class="paragraph">
<p>Tente alterar a senha do usuário para uma <em>string</em> menor que o tamanho exigido, como <code>marte</code> por exemplo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ passwd
(current) LDAP Password:
Nova senha:
Redigite a nova senha:
password change failed: Password fails quality checking policy
passwd : Erro de manipulação de token de autenticação
passwd: senha inalterada</pre>
</div>
</div>
<div class="paragraph">
<p>O <code>slapd</code> nos informa que a senha não atende os requisitos mínimos de qualidade, nesse caso, o tamanho da senha.</p>
</div>
</li>
<li>
<p>Altere a senha para um valor aceitável, como <code>seg10luke2</code>, por exemplo:</p>
<div class="literalblock">
<div class="content">
<pre>$ passwd
(current) LDAP Password:
Nova senha:
Redigite a nova senha:
passwd: senha atualizada com sucesso</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, tente alterar a senha para um valor já usado anteriormente, como <code>seg10luke</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ passwd
(current) LDAP Password:
Nova senha:
Redigite a nova senha:
password change failed: Password is in history of old passwords
passwd : Erro de manipulação de token de autenticação
passwd: senha inalterada</pre>
</div>
</div>
<div class="paragraph">
<p>Somos informados que a senha consta do histórico de senhas antigas. Como o LDAP implementa isso? Acesse a máquina <code>ns2</code> como usuário <code>root</code> e pesquise pelo campo <code>pwdHistory</code> do usuário <code>luke</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -LLL -D 'cn=admin,dc=intnet' -W 'uid=luke' pwdHistory
Enter LDAP Password:
dn: uid=luke,ou=People,dc=intnet
pwdHistory: 20181114030204Z#1.3.6.1.4.1.1466.115.121.1.40#38#{SSHA}bI0fgkHR6MZ
 tAavv1bUYx9PuPucZhDyY</pre>
</div>
</div>
<div class="paragraph">
<p>Ao informarmos uma nova senha, o <code>slapd</code> compara o seu hash com um dos <em>hashes</em> guardados no histórico do usuário (nesse caso, <code>luke</code>); se encontrada, a senha é rejeitada.</p>
</div>
</li>
<li>
<p>Vamos testar o <em>lockout</em> de contas. Como teremos que fazer logins propositalmente incorretos, ainda como o usuário <code>root</code> na máquina <code>ns2</code>, pare o serviço Fail2ban para evitar que sejamos bloqueados pelo firewall durante o teste:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl stop fail2ban</pre>
</div>
</div>
<div class="paragraph">
<p>De volta à máquina <code>client</code> como <code>luke</code>, tente logar via SSH na máquina <code>ns2</code> usando senha e erre propositalmente a combinação por 3 vezes consecutivas:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no luke@ns2
luke@ns2's password:
Permission denied, please try again.
luke@ns2's password:
Permission denied, please try again.
luke@ns2's password:
Permission denied (publickey,password).</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, tente logar com a senha correta&#8201;&#8212;&#8201;note que seu acesso será negado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no luke@ns2
luke@ns2's password:
Permission denied, please try again.</pre>
</div>
</div>
<div class="paragraph">
<p>De volta à máquina <code>ns2</code> como o usuário <code>root</code>, vamos verificar o que aconteceu:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="paragraph">
<p>Execute o comando <code>ldapsearch</code> abaixo para listar todos os usuários bloqueados na base <code>dc=intnet</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -LLL -D 'cn=admin,dc=intnet' -W 'pwdAccountLockedTime=*' pwdAccountLockedTime
Enter LDAP Password:
dn: uid=luke,ou=People,dc=intnet
pwdAccountLockedTime: 20181114030659Z</pre>
</div>
</div>
<div class="paragraph">
<p>Como esperado, <code>luke</code> está bloqueado. Para desbloquear um usuário específico crie um arquivo LDIF novo, <code>/root/ldif/unlockUser.ldif</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dn: uid=luke,ou=People,dc=intnet
changetype: modify
delete: pwdAccountLockedTime</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aplique as alterações do LDIF à base com:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapmodify -D 'cn=admin,dc=intnet' -W -f ~/ldif/unlockUser.ldif
Enter LDAP Password:
modifying entry "uid=luke,ou=People,dc=intnet"</pre>
</div>
</div>
<div class="paragraph">
<p>De volta à máquina <code>client</code> como <code>luke</code>, tente logar novamente com a senha correta:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no luke@ns2
luke@ns2's password:
Linux ns2 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

Last login: Wed Nov 14 00:15:11 2018 from 192.168.42.2
luke@ns2:~$</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns2
luke</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito, nossos controles funcionaram como esperado. Na máquina <code>ns2</code>, como <code>root</code>, não se esqueça de reiniciar o Fail2ban:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl start fail2ban</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_busca_de_senhas_fracas">3) Busca de senhas fracas</h3>
<div class="paragraph">
<p>Simplesmente configurar um tamanho mínimo de senha, como fizemos na atividade anterior, não é garantia que os usuários escolherão senhas seguras para suas contas. Por exemplo, um usuário pode definir <code>12345678</code> como sua senha&#8201;&#8212;&#8201;essa <em>string</em> está dentro do tamanho mínimo exigido mas não pode, nem de perto, ser considerada uma senha segura. O que fazer?</p>
</div>
<div class="paragraph">
<p>Podemos submeter os <em>hashes</em> de senha dos usuários a testes de segurança, como ataques de força-bruta&#8201;&#8212;&#8201;em que testamos combinações de caracteres exaustivamente para descobrir a senha&#8201;&#8212;&#8201;ou de dicionário&#8201;&#8212;&#8201;em que usamos uma base de senhas previamente preechida, conhecida como <em>wordlist</em>, e verificamos se a senha do usuário se encontra nessa lista. Devido ao fato de as senhas do LDAP serem armazenadas por padrão em formado SSHA (SHA-1 com <em>salt</em>), ataques do tipo <em>rainbow table</em>&#8201;&#8212;&#8201;em que comparamos o <em>hash</em> da senha do usuário com uma base de <em>hashes</em> previamente computados, buscando por similaridades&#8201;&#8212;&#8201;não são viáveis. Podemos verificar o <em>hash</em> utilizado para armazenar a senha do usuário <code>luke</code>, por exemplo, usando o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsearch -x -LLL -D 'cn=admin,dc=intnet' -W 'uid=luke' userPassword | grep '^userPassword::' | awk '{print $NF}' | base64 --decode
Enter LDAP Password:
{SSHA}JK1/uM/9bmoWM/IzW1uIBM4b1Q4UEWd8</pre>
</div>
</div>
<div class="paragraph">
<p>A ferramenta que iremos utilizar para realizar os ataques de dicionário e força-bruta mencionados anteriormente será o <code>hashcat</code> (<a href="https://hashcat.net/hashcat/" class="bare">https://hashcat.net/hashcat/</a>). Uma das ferramentas mais rápidas para quebra de senhas disponíveis, é um programa <em>open source</em> multiplataforma que se utiliza da CPU ou GPUs (placas gráficas) de uma máquina para acelerar o processo de ataque sensivelmente, especialmente quando comparada com ferramentas mais tradicionais como o <code>john</code>.</p>
</div>
<div class="paragraph">
<p>Até a versão v3.00, o <code>hashcat</code> era dividido em duas versões, uma voltada para CPUs e outra para GPUs (esta, implementada via OpenCL ou CUDA). Com o lançamento da versão v3.00, as duas versões foram unificadas em uma única ferramenta, requerendo a biblioteca OpenCL (<a href="https://www.khronos.org/opencl/" class="bare">https://www.khronos.org/opencl/</a>) como dependência.</p>
</div>
<div class="paragraph">
<p>É boa prática de segurança que instalemos apenas o estritamente necessário em servidores, a fim de reduzir a superfície de ataque disponível em uma eventual invasão. Por esse motivo, instalaremos o <code>hashcat</code> e as demais bibliotecas necessárias na máquina <code>client</code>, que é menos crítica que os servidores <code>ns2</code> e <code>ns1</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acesse a máquina <code>client</code> como o usuário <code>root</code>, e instale o <code>hashcat</code> e suas dependências:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
client
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get install --no-install-recommends hashcat libhwloc-dev ocl-icd-dev ocl-icd-opencl-dev pocl-opencl-icd</pre>
</div>
</div>
</li>
<li>
<p>Agora, acesse como o usuário <code>luke</code>, em seu diretório <em>home</em>.</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami ; pwd
client
luke
/home/luke</pre>
</div>
</div>
<div class="paragraph">
<p>Altere a senha do usuário <code>luke</code> para um valor propositalmente inseguro, como <code>password</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ passwd
(current) LDAP Password:
Nova senha:
Redigite a nova senha:
passwd: senha atualizada com sucesso</pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro passo para testarmos a segurança das senhas dos usuários é obter seus <em>hashes</em>. Vamos fazer isso, de forma remota, usando um <em>script</em> shell mostrado a seguir. Crie o arquivo novo <code>/home/luke/scripts/gethashes.sh</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

TMPFILE="$( mktemp )"
OUTFILE="${HOME}/hashes.txt"

rm -f ${OUTFILE}
touch ${OUTFILE}

ldapsearch -x                     \
  -LLL                            \
  -H ldap://10.0.42.2             \
  -D 'cn=admin,dc=intnet'         \
  -w 'rnpesr'                     \
  -b 'dc=intnet'                  \
  'userPassword=*'                \
  cn userPassword                 \
  | grep '^cn:\|^userPassword::'  \
  | awk '{print $NF}'             \
  | sed 'N;s/\n/ /'               \
  | tr ' ' ':' &gt; ${TMPFILE}

while read l; do
  luser="$( echo ${l} | cut -d':' -f1 )"
  lhash="$( echo ${l} | cut -d':' -f2 )"

  echo "${luser}:$( echo ${lhash} | base64 --decode )" &gt;&gt; ${OUTFILE}
done &lt; ${TMPFILE}

rm -f ${TMPFILE}</code></pre>
</div>
</div>
<div class="paragraph">
<p>O que esse <em>script</em> faz? Vamos ver:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>(Linhas 3-4) Criamos um arquivo temporário com o comando <code>mktemp</code>, e definimos o arquivo de saída como <code>~/hashes.txt</code>.</p>
</li>
<li>
<p>(Linhas 6-7) Se existente, removemos o arquivo de saída e criamos um novo, vazio.</p>
</li>
<li>
<p>(Linhas 9-20) Executamos um comando <code>ldapsearch</code> remoto na máquina <code>ns2</code>, executando o <em>bind</em> como o usuário <code>cn=admin,dc=intnet</code> e senha informada diretamente na linha de comando. Buscamos todos os DNs que possuem o campo <code>userPassword</code> não-vazio, e filtramos apenas os campos <code>cn</code> e <code>userPassword</code> na saída. Finalmente, fazemos uma junção de linhas duas-a-duas usando os comandos <code>awk</code>, <code>sed</code> e inserimos um separador usando o <code>tr</code>. Essa saída é escrita no arquivo temporário criado anteriormente.</p>
</li>
<li>
<p>(Linhas 22-27) Processamos o arquivo temporário linha-a-linha. Em cada linha, extraímos o campo 1 (<code>cn</code> do usuário) e o campo 2 (<code>userPassword</code>). O campo <code>userPassword</code> está codificado em base64, então usamos <code>base64 --decode</code> para traduzir esse campo, e escrevemos o <em>output</em> em ordem no arquivo de saída.</p>
</li>
<li>
<p>(Linha 29) O arquivo temporário é removido.</p>
</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<p>Vamos testar o funcionamento do <em>script</em>:</p>
<div class="literalblock">
<div class="content">
<pre>$ bash ~/scripts/gethashes.sh</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat hashes.txt
admin:{SSHA}NzQZTz7ufOxNM3PYy7cp+zV6p7bKFNcy
luke:{SSHA}46Qe8Ny+QQgDsbPcps2MODqUHGtdLX41
sshca:{SSHA}+JTtQ5+XEi+sJ4sPmWK3lZXrIHSpbcbn
han:{SSHA}BE6cC89vaJQtB/g9yEJTt0O8HCtRabel</pre>
</div>
</div>
</li>
<li>
<p>Vamos, primeiramente, executar um ataque de dicionário. Um ataque de dicionário, como mencionado anteriormente, é quando obtermos um arquivo com um conjunto de senhas em texto claro, calculamos seus <em>hashes</em> usando os valores de <em>salt</em> conhecidos, e comparamos os resultados com os <em>hashes</em> dos usuários.</p>
<div class="paragraph">
<p>No caso do algorito SSHA implementado no OpenLDAP, para extrair o <em>salt</em> devemos decodificar o <em>hash</em> original em base64 uma vez, remover o prefixo <code>{SSHA}</code>, decodificar o <em>hash</em> resultante em base64 novamente, e extrair os últimos 4 bytes; esses 4 bytes são o <em>salt</em> da senha codificada. Para ilustrar esse conceito, o <em>script</em> Perl a seguir pode ser usado para fazer a extração&#8201;&#8212;&#8201;crie o arquivo novo <code>/home/luke/scripts/getsalt.pl</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">#!/usr/bin/perl -w

my $hash=$ARGV[0];
# The hash is encoded as base64 twice:
use MIME::Base64;
$hash = decode_base64($hash);
$hash=~s/{SSHA}//;
$hash = decode_base64($hash);

# The salt length is four (the last four bytes).
$salt = substr($hash, -4);

# Split the salt into an array.
my @bytes = split(//,$salt);

# Convert each byte from binary to a human readable hexadecimal number.
foreach my $byte (@bytes) {
$byte = uc(unpack "H*", $byte);
print "$byte";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vamos recuperar o <em>hash</em> de senha do usuário <code>luke</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ldapsearch -x -LLL -H ldap://ldap.intnet/ -D 'cn=admin,dc=intnet' -b 'dc=intnet' -w 'rnpesr' 'uid=luke' userPassword | grep '^userPassword::' | awk '{print $NF}'
e1NTSEF9anFkZC80MW1BT3dFYVpkMFpvWUZzYk1xQTJyVlVMVlU=</pre>
</div>
</div>
<div class="paragraph">
<p>Executando o <em>script</em> <code>getsalt.pl</code>, podemos extrair o <em>salt</em> da senha. Note que o valor de saída está em hexadecimal.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ perl ~/scripts/getsalt.pl e1NTSEF9anFkZC80MW1BT3dFYVpkMFpvWUZzYk1xQTJyVlVMVlU= ; echo
D550B554</pre>
</div>
</div>
</li>
<li>
<p>De volta ao ataque de dicionário, vamos executá-lo usando o <code>hashcat</code>. Primeiro, temos que descobrir a qual código o <em>hash</em> SSHA do LDAP corresponde:</p>
<div class="literalblock">
<div class="content">
<pre>$ hashcat --help | grep SSHA
    111 | nsldaps, SSHA-1(Base64), Netscape LDAP SSHA      | HTTP, SMTP, LDAP Server
   1711 | SSHA-512(Base64), LDAP {SSHA512}                 | HTTP, SMTP, LDAP Server
  10300 | SAP CODVN H (PWDSALTEDHASH) iSSHA-1              | Enterprise Application Software (EAS)</pre>
</div>
</div>
<div class="paragraph">
<p>O código é, então, <code>111</code>. Quanto ao tipo de ataque:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hashcat --help | grep 'Attack Modes' -A8
- [ Attack Modes ] -

  # | Mode
 ===+======
  0 | Straight
  1 | Combination
  3 | Brute-force
  6 | Hybrid Wordlist + Mask
  7 | Hybrid Mask + Wordlist</pre>
</div>
</div>
<div class="paragraph">
<p>O ataque de dicionário, também conhecido como <em>straight mode</em> (<a href="https://hashcat.net/wiki/doku.php?id=dictionary_attack" class="bare">https://hashcat.net/wiki/doku.php?id=dictionary_attack</a>), possui código <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Falta apenas obter uma <em>wordlist</em> apropriada para executar o ataque. Procurando por termos como <em>"wordlist"</em>, <em>"password"</em> ou <em>"common"</em> no Google, é possível encontrar uma infinidade de páginas web dedicadas ao assunto, como por exemplo <a href="https://github.com/danielmiessler/SecLists/tree/master/Passwords" class="bare">https://github.com/danielmiessler/SecLists/tree/master/Passwords</a> . Iremos usar uma <em>wordlist</em> que alegadamente contém as 10 milhões de senhas mais comuns, que pode ser baixada na URL anteriormente mencionada ou solicitada ao instrutor. Note que, para um arquivo que contém apenas texto puro, seu tamanho é impressionante:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ wget -q https://github.com/danielmiessler/SecLists/raw/master/Passwords/Common-Credentials/10-million-password-list-top-1000000.txt</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ du -sh 10-million-password-list-top-1000000.txt
8,2M    10-million-password-list-top-1000000.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Tudo pronto! Vamos executar o ataque:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hashcat --force --hash-type 111 --attack-mode 0 --username hashes.txt 10-million-password-list-top-1000000.txt
hashcat (v3.30) starting...

(...)

Session..........: hashcat
Status...........: Exhausted
Hash.Type........: SSHA-1(Base64), nsldaps, Netscape LDAP SSHA
Hash.Target......: hashes.txt
Time.Started.....: Wed Nov 14 01:16:49 2018 (1 sec)
Time.Estimated...: Wed Nov 14 01:16:50 2018 (0 secs)
Input.Base.......: File (10-million-password-list-top-1000000.txt)
Input.Queue......: 1/1 (100.00%)
Speed.Dev.#1.....:  2591.6 kH/s (0.36ms)
Recovered........: 1/4 (25.00%) Digests, 1/4 (25.00%) Salts
Progress.........: 3999996/3999996 (100.00%)
Rejected.........: 36/3999996 (0.00%)
Restore.Point....: 999999/999999 (100.00%)
Candidates.#1....: vjq445 -&gt; vjht008
HWMon.Dev.#1.....: N/A

Started: Wed Nov 14 01:16:45 2018
Stopped: Wed Nov 14 01:16:51 2018</pre>
</div>
</div>
<div class="paragraph">
<p>Na máquina usada como exemplo (a velocidade pode variar de acordo com a velocidade da CPU/GPU disponível), o ataque aos quatro <em>hashes</em> disponíveis usando 10 milhões de senhas demorou&#8230;&#8203; 9 segundos. Como visualizado em <code>Speed.Dev.#1</code>, a velocidade de tentativas foi de 2591 kilo-<em>hashes</em> por segundo ou, em outras palavras, 2591000 <em>hashes</em> por segundo. Foi descoberto um <em>digest</em>, que podemos visualizar emitindo o mesmo comando com a <em>flag</em> <code>--show</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hashcat --force --hash-type 111 --attack-mode 0 --username hashes.txt 10-million-password-list-top-1000000.txt --show
luke:{SSHA}jqdd/41mAOwEaZd0ZoYFsbMqA2rVULVU:password</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente! Como era de se esperar, a senha fraca <code>password</code> do usuário <code>luke</code> foi descoberta usando o ataque de dicionário.</p>
</div>
</li>
<li>
<p>Mas, e as demais senhas? O usuário <code>han</code> e <code>sshca</code> possuem senhas relativamente mais complexas, mas sabemos que a senha do usuário <code>admin</code> é simples, <code>rnpesr</code>. Como essa <em>string</em> não consta do arquivo com 10 milhões de senhas usado no ataque anterior, ela não foi descoberta, no entanto.</p>
<div class="paragraph">
<p>Vamos executar um ataque de força-bruta contra essa senha. Para isso, alteraremos o modo de ataque do <code>hashcat</code> para <code>3</code>, e definiremos uma máscara igual a <code>?l?l?l?l?l?l</code>&#8201;&#8212;&#8201;senhas de até seis caracteres, apenas com caracteres de <code>[a-z]</code> minúsculos. Para aprender mais sobre a sintaxe de máscaras suportadas pelo <code>hashcat</code>, consulte sua página de manual ou <a href="https://hashcat.net/wiki/doku.php?id=mask_attack" class="bare">https://hashcat.net/wiki/doku.php?id=mask_attack</a> .</p>
</div>
<div class="paragraph">
<p>Ao trabalho:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hashcat --force --hash-type 111 --attack-mode 3 --username hashes.txt ?l?l?l?l?l?l
hashcat (v3.30) starting...

(...)

[s]tatus [p]ause [r]esume [b]ypass [c]heckpoint [q]uit =&gt; s</pre>
</div>
</div>
<div class="paragraph">
<p>Após a inicialização, a linha acima será mostrada. Podemos apertar os atalhos destacados entre colchetes para instruir o <code>hashcat</code> com ações durante o ataque. Apertando <code>s</code>, visualizamos o estado atual do ataque:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Session..........: hashcat
Status...........: Running
Hash.Type........: SSHA-1(Base64), nsldaps, Netscape LDAP SSHA
Hash.Target......: hashes.txt
Time.Started.....: Wed Nov 14 01:18:02 2018 (7 secs)
Time.Estimated...: Wed Nov 14 01:18:34 2018 (25 secs)
Input.Mask.......: ?l?l?l?l?l?l [6]
Input.Queue......: 1/1 (100.00%)
Speed.Dev.#1.....: 27956.2 kH/s (6.13ms)
Recovered........: 1/4 (25.00%) Digests, 1/4 (25.00%) Salts
Progress.........: 268409856/1235663104 (21.72%)
Rejected.........: 0/268409856 (0.00%)
Restore.Point....: 99072/456976 (21.68%)
Candidates.#1....: saufph -&gt; xqoxjk
HWMon.Dev.#1.....: N/A</pre>
</div>
</div>
<div class="paragraph">
<p>Observando a linha <code>Progress</code>, notamos que o ataque está 22,83% concluído. Aguardamos.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{SSHA}AZv4/v1spKXTHw5GOK1y+vQhPrnb7CzA:rnpesr</pre>
</div>
</div>
<div class="paragraph">
<p>Após algum tempo, a linha acima é mostrada na tela. O <code>hashcat</code> conseguiu quebrar a senha do usuário <code>admin</code>, descobrindo-a como sendo <code>rnpesr</code>. Aguardamos a conclusão do processo.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Session..........: hashcat
Status...........: Exhausted
Hash.Type........: SSHA-1(Base64), nsldaps, Netscape LDAP SSHA
Hash.Target......: hashes.txt
Time.Started.....: Wed Nov 14 01:18:02 2018 (30 secs)
Time.Estimated...: Wed Nov 14 01:18:32 2018 (0 secs)
Input.Mask.......: ?l?l?l?l?l?l [6]
Input.Queue......: 1/1 (100.00%)
Speed.Dev.#1.....: 27362.0 kH/s (6.14ms)
Recovered........: 2/4 (50.00%) Digests, 2/4 (50.00%) Salts
Progress.........: 1235663104/1235663104 (100.00%)
Rejected.........: 0/1235663104 (0.00%)
Restore.Point....: 456976/456976 (100.00%)
Candidates.#1....: sacxqg -&gt; xqqfqg
HWMon.Dev.#1.....: N/A

Started: Wed Nov 14 01:18:00 2018
Stopped: Wed Nov 14 01:18:33 2018</pre>
</div>
</div>
<div class="paragraph">
<p>Depois de 33 segundos, o ataque encontra-se 100% concluído. Um novo <em>digest</em> foi descoberto, como podemos visualizar com a <em>flag</em> <code>--show</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hashcat --force --hash-type 111 --attack-mode 3 --username hashes.txt ?l?l?l?l?l?l --show
luke:{SSHA}jqdd/41mAOwEaZd0ZoYFsbMqA2rVULVU:password
admin:{SSHA}AZv4/v1spKXTHw5GOK1y+vQhPrnb7CzA:rnpesr</pre>
</div>
</div>
<div class="paragraph">
<p>O <code>hashcat</code> reporta não somente a senha descoberta do usuário <code>admin</code>, bem como a senha do usuário <code>luke</code> descoberta na execução anterior. Isso ocorre porque o <code>hashcat</code> mantém o histórico de ataques realizados no diretório <code>~/.hashcat</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls -1 ~/.hashcat/
hashcat.dictstat
hashcat.potfile
kernels
sessions</pre>
</div>
</div>
<div class="paragraph">
<p>E assim, concluímos nossa busca por senhas fracas, via ataques de dicionário e força-bruta. O próximo passo, naturalmente, seria alterar o valor de senha dos usuários para um valor novo (bloqueando seu acesso), informá-los da nova senha e comunicar que devem alterar sua senha para uma combinação segura assim que possível.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_criação_da_vm_do_servidor_de_arquivos_nfs">4) Criação da VM do servidor de arquivos NFS</h3>
<div class="paragraph">
<p>Iremos implementar, agora, um servidor de arquivos simples para que os colaboradores da Intranet possam compartilhar arquivos e ter uma opção de backup emergencial para suas estações de trabalho. Como o ambiente que estamos simulando é inteiramente baseado em Linux, não há a necessidade de configurar uma solução interoperável com outros sistemas operacionais, como o Samba. Por isso, utilizaremos o NFS (<em>Network File System</em>), que é significativamente mais fácil de ser implementado.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O primeiro passo, assim como fizemos antes, é clonar a máquina <code>debian-template</code> e criar uma nova, que chamaremos de <code>nfs</code>. Essa máquina estará conectada a uma única rede <em>host-only</em>, com o mesmo nome que foi alocado para a interface de rede da máquina virtual <code>ns1</code>, configurada durante a sessão 2, que está conectada à DMZ. O IP da máquina será 10.0.42.3/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue a máquina e faça login como o usuário <code>root</code>. Em seguida, use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h nfs -i 10.0.42.3 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ip addr show label 'enp0s*' | grep 'inet ' | awk '{print $2,$NF}' ; hostname ; whoami
10.0.42.3/24 enp0s3
nfs
root</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_ajuste_das_regras_de_firewall">5) Ajuste das regras de firewall</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se você tentar acessar a máquina <code>nfs</code> recém-criada usando o SSH, a partir da máquina <code>client</code>, rapidamente perceberá que não é possível fazer o acesso:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh nfs
ssh: connect to host nfs port 22: Connection timed out</pre>
</div>
</div>
<div class="paragraph">
<p>Qual a razão disso? Após breve reflexão, fica claro que o problema reside no firewall. Vamos revisá-lo.</p>
</div>
</li>
<li>
<p>Logue na máquina <code>ns1</code> como o usuário <code>root</code>, como de costume. Tendo em vista que o acesso que desejamos fazer <strong>passa pelo</strong> firewall, devemos checar a <em>chain</em> FORWARD:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -L FORWARD -vn
Chain FORWARD (policy DROP 171 packets, 12318 bytes)
 pkts bytes target     prot opt in     out     source               destination
31432   74M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
    3   180 ACCEPT     tcp  --  *      enp0s3  10.0.42.0/24         0.0.0.0/0            multiport dports 80,443
    3   180 ACCEPT     tcp  --  *      enp0s3  192.168.42.0/24      0.0.0.0/0            multiport dports 80,443
    2   148 ACCEPT     udp  --  *      *       192.168.42.0/24      10.0.42.2            udp dpt:53
   68  4080 ACCEPT     tcp  --  *      *       192.168.42.0/24      10.0.42.2            multiport dports 22,389</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que liberamos o acesso SSH a partir da Intranet apenas para a máquina <code>ns2</code>, e nenhuma outra. Considerando que além da máquina <code>nfs</code> criaremos ainda outros servidores em nosso <em>datacenter</em> simulado, essa regra obviamente está inadequada. Vamos removê-la:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -D FORWARD -s 192.168.42.0/24 -d 10.0.42.2/32 -p tcp -m multiport --dports 22,389 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Em seu lugar, vamos criar duas regras: uma que reautoriza o acesso da Intranet ao servidor LDAP (que estava embutido na regra antiga), e outra que autoriza a Intranet a realizar SSH para qualquer máquina da DMZ:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 192.168.42.0/24 -d 10.0.42.2/32 -p tcp -m tcp --dport 389 -j ACCEPT</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 192.168.42.0/24 -d 10.0.42.0/24 -p tcp -m tcp --dport 22 -j ACCEPT</pre>
</div>
</div>
</li>
<li>
<p>Ainda temos que tratar do acesso da Intranet ao serviço NFS, que configuraremos na atividade a seguir. Para nossa sorte, a configuração do firewall para o NFS versão 4 (que utilizaremos neste curso) é significativamente mais fácil que as versões anteriores, bastando liberar o tráfego dos clientes para a porta 2049/TCP do servidor remoto (em nosso caso, a máquina <code>nfs</code>). A regra a seguir irá atender este requisito:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 192.168.42.0/24 -d 10.0.42.3/32 -p tcp -m tcp --dport 2049 -j ACCEPT</pre>
</div>
</div>
</li>
<li>
<p>Finalmente, salve as regras de firewall atuais:</p>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent save
[....] Saving netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save
done.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_configuração_do_servidor_de_arquivos_nfs_e_quotas_de_disco">6) Configuração do servidor de arquivos NFS e quotas de disco</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Queremos usar o servidor NFS para armazenar arquivos de usuários da Intranet, para compartilhamento e backup. Isso imediatamente suscita uma grande preocupação: imagine um cenário em que usuários querem armazenar muitos arquivos no servidor (de forma acidental ou maliciosa)&#8201;&#8212;&#8201;isso pode atrapalhar o uso de outros colaboradores, ou até mesmo chegar a encher a partição raiz (<code>/</code>) do sistema, causando instabilidade. Para evitar esse cenário, vamos criar uma partição dedicada para arquivos de usuário no diretório <code>/home</code> do servidor <code>nfs</code>, e também aplicar <em>quotas</em> de disco aos usuários.</p>
<div class="paragraph">
<p>Desligue a máquina <code>nfs</code> e adicione a ela um novo disco de 10 GB, usando a interface do Virtualbox. A seguir, formate o disco e adicione-o ao sistema LVM, criando um novo <em>volume group</em> <code>vg-home</code> com um único volume lógico <code>lv-home</code>, de forma análoga ao que fizemos na atividades (7) e (8) da sessão (1). Finalmente, formate esse volume em <code>ext4</code> e ative sua montagem automática durante o <em>boot</em> da máquina <code>nfs</code> no diretório <code>/home</code> com as opções <code>defaults,nosuid,nodev</code>.</p>
</div>
<div class="paragraph">
<p>Vamos ao trabalho. Após desligar a VM e adicionar o disco de 10 GB, acessamos a máquina <code>nfs</code> como o usuário <code>root</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
nfs
root</pre>
</div>
</div>
<div class="paragraph">
<p>O próximo passo é descobrir sob qual nome o disco foi detectado. Nesse caso, temos a vantagem de saber que o tamanho do disco novo, 10 GB, é diferente do disco preexistente.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dmesg | grep 'GiB'
[    1.585018] sd 1:0:0:0: [sdb] 20971520 512-byte logical blocks: (10.7 GB/10.0 GiB)
[    1.585187] sd 0:0:0:0: [sda] 16777216 512-byte logical blocks: (8.59 GB/8.00 GiB)</pre>
</div>
</div>
<div class="paragraph">
<p>Evidentemente, o disco <code>/dev/sdb</code> é o que acabamos de adicionar, portanto. Vamos formatá-lo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># fdisk /dev/sdb

Bem-vindo ao fdisk (util-linux 2.29.2).
As alterações permanecerão apenas na memória, até que você decida gravá-las.
Tenha cuidado antes de usar o comando de gravação.

A unidade não contém uma tabela de partição conhecida.
Criado um novo rótulo de disco DOS com o identificador de disco 0x3bc30929.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): o
Criado um novo rótulo de disco DOS com o identificador de disco 0x8a16601c.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): n
Tipo da partição
   p   primária (0 primárias, 0 estendidas, 4 livre)
   e   estendida (recipiente para partições lógicas)

Selecione (padrão p):

Usando resposta padrão p.
Número da partição (1-4, padrão 1):
Primeiro setor (2048-20971519, padrão 2048):
Último setor, +setores ou +tamanho{K,M,G,T,P} (2048-20971519, padrão 20971519):

Criada uma nova partição 1 do tipo "Linux" e de tamanho 10 GiB.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): t
Selecionou a partição 1
Tipo de partição (digite L para listar todos os tipos): 8e
O tipo da partição "Linux" foi alterado para "Linux LVM".</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): w
A tabela de partição foi alterada.
Chamando ioctl() para reler tabela de partição.
Sincronizando discos.</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, vamos criar o volume físico:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pvcreate /dev/sdb1
  Physical volume "/dev/sdb1" successfully created.</pre>
</div>
</div>
<div class="paragraph">
<p>O grupo de volumes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># vgcreate vg-home /dev/sdb1
  Volume group "vg-home" successfully created</pre>
</div>
</div>
<div class="paragraph">
<p>E, finalmente, o volume lógico:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lvcreate -l +100%FREE -n lv-home vg-home
  Logical volume "lv-home" created.</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos, agora, formatar o sistema de arquivos do LV:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkfs.ext4 /dev/mapper/vg--home-lv--home
mke2fs 1.43.4 (31-Jan-2017)
Creating filesystem with 2620416 4k blocks and 655360 inodes
Filesystem UUID: be99743c-7ca0-4144-8548-d7aab33a878b
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632

Allocating group tables: done
Writing inode tables: done
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done</pre>
</div>
</div>
<div class="paragraph">
<p>A seguir, sincronizar os arquivos do diretório <code>/home</code> atual com o LV recém-criado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mount /dev/mapper/vg--home-lv--home /mnt/</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># rsync -av /home/ /mnt/
sending incremental file list
./
aluno/
aluno/.bash_history
aluno/.bash_logout
aluno/.bashrc
aluno/.profile
aluno/.vimrc
luke/
luke/.bash_history
luke/.bash_logout
luke/.bashrc
luke/.profile
luke/scripts/
luke/scripts/sshsign_user.sh

sent 11,669 bytes  received 225 bytes  23,788.00 bytes/sec
total size is 10,787  speedup is 0.91</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># umount /mnt</pre>
</div>
</div>
<div class="paragraph">
<p>E, finalmente, configurar a montagem no <code>/etc/fstab</code> e montar o LV:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/fstab
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># tail -n1 /etc/fstab
/dev/mapper/vg--home-lv--home /home ext4  defaults,nosuid,nodev         0  2</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mount -a</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># df -h | sed -n '1p; /\/home/p'
Sist. Arq.                     Tam. Usado Disp. Uso% Montado em
/dev/mapper/vg--home-lv--home  9,8G   37M  9,3G   1% /home</pre>
</div>
</div>
</li>
<li>
<p>Agora, vamos instalar os pacotes para habilitar o compartilhamento de arquivos via NFS e <em>quotas</em> de disco. Como <code>root</code>, instale os pacotes <code>nfs-kernel-server</code>, <code>quota</code> e <code>quotatool</code>:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install nfs-kernel-server quota quotatool</pre>
</div>
</div>
</li>
<li>
<p>Vamos configurar primeiro o sistema de <em>quotas</em>. Edite a entrada do diretório <code>/home</code> no arquivo <code>/etc/fstab</code> e adicione as opções <code>usrquota,grpquota</code>, que ativam suporte a <em>quotas</em> por usuário e por grupo no sistema de arquivos.</p>
<div class="literalblock">
<div class="content">
<pre># nano /etc/fstab
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># tail -n1 /etc/fstab
/dev/mapper/vg--home-lv--home /home ext4  defaults,nosuid,nodev,usrquota,grpquota         0  2</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, remonte o sistema de arquivos e verifique se o sistema de <em>quotas</em> foi habilitado na partição.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mount -o remount /home</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mount | grep '/home'
/dev/mapper/vg--home-lv--home on /home type ext4 (rw,nosuid,nodev,relatime,quota,usrquota,grpquota,data=ordered)</pre>
</div>
</div>
<div class="paragraph">
<p>Crie os arquivos de configuração de <em>quotas</em> usando o comando <code>quotacheck</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># quotacheck -ugc /home/</pre>
</div>
</div>
<div class="paragraph">
<p>Pronto, o sistema de <em>quotas</em> está configurado. Iremos editar <em>quotas</em> de usuário e testar seu funcionamento mais à frente, após a configuração do NFS.</p>
</div>
</li>
<li>
<p>O próximo passo é configurar o serviço NFS&#8201;&#8212;&#8201;lembre-se que queremos disponibilizar compartilhamentos para arquivos de usuário, no diretório <code>/home</code> do sistema. Insira a linha a seguir no arquivo <code>/etc/exports</code>:</p>
<div class="literalblock">
<div class="content">
<pre># echo '/home 192.168.42.0/24(rw,async,no_subtree_check,root_squash)' &gt;&gt; /etc/exports</pre>
</div>
</div>
<div class="paragraph">
<p>A linha acima irá configurar a exportação o diretório <code>/home</code> para todas as máquinas da Intranet (faixa 192.168.42.0/24), em modo leitura-escrita, assíncrono (i.e. escritas ao disco do servidor remoto não precisam ter sido efetivadas para que o cliente receba confirmação), sem checagem de sub-árvores de montagem (consultar página de manual com <code>man 5 exports</code>) e desabilitando o mapeamento de UID do <code>root</code> da máquina remota no servidor local.</p>
</div>
<div class="paragraph">
<p>Para exportar o diretório, basta executar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># exportfs -a</pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, para visualizar quais diretórios estão sendo exportados, execute:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># showmount -e
Export list for nfs:
/home 192.168.42.0/24</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar nosso sistema de compartilhamento de arquivos via NFS e <em>quotas</em> de disco. Acesse a máquina <code>client</code> como o usuário <code>root</code>, crie um diretório <code>/remote</code> para ser o ponto de montagem NFS e monte o diretório compartilhado.</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
client
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mkdir /remote</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mount -t nfs 10.0.42.3:/home /remote</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -l /remote/
total 40
drwxr-xr-x 2 aluno aluno   4096 nov 13 17:01 aluno
-rw------- 1 root  root    8192 nov 14 01:49 aquota.group
-rw------- 1 root  root    8192 nov 14 01:49 aquota.user
drwx------ 2 root  root   16384 nov 14 01:46 lost+found
drwxr-xr-x 3 luke  sysadm  4096 nov 14 01:41 luke</pre>
</div>
</div>
</li>
<li>
<p>Um dos principais problemas em sistemas de compartilhamento de arquivos em ambientes Unix é o mapeamento de UIDs e GIDs&#8201;&#8212;&#8201;como garantir que os usuários de múltiplas máquinas remotas possuam os mesmos identificadores que os usuários existentes no servidor de arquivos? Felizmente, nosso sistema centralizado de autenticação usando LDAP resolve esse problema de forma transparente: todos os usuários possuem um valor de UID e GID consistente em todo o <em>datacenter</em>, já que as contas são gerenciadas em um ponto único.</p>
<div class="paragraph">
<p>Senão, vejamos: como o usuário <code>luke</code>, tente criar um arquivo novo dentro do ponto de montagem <code>/remote/luke</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ echo test &gt; /remote/luke/file</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat /remote/luke/file
test</pre>
</div>
</div>
<div class="paragraph">
<p>Funcionou perfeitamente! Uma vez que os valores de UID e GID do usuário <code>luke</code> são consistentes entre a máquina <code>client</code> e o servidor de arquivos <code>nfs</code>, não temos problemas de permissão.</p>
</div>
</li>
<li>
<p>E quanto ao usuário <code>root</code>? Será que o <code>root</code> local da máquina <code>client</code> possui acesso irrestrito aos arquivos compartilhados?</p>
<div class="literalblock">
<div class="content">
<pre>$ su -
Senha:
root@client:~#</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
client
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># echo test &gt; /remote/file
-su: /remote/file: Permissão negada</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># rm /remote/aquota.user
rm: não foi possível remover '/remote/aquota.user': Permissão negada</pre>
</div>
</div>
<div class="paragraph">
<p>Devido à utilização da opção <code>root_squash</code> no compartilhamento configurado via arquivo <code>/etc/exports</code> da máquina <code>nfs</code>, o mapeamento de UID do usuário <code>root</code> em máquinas remotas é desativado, efetivamente impedindo-o de alterar quaisquer arquivos.</p>
</div>
</li>
<li>
<p>Vamos testar o sistema de <em>quotas</em>. Na máquina <code>nfs</code>, como o usuário <code>root</code>, edite as <em>quotas</em> do usuário <code>luke</code> usando o comando <code>edquota</code>:</p>
<div class="literalblock">
<div class="content">
<pre># edquota -u luke</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>edquota</code> irá invocar um editor (indicado pela variável de ambiente <code>$EDITOR</code>) para que as <em>quotas</em> sejam ajustadas. Vamos editar os campos <em>soft</em> e <em>hard</em> da seção <em>block</em> do arquivo, ajustando limites de 100 MB e 200 MB, respectivamente&#8201;&#8212;&#8201;note que os valores devem ser informados em kilobytes. Pode-se, opcionalmente, também setar um limite para <em>inodes</em> que o usuário pode criar.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Disk quotas for user luke (uid 10000):
  Filesystem                   blocks       soft       hard     inodes     soft     hard
  /dev/mapper/vg--home-lv--home    32     100000     200000          8        0        0</pre>
</div>
</div>
<div class="paragraph">
<p>Para verificar as <em>quotas</em> de um sistema de arquivos, use o comando <code>repquota</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># repquota -u /home
*** Report for user quotas on device /dev/mapper/vg--home-lv--home
Block grace time: 7days; Inode grace time: 7days
                        Block limits                File limits
User            used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --      20       0       0              2     0     0
aluno     --      24       0       0              6     0     0
luke      --      32  100000  200000              8     0     0</pre>
</div>
</div>
<div class="paragraph">
<p>Para ativar as <em>quotas</em> em uma partição, utilize o comando <code>quotaon</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># quotaon -ug /home</pre>
</div>
</div>
</li>
<li>
<p>Acesse a máquina <code>client</code> como o usuário <code>luke</code>. Vamos tentar extrapolar o limite estabelecido pela <em>quota</em> no passo anterior.</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
luke</pre>
</div>
</div>
<div class="paragraph">
<p>O kernel do SO é um arquivo interessante a ser usado para esse teste, já que possui um tamanho razoável. Vamos copiá-lo sucessivas vezes para o diretório <code>/remote/luke</code> e verificar o que acontece:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ du -sh /boot/vmlinuz-4.9.0-8-amd64
4,1M    /boot/vmlinuz-4.9.0-8-amd64</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ for i in {1..100}; do cp /boot/vmlinuz-4.9.0-8-amd64 /remote/luke/vmlinuz-$i; done
cp: falha ao fechar '/remote/luke/vmlinuz-49': Disk quota exceeded
cp: falha ao fechar '/remote/luke/vmlinuz-50': Disk quota exceeded
cp: falha ao fechar '/remote/luke/vmlinuz-51': Disk quota exceeded
(...)
cp: falha ao fechar '/remote/luke/vmlinuz-98': Disk quota exceeded
cp: falha ao fechar '/remote/luke/vmlinuz-99': Disk quota exceeded
cp: falha ao fechar '/remote/luke/vmlinuz-100': Disk quota exceeded</pre>
</div>
</div>
<div class="paragraph">
<p>Note que após 48 cópias de arquivo, o sistema reporta a <em>quota</em> de disco como excedida, e o usuário não pode mais escrever na partição. De fato, checando o estado da <em>quota</em> de disco com o comando <code>repquota</code> na máquina <code>nfs</code>, temos que:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
nfs
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># repquota -u /home/
*** Report for user quotas on device /dev/mapper/vg--home-lv--home
Block grace time: 7days; Inode grace time: 7days
                        Block limits                File limits
User            used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --      20       0       0              2     0     0
aluno     --      24       0       0              6     0     0
luke      +-  200000  100000  200000  6days     108     0     0</pre>
</div>
</div>
<div class="paragraph">
<p>Temos, portanto, que nosso esquema de <em>quotas</em> está funcionando como esperado. Não se esqueça de apagar os diversos arquivos <code>vmlinuz*</code> que criamos, para liberar espaço no disco novamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># rm /home/luke/vmlinuz-*</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Observe que apenas os usuários <code>aluno</code> e <code>luke</code> possuem pastas no diretório <code>/home</code> compartilhado pela máquina <code>nfs</code>. Isso se deve ao fato de que apenas esses usuários haviam feito acesso local à máquina <code>nfs</code> até aquele momento&#8201;&#8212;&#8201;lembre-se que o arquivo de configuração <code>/usr/share/pam-configs/mkhomedir</code> que aplicamos ao PAM cria diretórios <em>home</em> apenas quando o usuário faz acesso à máquina pela primeira vez. Como consequência, o usuário <code>han</code>, para citar um exemplo, não possui uma pasta no servidor de arquivos.</p>
</div>
<div class="paragraph">
<p>Em produção, seria interessante que a pasta compartilhada do usuário fosse criada assim que este fosse adicionado à base LDAP, juntamente com o comando <code>ldapadduser</code>, por exemplo. Um <em>script</em> shell seria ideal para resolver essa situação. Claro, é possível que nem todos os novos usuários criados na base LDAP devam ter uma pasta nesse servidor, o que pode complicar sua configuração.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_7_uso_de_acls_localmente">7) Uso de ACLs localmente</h3>
<div class="paragraph">
<p>Imagine a seguinte situação, agora: o usuário <code>luke</code> quer criar um arquivo novo, sigiloso, e dar permissão para que <code>han</code> possa visualizá-lo. Ora, com as permissões padrão disponíveis em um sistema Linux, quais são nossas opções?</p>
</div>
<div class="paragraph">
<p>Sabemos que, ao criar o arquivo, o usuário-dono será <code>luke</code> e o grupo-dono será <code>sysadm</code>. Se <code>luke</code> altera o grupo-dono do arquivo para <code>fwadm</code> e <code>chmod</code> de <code>640</code>, apesar de a permissão objetivada para <code>han</code> ser garantida, todos os outros membros do grupo <code>fwadm</code> também poderão visualizar o arquivo, que não é o que queremos. Se garante-se a permissão de <code>644</code>, não só <code>han</code> como qualquer outro usuário pode visualizar o arquivo. Finalmente, a alternativa final que seria adicionar <code>han</code> ao grupo <code>sysadm</code> pode não ser desejável ou aceitável do ponto de vista administrativo. O que fazer?</p>
</div>
<div class="paragraph">
<p>O uso de ACLs (<em>Access Control Lists</em>) é especialmente adequado para esse tipo de situação, quando precisamos configurar permissões de arquivos e diretórios de forma granular. Com o uso de ACLs, é possível definir permissões customizadas para usuários e grupos diferentes dos donos do arquivo/diretório original, solucionando problemas de permissionamento para os quais o sistema tradicional de permissões Unix é inadequado.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acesse a máquina <code>nfs</code> como o usuário <code>root</code>. Para consultar e ajustar ACLs localmente, basta instalar o pacote <code>acl</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
nfs
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get install acl</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar o funcionamento de ACLs localmente, usando os usuários <code>luke</code> e <code>han</code>. Acesse a máquina <code>nfs</code> como o usuário <code>luke</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami ; pwd
nfs
luke
/home/luke</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, crie o arquivo novo <code>~/teste</code>, com qualquer conteúdo. Em seguida, consulte suas ACLs atuais.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ echo oi &gt; teste</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ getfacl teste
# file: teste
# owner: luke
# group: sysadm
user::rw-
group::r--
other::r--</pre>
</div>
</div>
</li>
<li>
<p>Imaginemos que o arquivo criado na atividade anterior é especialmente sigiloso, devendo ser visualizado apenas pelo usuário <code>han</code> e seu dono, <code>luke</code>. Primeiro, retire as permissões do grupo e de outros:</p>
<div class="literalblock">
<div class="content">
<pre>$ chmod 600 ~/teste</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, use ACLs para dar permissão de leitura a <code>han</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ setfacl -m u:han:r ~/teste</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique as permissões Unix tradicionais&#8201;&#8212;&#8201;observe que ao final da coluna de permissionamento do <code>ls</code> vemos o caractere <code>+</code>, que indica que o arquivo possui permissões estendidas na forma de ACLs.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls -ld /home/luke/teste
-rw-r-----+ 1 luke sysadm 3 nov  1 18:27 /home/luke/teste</pre>
</div>
</div>
<div class="paragraph">
<p>Consulte novamente as ACLs do arquivo, verificando que a configuração desejada foi aplicada.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ getfacl teste
# file: teste
# owner: luke
# group: sysadm
user::rw-
user:han:r--
group::---
mask::r--
other::---</pre>
</div>
</div>
</li>
<li>
<p>Terá funcionado? Vamos ver. Como o usuário <code>aluno</code>, tente visualizar o conteúdo do arquivo <code>/home/luke/teste</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ whoami
aluno</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat /home/luke/teste
cat: /home/luke/teste: Permissão negada</pre>
</div>
</div>
<div class="paragraph">
<p>E como <code>han</code>? Vamos ver:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami
han</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat /home/luke/teste
oi</pre>
</div>
</div>
</li>
<li>
<p>Como <code>luke</code>, vamos remover a ACL de leitura do usuário <code>han</code> e testar:</p>
<div class="literalblock">
<div class="content">
<pre>$ whoami
luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ setfacl -x u:han ~/teste</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su - han
Senha:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami
han</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat /home/luke/teste
cat: /home/luke/teste: Permissão negada</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito! Lembre-se que também podemos configurar ACLs para grupos através do caractere <code>g</code>, o que não foi testado nesta atividade.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_8_uso_de_acls_via_nfs">8) Uso de ACLs via NFS</h3>
<div class="paragraph">
<p>A atividade anterior, apesar de interessante, é pouco prática quando consideramos nossa configuração atual: se ACLs podem apenas ser manipuladas localmente mas estamos mantendo nossos arquivos compartilhados via rede com NFS, então toda vez que um usuário quiser alterar ACLs ele terá que fazer um acesso local à máquina <code>nfs</code>? Não é razoável fazermos isso. De fato, tente fazer a alteração de ACLs a partir da máquina <code>client</code> como o usuário <code>luke</code>&#8201;&#8212;&#8201;lembre-se: assim como fizemos na máquina <code>nfs</code>, será necessário instalar o pacote <code>acl</code> antes de realizar este teste:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ setfacl -m u:han:rw /remote/luke/teste
setfacl: /remote/luke/teste: Operação não suportada</pre>
</div>
</div>
<div class="paragraph">
<p>Com efeito, ACLs POSIX não são suportadas diretamente via <code>setfacl</code> em <em>mounts</em> NFS.</p>
</div>
<div class="paragraph">
<p>Por outro lado, <em>mounts</em> NFS versão 4 possuem suporte a ACLs&#8201;&#8212;&#8201;de fato, a um conjunto de permissões ainda mais granulares e expressivas que as ACLs POSIX padrão. Mas primeiro, temos que responder à pergunta: nosso compartilhamento atual está em qual versão? Vamos ver:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ mount | grep '/home' | grep -o 'vers=[0-9\.]*'
vers=4.2</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente, estamos usando a versão 4.2, o que deve ser suficiente. Os comandos para visualização e edição de ACLs NFSv4 não são os mesmos que utilizamos até agora, no entanto&#8201;&#8212;&#8201;vamos instalá-los.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acesse a máquina <code>client</code> como o usuário <code>root</code> e instale o pacote <code>nfs4-acl-tools</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
client
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get install nfs4-acl-tools</pre>
</div>
</div>
</li>
<li>
<p>Agora sim, vamos testar o funcionamento de ACLs com a pasta compartilhada via NFS. Acesse como o usuário <code>luke</code>; para tornar o uso corriqueiro dessa pasta compartilhada mais conveniente, crie um link simbólico com o nome <code>remote</code> em seu diretório <em>home</em>.</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami ; pwd
client
luke
/home/luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ln -s /remote/luke/ ~/remote</pre>
</div>
</div>
</li>
<li>
<p>Consulte as ACLs NFSv4 do arquivo criado na atividade anterior:</p>
<div class="literalblock">
<div class="content">
<pre>$ nfs4_getfacl ~/remote/teste
A::OWNER@:rwatTcCy
A::GROUP@:tcy
A::EVERYONE@:tcy</pre>
</div>
</div>
<div class="paragraph">
<p>O formato de representação de permissões NFSv4 é bastante diferente do que estamos acostumados&#8201;&#8212;&#8201;muitas opções e controles adicionais são suportados. Nesta atividade iremos trabalhar apenas com as permissões mais usuais, <code>rwx</code>, mas a página de manual <code>man 5 nfs4_acl</code> possui uma documentação bastante completa sobre as possibilidades de uso desse sistema. Em especial, a seção <em>ACE PERMISSIONS</em> é recomendada para entender o formado do <em>output</em> acima.</p>
</div>
<div class="paragraph">
<p>Como um exemplo, vamos analisar em detalhe a ACE (<em>Access Control Entry</em>) <code>A::OWNER@:rwatTcCy</code>:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>A</code>: tipo da ACE; pode ser <code>A</code> (<em>allow</em>), <code>D</code> (<em>deny</em>), <code>U</code> (<em>audit</em>, usada para configurar log de acessos) e <code>L</code> (<em>alarm</em>, para gerar alarmes de sistema em caso de acesso).</p>
</li>
<li>
<p><code>::</code>: o segundo campo, neste caso vazio, define as <em>flags</em> da ACE; pode ser utilizado para indicar ACEs aplicáveis a grupos, configurações de herança da ACE para diretórios e arquivos-filho, ou <em>flags</em> administrativas para controlar eventos de log e alarme.</p>
</li>
<li>
<p><code>OWNER@</code>: define o <em>principal</em> ao qual se aplica a ACE corrente; pode ser um usuário, grupo ou uma de três ACEs especiais, <code>OWNER@</code>, <code>GROUP@</code> e <code>EVERYONE@</code>, funcionalmente equivalentes às suas contrapartes POSIX.</p>
</li>
<li>
<p><code>rwatTcCy</code>: permissões definidas pela ACE; no caso, temos definidas:</p>
<div class="ulist">
<ul>
<li>
<p><code>r</code>: permissão de leitura para arquivos, ou listagem de diretórios.</p>
</li>
<li>
<p><code>w</code>: permissão de escrita para arquivos, ou criação de novos arquivos em diretórios.</p>
</li>
<li>
<p><code>a</code>: <em>append</em> de dados em arquivos (escrever ao final), ou criar novos subdiretórios em diretórios.</p>
</li>
<li>
<p><code>t</code>: ler atributos do arquivo/diretório.</p>
</li>
<li>
<p><code>T</code>: escrever atributos do arquivo/diretório.</p>
</li>
<li>
<p><code>c</code>: ler ACLs NFSv4 do arquivo/diretório.</p>
</li>
<li>
<p><code>C</code>: escrever ACLs NFSv4 do arquivo/diretório.</p>
</li>
<li>
<p><code>y</code>: autorizar clientes a usar I/O síncrono com o servidor.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Vamos configurar uma ACL NFSv4 de leitura do arquivo para o usuário <code>han</code>, assim como fizemos anteriormente.</p>
<div class="literalblock">
<div class="content">
<pre>$ nfs4_setfacl -a A::han@intnet:rtcy ~/remote/teste</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos ver como ficaram as ACEs do arquivo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ nfs4_getfacl ~/remote/teste
A::OWNER@:rwatTcCy
A::10002:rtcy
A::GROUP@:tcy
A::EVERYONE@:tcy</pre>
</div>
</div>
<div class="paragraph">
<p>Note que o nome de usuário <code>han@intnet</code> foi mapeado para o UID <code>10002</code>&#8201;&#8212;&#8201;que é consistente entre todas as máquinas do <em>datacenter</em> graças à integração com o LDAP que fizemos na sessão 3. Verifique a correspondência do UID:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ getent passwd han
han:*:10002:10002:han:/home/han:/bin/bash</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar? Acesse como o usuário <code>aluno</code> e tente exibir o conteúdo do arquivo <code>/remote/luke/teste</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ su - aluno
Senha:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami
aluno</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat /remote/luke/teste
cat: /remote/luke/teste: Permissão negada</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, teste com o usuário <code>han</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su - han
Senha:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami
han</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat /remote/luke/teste
oi</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente, tudo funcionando a contento.</p>
</div>
</li>
<li>
<p>Como remover uma ACL NFSv4? É simples:</p>
<div class="literalblock">
<div class="content">
<pre>$ nfs4_setfacl -x A::han@intnet:rtcy ~/remote/teste</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ nfs4_getfacl ~/remote/teste
A::OWNER@:rwatTcCy
A::10002:rtcy
A::GROUP@:tcy
A::EVERYONE@:tcy</pre>
</div>
</div>
<div class="paragraph">
<p>Ué, não funcionou. Para deletar ACEs, temos que especificá-las <strong>exatamente</strong> no mesmo formato da linha reportada pelo comando <code>nfs4_getfacl</code>, ou usando o índice numérico da regra. Vamos tentar novamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ nfs4_setfacl -x A::10002:rtcy ~/remote/teste</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ nfs4_getfacl ~/remote/teste
A::OWNER@:rwatTcCy
A::GROUP@:tcy
A::EVERYONE@:tcy</pre>
</div>
</div>
<div class="paragraph">
<p>Agora sim, perfeito. Vamos verificar que a remoção da ACE surtiu efeito:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su - han
Senha:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami
han</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat /remote/luke/teste
cat: /remote/luke/teste: Permissão negada</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_9_controle_granular_de_permissões_via_sudo">9) Controle granular de permissões via sudo</h3>
<div class="paragraph">
<p>Para todas as ações privilegiadas que precisamos tomar até aqui, sempre usamos o comando <code>su</code> para nos tornarmos o usuário <code>root</code>, e então efetuamos a instalação de pacotes, adição de usuários ou criação de arquivos de configuração. Mas, como fica essa situação em um ambiente de <em>datacenter</em> como o que estamos simulando? Seria interessante passar a senha do usuário <code>root</code> para os usuários <code>luke</code> e <code>han</code> (e outros que viermos a criar), permitindo que tomem quaisquer ações nas máquinas?</p>
</div>
<div class="paragraph">
<p>O <code>sudo</code> (<em>Super User DO</em>) é um comando que permite que usuários comuns obtenham privilégios de outro usuário, em geral o <code>root</code>, para executar tarefas específicas dentro do sistema de maneira segura e controlável pelo administrador. Assim, podemos delimitar que um determinado usuário ou grupo pode executar apenas um pequeno conjunto de comandos dentro de um servidor específico. Como o <code>sudo</code> é compatível com <em>hostnames</em> e endereços IP, é possível utilizar o mesmo arquivo em todas as máquinas do parque, facilitando tremendamente o esforço de configuração.</p>
</div>
<div class="paragraph">
<p>Para ilustrar esse cenário, vamos solucionar dois exemplos hipotéticos:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>A colaboradora <code>leia</code> acaba de se juntar à equipe de <code>han</code>, o grupo <code>fwadm</code> em nosso sistema LDAP. Imagine que ela ficará responsável por editar regras no firewall de borda, a máquina <code>ns1</code>. Mas, por estar começando agora na empresa, <code>han</code> quer restringir o conjunto de comandos que <code>leia</code> pode executar na máquina, liberando apenas a edição do firewall via <code>iptables</code>. Sua senha será <code>seg10leia</code>. Nas demais máquinas (<code>ns2</code> e <code>nfs</code>) <code>leia</code> não deve ter qualquer acesso especial, apenas como um usuário regular.</p>
</li>
<li>
<p>O colaborador <code>chewie</code> foi contratado para auxiliar na manutenção da base LDAP da empresa. Para desempenhar suas tarefas, iremos colocá-lo em um novo grupo <code>ldapadm</code>. Os membros desse grupo devem ter acesso aos principais comandos de edição do LDAP (criação, modificação e deleção de usuários e grupos) na máquina <code>ns2</code>. Sua senha será <code>seg10chewie</code>. Nas demais máquinas (<code>ns1</code> e <code>nfs</code>) <code>chewie</code> não deve ter qualquer acesso especial, apenas como um usuário regular.</p>
</li>
<li>
<p>Os usuários atuais, <code>luke</code> e <code>han</code>, terão permissão para executar qualquer comando como o usuário <code>root</code>, em qualquer máquina.</p>
</li>
<li>
<p>Observe que temos controles alheios ao <code>sudo</code> já aplicados que irão restringir o acesso de certos usuários&#8201;&#8212;&#8201;por exemplo, apenas membros do grupo <code>fwadm</code> conseguem fazer login na máquina <code>ns1</code> devido à configuração do <code>nslcd</code> que realizamos na atividade (13) da sessão (3).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Vamos solucionar esses problemas?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, devemos criar os usuários e grupos&#8201;&#8212;&#8201;vamos começar com <code>leia</code>. Como <code>root</code>, na máquina <code>ns2</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapadduser leia fwadm
Successfully added user leia to LDAP
Successfully set password for user leia</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapaddusertogroup leia fwadm
Successfully added user leia to group cn=fwadm,ou=Groups,dc=intnet</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsetpasswd leia
Changing password for user uid=leia,ou=People,dc=intnet
New Password:
Retype New Password:
Successfully set password for user uid=leia,ou=People,dc=intnet</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, <code>chewie</code>. Lembre-se que no caso dele temos também que adicionar um novo grupo, <code>ldapadm</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapaddgroup ldapadm
Successfully added group ldapadm to LDAP</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapadduser chewie ldapadm
Successfully added user chewie to LDAP
Successfully set password for user chewie</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapaddusertogroup chewie ldapadm
Successfully added user chewie to group cn=ldapadm,ou=Groups,dc=intnet</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsetpasswd chewie
Changing password for user uid=chewie,ou=People,dc=intnet
New Password:
Retype New Password:
Successfully set password for user uid=chewie,ou=People,dc=intnet</pre>
</div>
</div>
<div class="paragraph">
<p>Fácil, não é mesmo?</p>
</div>
</li>
<li>
<p>Como já instalamos o <code>sudo</code> na máquina <code>debian-template</code> na sessão 1, o comando deve estar diponível no <code>$PATH</code>:</p>
<div class="literalblock">
<div class="content">
<pre># which sudo
/usr/bin/sudo</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos testar? Edite o arquivo <code>/etc/sudoers</code> e autorize o usuário <code>luke</code> a usar o comando <code>/bin/grep</code> como o usuário <code>root</code>. Edite o arquivo com:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># visudo
(...)</pre>
</div>
</div>
<div class="paragraph">
<p>Insira a linha <code>luke ALL=/bin/grep</code> abaixo da entrada do usuário <code>root</code> na seção <em>User privilege specification</em>, como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># grep -A2 'User privilege specification' /etc/sudoers
# User privilege specification
root    ALL=(ALL:ALL) ALL
luke    ALL=(root)    /bin/grep</pre>
</div>
</div>
<div class="paragraph">
<p>Como o usuário <code>luke</code>, tente usar o comando <code>grep</code> com o <code>sudo</code> para visualizar um arquivo restrito, como o <code>/etc/shadow</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># su - luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ whoami
luke</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo grep root /etc/shadow

Presumimos que você recebeu as instruções de sempre do administrador
de sistema local. Basicamente, resume-se a estas três coisas:

    #1) Respeite a privacidade dos outros.
    #2) Pense antes de digitar.
    #3) Com grandes poderes vêm grandes responsabilidades.

[sudo] senha para luke:
root:$6$s7Gt1cd.$UXQf67CVYxR7HP..h2wvhOx4nOtBT7do28R1uChYdMpZc.uLi43OKdtentrWD2zSTKv9EyB7Bdqcpwr6nAlNo.:17848:0:99999:7:::</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, tente executar um comando não-autorizado, como o <code>cat</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo cat /etc/shadow
Sinto muito, usuário luke não tem permissão para executar "/bin/cat /etc/shadow" como root em ns2.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito, nosso teste inicial funcionou com sucesso. Remova a linha referente ao usuário <code>luke</code> no arquivo <code>/etc/sudoers</code>, e vamos prosseguir.</p>
</div>
</li>
<li>
<p>Queremos controlar os comandos utilizados nos servidores do <em>datacenter</em>, que até o momento são as máquinas <code>ns1</code>, <code>ns2</code> e <code>nfs</code>.</p>
<div class="paragraph">
<p>Tecnicamente, seria possível configurar o <code>sudo</code> em cada um dos servidores&#8201;&#8212;&#8201;uma vez que as regras para a usuária <code>leia</code> são específica para a máquina <code>ns1</code> e as do usuário <code>chewie</code> se aplicam à máquina <code>ns2</code>&#8201;&#8212;&#8201;mas não faremos isso. Imagine que, ao invés de três máquinas, nosso <em>datacenter</em> tivesse centenas de VMs: seria factível controlar as regras de <code>sudo</code> localmente em cada um dos servidores? É evidente que não.</p>
</div>
<div class="paragraph">
<p>Temos algumas opções para configurar o <code>sudo</code> de forma coordenada entre múltiplos servidores. A gestão de configuração de servidores, usando ferramentas como o Puppet, Chef ou Ansible (que veremos na sessão seguinte) é um dos métodos mais modernos e eficientes de atingir esse objetivo.</p>
</div>
<div class="paragraph">
<p>Assim sendo, ao invés de desenvolver uma solução inadequada para o problema de configuração do <code>sudo</code> neste momento, iremos fazer uma breve pausa nessa tarefa. Na próxima sessão, aprenderemos as bases do Ansible e, com isso, a solução do problema ficará bem mais fácil. Nos vemos em breve!</p>
</div>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_5_gestão_de_configuração">Sessão 5: Gestão de configuração</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Algo que já deve ter ficado claro, a este ponto, é que a configuração manual de múltiplas máquinas é um processo tedioso, demorado, e ainda oferece o risco de configuração incorreta por parte do administrador durante o processo. Fica ainda mais evidente a dimensão do problema quando observamos que nosso <em>datacenter</em> simulado possui até o momento apenas três servidores&#8201;&#8212;&#8201;imagine o tamanho do problema se tivéssemos dezenas ou centenas de VMs!</p>
</div>
<div class="paragraph">
<p>As ferramentas de gestão de configuração oferecem uma alternativa: através delas, podemos ter um processo de implementação sistemática de mudanças em um (ou vários) sistemas de forma a manter sua integridade. A ideia básica por trás dessas ferramentas é a gestão de <strong>estados desejados</strong>: criamos artefatos de configuração que definem um estado-alvo para um grupo de sistemas, e o sistema de gestão de configuração se encarrega de checar se esse estado está atendido&#8201;&#8212;&#8201;caso positivo, nada precisa ser feito; e, caso negativo, as alterações de configuração previstas nos artefatos de configuração serão aplicadas nos sistemas.</p>
</div>
<div class="paragraph">
<p>Outro conceito central é o <strong>comportamento idempotente</strong> desse tipo de ferramenta: mesmo com aplicações sucessivas dos artefatos de configuração, o sistema se encarrega de verificar se o estado-alvo está atendido, não reaplicando mudanças desnecessárias. Podemos citar também como vantagens desses sistemas de gestão a existência de <em>frameworks</em> de automação que facilitam o trabalho do administrador, uso de <em>templates</em> para aproveitar e customizar configuração entre diferentes grupos de máquinas, e grande extensibilidade de capacidades através de módulos e <em>plugins</em> de terceiros.</p>
</div>
<div class="paragraph">
<p>Nesta sessão iremos trabalhar com o Ansible, uma ferramenta de gestão de configuração <em>open-source</em> criada por Michael DeHaan em 2012 e atualmente mantida pela Red Hat. O Ansible possibilita também a automatização de provisionamento de software e <em>deployment</em> de aplicações, conectando-se via SSH ou PowerShell aos servidores-alvo em um arquitetura que dispensa a instalação de agentes (<em>agentless</em>). Usando o Ansible, iremos solucionar a gestão centralizada do arquivo <code>/etc/sudoers</code>, problema que encontramos no final da sessão anterior. Finalmente, iremos usar a ferramenta de controle de versão Git para gerenciar as mudanças que faremos nos conjuntos de <em>scripts</em> e artefatos do Ansible ao longo das sessões.</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão_4">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>A figura abaixo mostra a topologia de rede que será utilizada nesta sessão, com as máquinas relevantes em destaque.</p>
</div>
<div id="img-topologia5" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/Topologia_SEG10_S5.png" alt="Topologia SEG10 S5">
</div>
<div class="title">Figure 29. Topologia de rede desta sessão</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Praticamente não há mudanças em relação à topologia da sessão anterior&#8201;&#8212;&#8201;a única diferença é que a máquina <code>nfs</code> possuirá um novo <em>alias</em>, <code>git</code>, já que atuará como servidor da solução de controle de versão Git. Vamos ajustar o DNS: acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo de zonas <code>/etc/nsd/zones/intnet.zone</code>, inserindo uma entrada CNAME para a máquina <code>nfs</code>, como se segue. <strong>Não se esqueça</strong> de incrementar o valor do serial no topo do arquivo!</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/intnet.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep git /etc/nsd/zones/intnet.zone
git     IN    CNAME             nfs</pre>
</div>
</div>
<div class="paragraph">
<p>Assine o arquivo de zonas usando o <em>script</em> criado anteriormente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash /root/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 0 rrsets, 0 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a criação das entradas usando o comando <code>dig</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig git.intnet +short
nfs.intnet.
10.0.42.3</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_2_instalação_e_configuração_inicial_do_ansible">2) Instalação e configuração inicial do Ansible</h3>
<div class="paragraph">
<p>Um dos aspectos mais interessantes do Ansible é sua simplicidade&#8201;&#8212;&#8201;dependendo apenas do interpretador Python para operar (o qual já vem instalado no sistema-base do Debian), sua instalação é bastante simples. Outro fator relevante: como o sistema dispensa a instalação de agentes, não é necessário criar um servidor dedicado para usar o Ansible, de forma que iremos usar a máquina <code>client</code> como um conveniente ponto de partida para os logins remotos.</p>
</div>
<div class="paragraph">
<p>Vamos, no entanto, criar um usuário específico para o Ansible no servidor LDAP, gerenciando suas permissões de forma granular via <code>sudo</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acesse a máquina <code>ns2</code> como o usuário <code>root</code> e crie um usuário para o Ansible, membro dos grupos <code>setup</code> (primário) e <code>fwadm</code>, com senha <code>seg10ansible</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapadduser ansible setup
Successfully added user ansible to LDAP
Successfully set password for user ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapaddusertogroup ansible setup
Successfully added user ansible to group cn=setup,ou=Groups,dc=intnet</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapaddusertogroup ansible fwadm
Successfully added user ansible to group cn=fwadm,ou=Groups,dc=intnet</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ldapsetpasswd ansible
Changing password for user uid=ansible,ou=People,dc=intnet
New Password:
Retype New Password:
Successfully set password for user uid=ansible,ou=People,dc=intnet</pre>
</div>
</div>
</li>
<li>
<p>Agora, acesse a máquina <code>client</code> como o usuário <code>root</code> e instale o Ansible seguindo os passos abaixo. Todas as instruções a seguir referenciam o passo-a-passo da documentação oficial do Ansible, acessível em <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#latest-releases-via-apt-debian" class="bare">https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#latest-releases-via-apt-debian</a> .</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
client
root</pre>
</div>
</div>
<div class="paragraph">
<p>Primeiro, adicione o repositório de pacotes do Ansible à lista de fontes do <code>apt-get</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># echo "deb http://ppa.launchpad.net/ansible/ansible/ubuntu trusty main" &gt; /etc/apt/sources.list.d/ansible.list</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, adicione à lista de chaves confiáveis para instalação de pacotes a <em>pubkey</em> dos mantenedores do pacote do Ansible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 93C4A3FD7BB9C367
Executing: /tmp/apt-key-gpghome.UOSyzarqGQ/gpg.1.sh --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 93C4A3FD7BB9C367
gpg: key 93C4A3FD7BB9C367: public key "Launchpad PPA for Ansible, Inc." imported
gpg: Total number processed: 1
gpg:               imported: 1</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, basta atualizar a lista de pacotes disponíveis nos repositórios remotos e instalar o Ansible usando o <code>apt-get</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get update</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get install ansible</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_execução_de_comandos_simples">3) Execução de comandos simples</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Começaremos utilizando as funções mais básicas do Ansible. Antes de mais nada, no entanto, precisamos configurar o acesso para os diversos servidores do <em>datacenter</em> simulado usando o sistema de autenticação LDAP/SSH-CA.</p>
<div class="paragraph">
<p>Acesse a máquina <code>client</code> como o usuário <code>ansible</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami ; pwd
client
ansible
/home/ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, use o script <code>~/scripts/sshsign_user.sh</code> para assine um par de chaves e conseguir logar nos servidores:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bash ~/scripts/sshsign_user.sh
Signing ~/.ssh/id_rsa.pub key...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Como estabelecido, o Ansible consegue trabalhar com múltiplos sistemas em uma infraestrutura ao mesmo tempo&#8201;&#8212;&#8201;para isso, ele seleciona conjuntos de máquinas em seu <strong>inventário</strong>. O inventário é um arquivo texto em formato INI ou YAML que lista as máquinas e grupos a serem gerenciados.</p>
<div class="paragraph">
<p>Crie o arquivo novo <code>/home/ansible/hosts</code> com o seguinte conteúdo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ nano ~/hosts
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat hosts
[srv]
ns1
ns2
nfs</pre>
</div>
</div>
<div class="paragraph">
<p>No arquivo acima criamos um único grupo, <code>srv</code>, contendo todos os servidores do <em>datacenter</em> simulado criados até aqui.</p>
</div>
</li>
<li>
<p>Vamos testar? Execute um comando simples em todas as máquinas gerenciadas pelo Ansible:</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/hosts srv -m shell -a 'hostname --fqdn ; whoami'
ns2 | CHANGED | rc=0 &gt;&gt;
ns2.intnet
ansible

ns1 | CHANGED | rc=0 &gt;&gt;
ns1.intnet
ansible

nfs | CHANGED | rc=0 &gt;&gt;
nfs.intnet
ansible</pre>
</div>
</div>
<div class="paragraph">
<p>O que aconteceu? Vejamos:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Com <code>ansible</code>, invocamos o Ansible para executar uma única tarefa, com parâmetros passados diretamente via linha de comando.</p>
</li>
<li>
<p>Depois, <code>-i ~/hosts</code> define o arquivo de inventário a ser usado, <code>/home/ansible/hosts</code>.</p>
</li>
<li>
<p>O grupo <code>srv</code> é indicado a seguir, falando para o Ansible qual dos grupos disponíveis no arquivo de inventário será o alvo dos comandos que se seguem.</p>
</li>
<li>
<p>Com <code>-m shell</code> carregamos o módulo <em>shell</em> do Ansible, que permite execução de comandos diretamente pelo interpretador <code>/bin/sh</code> (ou outro à sua escolha) nas máquinas remotas.</p>
</li>
<li>
<p>Finalmente, <code>-a 'hostname --fqdn ; whoami'</code> indica quais comandos o <em>shell</em> sendo executado em cada uma das máquinas-membros do grupo <code>srv</code> irá operar.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Analise a saída, agora: note que o Ansible loga em cada uma das máquinas do grupo <code>srv</code> (<code>ns2</code>, <code>ns1</code> e <code>nfs</code>) e executa os comandos indicados, mostrando claramente o <em>hostname</em> local e usuário logado. Observe, ainda, que a ordem das máquinas escrita no arquivo <code>/home/ansible/hosts</code> não foi respeitada&#8201;&#8212;&#8201;o Ansible inicia conexões nos servidores de forma paralela, e as respostas podem vir fora de ordem.</p>
</div>
<div class="paragraph">
<p>Um último adendo: mencionamos o uso do módulo <em>shell</em> no comando acima, mas quais outros módulos existem? Há muitos outros&#8201;&#8212;&#8201;mesmo. Confira a lista completa na página <a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html" class="bare">https://docs.ansible.com/ansible/latest/modules/modules_by_category.html</a> .</p>
</div>
</li>
<li>
<p>A próxima pergunta que pode surgir neste momento é: Ok, conseguimos executar um comando remoto com um usuário não-privilegiado. E se quisermos executar como o <code>root</code>? Para isso, podemos executar a escalação de privilégios usando o <code>become</code>. Veja:</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/hosts srv --become --become-user=root --become-method=su --ask-become-pass -m shell -a 'hostname --fqdn ; head -n1 /etc/shadow'
SU password:
ns1 | CHANGED | rc=0 &gt;&gt;
ns1.intnet
root:$6$s7Gt1cd.$UXQf67CVYxR7HP..h2wvhOx4nOtBT7do28R1uChYdMpZc.uLi43OKdtentrWD2zSTKv9EyB7Bdqcpwr6nAlNo.:17848:0:99999:7:::

ns2 | CHANGED | rc=0 &gt;&gt;
ns2.intnet
root:$6$s7Gt1cd.$UXQf67CVYxR7HP..h2wvhOx4nOtBT7do28R1uChYdMpZc.uLi43OKdtentrWD2zSTKv9EyB7Bdqcpwr6nAlNo.:17848:0:99999:7:::

nfs | CHANGED | rc=0 &gt;&gt;
nfs.intnet
root:$6$s7Gt1cd.$UXQf67CVYxR7HP..h2wvhOx4nOtBT7do28R1uChYdMpZc.uLi43OKdtentrWD2zSTKv9EyB7Bdqcpwr6nAlNo.:17848:0:99999:7:::</pre>
</div>
</div>
<div class="paragraph">
<p>Quais as diferenças para o comando anterior?</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>--become</code> indica que desejamos executar comandos como outro usuário&#8201;&#8212;&#8201;esta opção não implica qual usuário, método ou senha serão usados, mas apenas que haverá a alteração de usuário efetivo.</p>
</li>
<li>
<p>Em seguida, <code>--become-user=root</code> informa que o usuário a se tornar nas máquinas remotas será, de fato, o <code>root</code>.</p>
</li>
<li>
<p>A opção <code>--become-method=su</code> configura o método de escalada de privilégio usado. Como ainda não configuramos o <code>sudo</code> nas máquinas remotas, iremos usar o <code>su</code>.</p>
</li>
<li>
<p><code>--ask-become-pass</code> solicita ao Ansible que pergunte a senha de escalação de privilégio antes de executar os comandos, evitando que tenhamos que digitá-la diretamente no terminal.</p>
</li>
<li>
<p>Por fim, <code>'hostname --fqdn ; head -n1 /etc/shadow'</code> visa identificar a máquina remota e depois executar um comando que apenas o <code>root</code> conseguiria fazer.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Excelente! Estamos conseguindo controlar remotamente todos os servidores com sucesso. Mas e se quisermos fazer mais que apenas rodar comandos simples?</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_uso_de_roles_no_ansible">4) Uso de roles no Ansible</h3>
<div class="paragraph">
<p>Caso queiramos fazer mais que executar poucos comandos num <em>shell</em> remoto, o uso de <em>roles</em> (ou papéis) é fundamental para organizar tarefas complexas, cópia remota de arquivos e gerência de dependências entre serviços. Vamos usar <em>roles</em> no Ansible para solucionar o problema de gestão centralizada do arquivo <code>/etc/sudoers</code>, apresentado no final da sessão anterior.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Crie um diretório para armazenar as <em>roles</em> que serão criadas, <code>/home/ansible/roles</code>. Em seguida, entre nesse diretório.</p>
<div class="literalblock">
<div class="content">
<pre>$ mkdir ~/roles</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/roles/</pre>
</div>
</div>
</li>
<li>
<p>O comando <code>ansible-galaxy</code> nos permite realizar uma série de operações relacionadas a <em>roles</em>, desde a criação de simples papéis locais até a busca e importação de <em>roles</em> criadas por outros usuários do Ansible e acessíveis na Internet pelo website <a href="https://galaxy.ansible.com/" class="bare">https://galaxy.ansible.com/</a> . Recomendamos ao aluno que pesquise por tarefas usuais nesse site&#8201;&#8212;&#8201;provavelmente já existe uma <em>role</em> para solucionar esse problema!</p>
<div class="paragraph">
<p>Para manter a simplicidade das atividades executadas no curso, iremos criar <em>roles</em> manualmente. Use o <code>ansible-galaxy</code> para criar uma estrutura de diretórios padrão para a <em>role</em> <code>sudoers</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-galaxy init --init-path ~/roles/ sudoers
- sudoers was created successfully</pre>
</div>
</div>
<div class="paragraph">
<p>O que foi criado? Vejamos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls -R ~/roles/sudoers/
/home/ansible/roles/sudoers/:
defaults  files  handlers  meta  README.md  tasks  templates  tests  vars

/home/ansible/roles/sudoers/defaults:
main.yml

/home/ansible/roles/sudoers/files:

/home/ansible/roles/sudoers/handlers:
main.yml

/home/ansible/roles/sudoers/meta:
main.yml

/home/ansible/roles/sudoers/tasks:
main.yml

/home/ansible/roles/sudoers/templates:

/home/ansible/roles/sudoers/tests:
inventory  test.yml

/home/ansible/roles/sudoers/vars:
main.yml</pre>
</div>
</div>
<div class="paragraph">
<p>Cada um dos diretórios criados possui uma função específica, a saber:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>defaults</code>: contém variáveis-padrão a serem usadas na <em>role</em>.</p>
</li>
<li>
<p><code>files</code>: contém arquivos que serão copiados através desta <em>role</em>.</p>
</li>
<li>
<p><code>handlers</code>: contém funções especiais denominadas <em>handlers</em>. Essas funções são bastante parecida com <em>tasks</em>, mas são invocadas de forma indireta e servem para automatizar tarefas recorrentes, como o <em>reload</em> de <em>daemons</em> de serviços.</p>
</li>
<li>
<p><code>meta</code>: contém metadados sobre a <em>role</em>, como a definição de dependências entre <em>roles</em> em um mesmo diretório.</p>
</li>
<li>
<p><code>tasks</code>: contém a lista principais de tarefas a serem executados pela <em>role</em>.</p>
</li>
<li>
<p><code>templates</code>: contém <em>templates</em> que podem ser copiados através desta <em>roles</em>&#8201;&#8212;&#8201;<em>templates</em> podem basicamente ser entendidos como arquivos que se utilizam de variáveis para customizar seu estado final.</p>
</li>
<li>
<p><code>tests</code>: permite a criação de testes para verificar a correta execução de aspectos da <em>role</em> corrente. Frequentemente não é necessário desenvolver (muitos) testes no Ansible, já que o sistema de configuração modela um estado-alvo desejado, de forma declarativa.</p>
</li>
<li>
<p><code>vars</code>: define outras variáveis para a <em>role</em>, que têm precedência sobre as variáveis em <code>defaults</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Retomemos o problema central, a configuração do arquivo <code>/etc/sudoers</code> de forma centralizada:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>A colaboradora <code>leia</code> acaba de se juntar à equipe de <code>han</code>, o grupo <code>fwadm</code> em nosso sistema LDAP. Imagine que ela ficará responsável por editar regras no firewall de borda, a máquina <code>ns1</code>. Mas, por estar começando agora na empresa, <code>han</code> quer restringir o conjunto de comandos que <code>leia</code> pode executar na máquina, liberando apenas a edição do firewall via <code>iptables</code>. Sua senha será <code>seg10leia</code>. Nas demais máquinas (<code>ns2</code> e <code>nfs</code>) <code>leia</code> não deve ter qualquer acesso especial, apenas como um usuário regular.</p>
</li>
<li>
<p>O colaborador <code>chewie</code> foi contratado para auxiliar na manutenção da base LDAP da empresa. Para desempenhar suas tarefas, iremos colocá-lo em um novo grupo <code>ldapadm</code>. Os membros desse grupo devem ter acesso aos principais comandos de edição do LDAP (criação, modificação e deleção de usuários e grupos) na máquina <code>ns2</code>. Sua senha será <code>seg10chewie</code>. Nas demais máquinas (<code>ns1</code> e <code>nfs</code>) <code>chewie</code> não deve ter qualquer acesso especial, apenas como um usuário regular.</p>
</li>
<li>
<p>Os usuários atuais, <code>luke</code> e <code>han</code>, terão permissão para executar qualquer comando como o usuário <code>root</code>, em qualquer máquina.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>A criação de usuários e grupos já foi tratada no passo (1) da atividade (9) da sessão anterior, como visto. Foquemos, então, apenas arquivo <code>sudoers</code>. Como o <code>sudo</code> é um programa estático (isto é, não depende de nenhum <em>daemon</em> executando para funcionar), o único requerimento para uma <em>role</em> que configure o arquivo <code>/etc/sudoers</code> é copiar o arquivo corretamente para as máquinas, e ajustar suas permissões.</p>
</div>
<div class="paragraph">
<p>Crie o arquivo novo <code>/home/ansible/roles/sudoers/files/sudoers</code>, com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">Defaults        env_reset
Defaults        mail_badpass
Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

User_Alias ADMINS    = aluno, \
                       luke,  \
                       han

User_Alias FWUSERS   = leia

User_Alias LDAPUSERS = %ldapadm

Host_Alias FWHOSTS   = ns1

Host_Alias LDAPHOSTS = ns2

Cmnd_Alias FWCMDS    = /sbin/iptables

Cmnd_Alias LDAPCMDS  = /usr/sbin/ldapaddgroup,             \
                       /usr/sbin/ldapadduser,              \
                       /usr/sbin/ldapaddusertogroup,       \
                       /usr/sbin/ldapdeletegroup,          \
                       /usr/sbin/ldapdeleteuser,           \
                       /usr/sbin/ldapdeleteuserfromgroup,  \
                       /usr/sbin/ldapmodifygroup,          \
                       /usr/sbin/ldapmodifymachine,        \
                       /usr/sbin/ldapmodifyuser,           \
                       /usr/sbin/ldaprenamegroup,          \
                       /usr/sbin/ldaprenameuser,           \
                       /usr/sbin/ldapsetpasswd,            \
                       /usr/sbin/ldapsetprimarygroup

root      ALL=(ALL:ALL)    ALL

ansible   ALL=(ALL:ALL)    NOPASSWD: ALL

ADMINS    ALL=(ALL:ALL)    ALL

FWUSERS   FWHOSTS=(root)   FWCMDS

LDAPUSERS LDAPHOSTS=(root) LDAPCMDS

#includedir /etc/sudoers.d</code></pre>
</div>
</div>
<div class="paragraph">
<p>O que esse arquivo faz? Vamos ver:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Nas linhas [5-11] definimos <em>aliases</em> (apelidos) de usuários para agrupar os elementos que serão configurados para usar o <code>sudo</code>. Criamos um <em>alias</em> <code>ADMINS</code> para agrupar os usuários <code>aluno</code>, <code>luke</code> e <code>han</code>, <code>FWUSERS</code> para <code>leia</code> e <code>LDAPUSERS</code> para o <strong>grupo</strong> <code>ldapadm</code>. É especialmente importante manter um <em>alias</em> apontando para um usuário local, como o usuário <code>aluno</code>, caso haja problemas com o sistema de autenticação LDAP.</p>
</li>
<li>
<p>Nas linhas [13-15] definimos <em>aliases</em> para máquinas, <code>ns1</code> e <code>ns2</code>. Também poderíamos usar endereços IP, se desejado.</p>
</li>
<li>
<p>Nas linhas [17-31] definimos <em>aliases</em> de comandos: para a máquina <code>ns1</code>, apenas o comando <code>/sbin/iptables</code> é suficiente; já para a máquina <code>ns2</code> configuramos uma lista detalhada dos comandos que o <em>alias</em> <code>LDAPUSERS</code> poderá usar.</p>
</li>
<li>
<p>Nas linhas [33-41] fazemos a "amarração" dos <em>aliases</em> previamente definidos, atribuindo aos usuários/grupos em quais máquinas eles podem executar os comandos, como quais usuários, e quais são esses comandos. Note que ao usuário <code>ansible</code> é permitido executar qualquer comando como <code>root</code> em todas as máquinas sem a necessidade de digitação de senha, de forma bastante conveniente para a automação de tarefas via Ansible como faremos em sessões futuras.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Compare as regras sendo definidas pelos <em>aliases</em> no arquivo <code>sudoers</code> acima e os requisitos de acesso definidos no começo deste passo&#8201;&#8212;&#8201;todos estão sendo atendidos a contento. É claro, seria possível organizar os usuários/grupos de forma diferente&#8201;&#8212;&#8201;em particular, poderia ser interessante agrupar os usuário <code>han</code> e <code>luke</code> em um grupo dedicado de "super-admins"&#8201;&#8212;&#8201;mas funciona como uma boa prova de conceito.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para o aluno atento, é claro observar que o conjunto de programas que estão sendo autorizados para o usuário <code>chewie</code> (de fato, todo o grupo <code>ldapadm</code>) garante a ele uma permissão efetiva <strong>muito</strong> maior que a prevista no escopo inicial do problema. Afinal, bastaria ao usuário <code>chewie</code> adicionar-se a si mesmo no grupo <code>fwadm</code> (via comando <code>ldapaddusertogroup</code>) para acessar a máquina <code>ns1</code>, ou alterar a senha dos usuários <code>han</code> ou <code>luke</code> (via comando <code>ldapsetpasswd</code>) e entrar como esses usuários em máquinas que permitam login via senha. Iremos "ignorar" esse problema nesta atividade, em nome da simplicidade.</p>
</div>
<div class="paragraph">
<p>De fato, fica aqui também um desafio: qual seria o conjunto adequado de programas e permissões garantidas via <code>sudoers</code> que permitiria ao usuário <code>chewie</code> executar seu trabalho de manutenção de contas no LDAP da empresa, e ao mesmo tempo controlar seu acesso de forma efetiva? Lembre-se que o <code>sudoers</code> permite ao administrador definir não apenas quais comandos serão autorizados, mas também parâmetros específicos de linha de comando, se desejado.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Criado o arquivo <code>sudoers</code> que atende aos requisitos iniciais, temos que criar a tarefa que irá distribuí-lo. Antes disso, observe as permissões do arquivo <code>sudoers</code> original:</p>
<div class="literalblock">
<div class="content">
<pre>$ ls -ld /etc/sudoers
-r--r----- 1 root root 669 jun  5  2017 /etc/sudoers</pre>
</div>
</div>
<div class="paragraph">
<p>Com essas permissões em mente, edite o arquivo <code>/home/ansible/roles/sudoers/tasks/main.yml</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Propagate sudoers configuration
  become: yes
  become_user: root
  become_method: su
  copy:
    src: sudoers
    dest: /etc
    owner: root
    group: root
    mode: 0440</code></pre>
</div>
</div>
<div class="paragraph">
<p>Definimos uma tarefa de propagação do arquivo <code>sudoers</code>, com as seguintes características: iremos rodar a tarefa como o usuário <code>root</code>, usando o <code>su</code> para escalada de privilégio; será copiado o arquivo <code>sudoers</code> (do diretório <code>files/</code>, implícito aqui) para a pasta <code>/etc</code> na máquina remota, com <code>root</code> como usuário e grupo donos, e permissões <code>r&#8212;&#8203;r-----</code>.</p>
</div>
</li>
<li>
<p>Tudo pronto? Vamos executar! Crie o arquivo <code>/home/ansible/srv.yml</code> para fazer a amarração entre o grupo de <em>hosts</em> e a nova <em>role</em>:</p>
<div class="literalblock">
<div class="content">
<pre>$ nano ~/srv.yml
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/srv.yml
---
- hosts: srv
  roles:
    - sudoers</pre>
</div>
</div>
<div class="paragraph">
<p>Como ainda <strong>não</strong> configuramos o <code>sudo</code>, e estamos usando o comando <code>su</code> para escalada de privilégio, iremos passar novamente a opção <code>--ask-become-pass</code> para que o Ansible solicite a senha do usuário <code>root</code> para escalada de privilégio nas máquinas remotas. Execute a role:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/hosts ~/srv.yml --ask-become-pass
SUDO password:

PLAY [srv] **********************************************************************************************************


TASK [Gathering Facts] **********************************************************************************************

ok: [ns2]
ok: [ns1]
ok: [nfs]

TASK [sudoers : Propagate sudoers configuration] ********************************************************************

changed: [ns2]
changed: [ns1]
changed: [nfs]

PLAY RECAP **********************************************************************************************************

nfs                        : ok=2    changed=1    unreachable=0    failed=0
ns1                        : ok=2    changed=1    unreachable=0    failed=0
ns2                        : ok=2    changed=1    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>Terá funcionado? Vamos ver: tente executar um comando distribuído com o Ansible usando o <code>sudo</code> como método de escalada de privilégio, e sem digitar senha.</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/hosts srv -b --become-user=root --become-method=sudo -m shell -a 'hostname --fqdn ; grep ansible /etc/sudoers'
nfs | CHANGED | rc=0 &gt;&gt;
nfs.intnet
ansible   ALL=(ALL:ALL)    NOPASSWD: ALL

ns2 | CHANGED | rc=0 &gt;&gt;
ns2.intnet
ansible   ALL=(ALL:ALL)    NOPASSWD: ALL

ns1 | CHANGED | rc=0 &gt;&gt;
ns1.intnet
ansible   ALL=(ALL:ALL)    NOPASSWD: ALL</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito! Veja que o Ansible conseguiu acessar todas as máquinas, elevar privilégios usando o <code>sudo</code> sem necessidade de senha, e imprimir o conteúdo do arquivo <code>/etc/sudoers</code>&#8201;&#8212;&#8201;o qual pode ser lido apenas pelo <code>root</code> e, convenientemente, filtramos a linha em que a autorização ao usuário <code>ansible</code> está sendo configurada.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_testando_os_controles_do_sudo">5) Testando os controles do sudo</h3>
<div class="paragraph">
<p>Conseguimos distribuir o arquivo <code>sudoers</code> como objetivado, mas será que os controles estão funcionando?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos testar o acesso de <code>leia</code> na máquina <code>ns1</code>&#8201;&#8212;&#8201;lembre-se, ela deve conseguir executar apenas o comando <code>iptables</code> como o usuário <code>root</code>, e nenhum outro. Acesse a máquina <code>ns1</code> como <code>leia</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns1
leia</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, tente executar o comando <code>iptables</code> usando o <code>sudo</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo iptables -L POSTROUTING -vn -t nat

Presumimos que você recebeu as instruções de sempre do administrador
de sistema local. Basicamente, resume-se a estas três coisas:

    #1) Respeite a privacidade dos outros.
    #2) Pense antes de digitar.
    #3) Com grandes poderes vêm grandes responsabilidades.

[sudo] senha para leia:
Chain POSTROUTING (policy ACCEPT 322 packets, 25437 bytes)
 pkts bytes target     prot opt in     out     source               destination
    1    60 MASQUERADE  tcp  --  *      enp0s3  10.0.42.0/24         0.0.0.0/0            multiport dports 80,443
    9   540 MASQUERADE  tcp  --  *      enp0s3  192.168.42.0/24      0.0.0.0/0            multiport dports 80,443</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente! E se tentarmos executar um comando não autorizado?</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo rm /etc/shadow
Sinto muito, usuário leia não tem permissão para executar "/bin/rm /etc/shadow" como root em ns1.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>De fato, é possível listar exatamente quais comandos um usuário está apto a executar com o comando <code>sudo -l</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo -l
Entradas de Defaults correspondentes a leia em ns1:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

Usuário leia pode executar os seguintes comandos em ns1:
    (root) /sbin/iptables</pre>
</div>
</div>
<div class="paragraph">
<p>E quanto a <code>han</code>? Ele consegue executar qualquer comando como <code>root</code>?</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns1
han</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo -l

Presumimos que você recebeu as instruções de sempre do administrador
de sistema local. Basicamente, resume-se a estas três coisas:

    #1) Respeite a privacidade dos outros.
    #2) Pense antes de digitar.
    #3) Com grandes poderes vêm grandes responsabilidades.

[sudo] senha para han:
Entradas de Defaults correspondentes a han em ns1:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

Usuário han pode executar os seguintes comandos em ns1:
    (ALL : ALL) ALL</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente! Os acessos para a máquina <code>ns1</code> estão funcionando como previsto.</p>
</div>
</li>
<li>
<p>Vamos para o caso do usuário <code>chewie</code>. Acesse a máquina <code>ns2</code> como <code>chewie</code> e verifique quais comandos você está autorizado a executar usando o <code>sudo</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns2
chewie</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo -l

Presumimos que você recebeu as instruções de sempre do administrador
de sistema local. Basicamente, resume-se a estas três coisas:

    #1) Respeite a privacidade dos outros.
    #2) Pense antes de digitar.
    #3) Com grandes poderes vêm grandes responsabilidades.

[sudo] senha para chewie:
Entradas de Defaults correspondentes a chewie em ns2:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

Usuário chewie pode executar os seguintes comandos em ns2:
    (root) /usr/sbin/ldapaddgroup, /usr/sbin/ldapadduser, /usr/sbin/ldapaddusertogroup, /usr/sbin/ldapdeletegroup,
        /usr/sbin/ldapdeleteuser, /usr/sbin/ldapdeleteuserfromgroup, /usr/sbin/ldapmodifygroup,
        /usr/sbin/ldapmodifymachine, /usr/sbin/ldapmodifyuser, /usr/sbin/ldaprenamegroup, /usr/sbin/ldaprenameuser,
        /usr/sbin/ldapsetpasswd, /usr/sbin/ldapsetprimarygroup</pre>
</div>
</div>
<div class="paragraph">
<p>Tente criar um novo grupo no LDAP, <code>sudotest</code>, e em seguida delete-o.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo ldapaddgroup sudotest
Successfully added group sudotest to LDAP</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo ldapdeletegroup sudotest
Successfully deleted group cn=sudotest,ou=Groups,dc=intnet from LDAP</pre>
</div>
</div>
<div class="paragraph">
<p>Tente executar um comando não-autorizado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo reboot
Sinto muito, usuário chewie não tem permissão para executar "/sbin/reboot" como root em ns2.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>Tudo de acordo com o esperado, muito bom.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_controle_da_senha_do_usuário_root">6) Controle da senha do usuário root</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Pergunte-se agora o seguinte: e se <code>leia</code> ou <code>chewie</code>, por qualquer motivo, conseguirem obter a senha do usuário <code>root</code>? O que não é exatamente difícil, já que estamos usando <code>rnpesr</code> como senha&#8201;&#8212;&#8201;o que ocorre então? Veja o que acontece ao usarmos o comando <code>su</code> como <code>chewie</code> na máquina <code>ns2</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns2
chewie</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su -
Senha:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># whoami
root</pre>
</div>
</div>
<div class="paragraph">
<p>A solução ideal, nesse caso, é desabilitar a senha do <code>root</code>. Já que os acessos de superusuário estão corretamente configurados via arquivo <code>sudoers</code> distribuído centralmente via Ansible, não teremos prejuízo administrativo&#8201;&#8212;&#8201;nesse cenário, mesmo que usuários não-autorizados descubram a senha, está já estará desabilitada e não poderá ser usada para efetuar escalada de privilégio.</p>
</div>
</li>
<li>
<p>Acesse a máquina <code>client</code> como o usuário <code>ansible</code>. Para desabilitar a conta do <code>root</code>, basta usar o comando <code>passwd -l</code>&#8201;&#8212;&#8201;vamos executar esse comando em todos os servidores do <em>datacenter</em>:</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/hosts srv -b --become-user=root --become-method=sudo -m shell -a 'passwd -l root'
ns1 | CHANGED | rc=0 &gt;&gt;
passwd: informação de expiração de senha alterada.

nfs | CHANGED | rc=0 &gt;&gt;
passwd: informação de expiração de senha alterada.

ns2 | CHANGED | rc=0 &gt;&gt;
passwd: informação de expiração de senha alterada.</pre>
</div>
</div>
</li>
<li>
<p>Com a senha desabilitada, apenas aqueles usuários que tenham permissão de <code>sudo</code> para executar comandos de escalada de privilégio poderão tornar-se o usuário <code>root</code>&#8201;&#8212;&#8201;todos os demais, restritos a um subconjunto de comandos controlados pelo arquivo <code>/etc/sudoers</code>, não conseguirão fazê-lo.</p>
<div class="paragraph">
<p>Por exemplo, acesse a máquina <code>ns1</code> como o usuário <code>han</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns1
han</pre>
</div>
</div>
<div class="paragraph">
<p>Note que mesmo o usuário <code>han</code>, que possui acesso irrestrito, não consegue executar <code>su</code> diretamente, mesmo digitando a senha correta:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su -
Senha:
su: Falha de autenticação</pre>
</div>
</div>
<div class="paragraph">
<p>Apenas com comandos como <code>sudo su -</code>, <code>sudo -i</code> ou <code>sudo --login</code> (que equivale a invocar um <em>shell</em> de login, como executar <code>sudo bash</code>) é possível tornar-se <code>root</code>, como podemos ver:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo -i</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># whoami
root</pre>
</div>
</div>
</li>
<li>
<p>Mas&#8230;&#8203; observe, nossa configuração não está ortogonal. Imagine que uma nova máquina seja criada em nosso <em>datacenter</em>, e queremos configurá-la com a distribuição do arquivo <code>sudoers</code> de forma centralizada, assim como fizemos com nossos servidores atuais. Sem problema, certo? Basta adicionar o novo <em>hostname</em> no arquivo <code>~/hosts</code> e disparar com o <code>ansible-playbook</code>!</p>
<div class="paragraph">
<p>A configuração de <em>lockout</em> da senha do <code>root</code> que fizemos no passo (2), no entanto, não está integrada à <em>role</em> <code>sudoers</code>. De fato, executamos um comando direto usando o módulo <em>shell</em>&#8201;&#8212;&#8201;e se esquecermos de fazer esse passo com a próxima máquina? Nesse caso, a senha do <code>root</code> dessa máquina estará habilitada, e teremos uma configuração divergente em nossos servidores.</p>
</div>
<div class="paragraph">
<p>Fica claro, portanto, que o método correto de integração de novas tarefas no Ansible é via <em>roles</em>, e não via comandos isolados, sob pena de criar uma grande confusão no parque de servidores num futuro próximo. Vamos reverter o comando que fizemos antes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/hosts srv -b --become-user=root --become-method=sudo -m shell -a 'passwd -u root'
ns1 | CHANGED | rc=0 &gt;&gt;
passwd: informação de expiração de senha alterada.

nfs | CHANGED | rc=0 &gt;&gt;
passwd: informação de expiração de senha alterada.

ns2 | CHANGED | rc=0 &gt;&gt;
passwd: informação de expiração de senha alterada.</pre>
</div>
</div>
</li>
<li>
<p>Como desabilitar a conta do <code>root</code> do jeito certo? Vamos editar a lista de <em>tasks</em> da <em>role</em> <code>sudoers</code>. Adicione a tarefa a seguir no arquivo <code>/home/ansible/roles/sudoers/tasks/main.yml</code> (copie todo o comando, desde <code>cat</code> até a palavra <code>EOF</code>):</p>
<div class="literalblock">
<div class="content">
<pre>$ cat &lt;&lt; EOF &gt;&gt; ~/roles/sudoers/tasks/main.yml

- name: Sets root account as expired
  user:
    name: root
    expires: 0
EOF</pre>
</div>
</div>
<div class="paragraph">
<p>Uma curiosidade: a sintaxe acima é conhecida como <em>heredoc</em> (ou <em>Here Document</em>), um bloco de código que pode ser usado para diversas tarefas no <em>shell</em> Bash. No exemplo acima, estamos usando-o para inserir todas as linhas ao final do arquivo <code>/home/ansible/roles/sudoers/tasks/main.yml</code>, até que seja encontrada a <em>string</em> <code>EOF</code>. Consulte este link para mais informações sobre uso de <em>heredocs</em>: <a href="https://www.tldp.org/LDP/abs/html/here-docs.html" class="bare">https://www.tldp.org/LDP/abs/html/here-docs.html</a> .</p>
</div>
<div class="paragraph">
<p>De volta à tarefa em mãos, vamos ver como ficou o arquivo após a alteração:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat /home/ansible/roles/sudoers/tasks/main.yml
---
- name: Propagate sudoers configuration
  become: yes
  become_user: root
  become_method: su
  copy:
    src: sudoers
    dest: /etc
    owner: root
    group: root
    mode: 0440

- name: Sets root account as expired
  user:
    name: root
    expires: 0</pre>
</div>
</div>
<div class="paragraph">
<p>A tarefa que acabamos de adicionar irá se valer do módulo <em>user</em> do Ansible, e ajustar a data de expiração do usuário <code>root</code> para 0&#8201;&#8212;&#8201;esse valor é contado em segundos a partir do dia 1 de janeiro de 1970, uma referência conhecida como <em>Unix Epoch</em>, ou <em>POSIX Time</em>. Com efeito, estamos dizendo que a conta deste usuário está expirada desde 1/1/1970.</p>
</div>
</li>
<li>
<p>Falta alguma coisa? Ah sim! Note que o <code>become_method</code> do arquivo <code>/home/ansible/roles/sudoers/tasks/main.yml</code> ainda está configurado como <code>su</code>&#8201;&#8212;&#8201;como já distribuímos o arquivo <code>sudoers</code> anteriormente com sucesso usando essa <em>role</em>, podemos alterá-lo para <code>sudo</code>.</p>
<div class="paragraph">
<p>Mais além, observe que as diretivas <code>become*</code> são específicas da tarefa de propagação do arquivo <code>sudoers</code>, e não se aplicam à tarefa de ajuste de expiração de conta do usuário <code>root</code>. Ao invés de repetir o bloco <code>become + become_user + become_method</code> duas vezes (ou mais, dependendo do número de tarefas que queremos realizar), o melhor caminho de ação é remover esse bloco do arquivo de <em>tasks</em> e inseri-lo no arquivo de configuração da <em>role</em>.</p>
</div>
<div class="paragraph">
<p>Vamos por partes. Primeiro, vamos remover as linhas <code>become*</code> do arquivo <code>/home/ansible/roles/sudoers/tasks/main.yml</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ t="$( mktemp )" ; \
    cat ~/roles/sudoers/tasks/main.yml | \
    awk 'gsub(/^ *become.*$/,""){printf $0;next;}1' &gt; $t ; \
    mv $t ~/roles/sudoers/tasks/main.yml ; \
    unset t</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/roles/sudoers/tasks/main.yml
---
- name: Propagate sudoers configuration
  copy:
    src: sudoers
    dest: /etc
    owner: root
    group: root
    mode: 0440

- name: Sets root account as expired
  user:
    name: root
    expires: 0</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, vamos inseri-las no arquivo de amarração da <em>role</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\- hosts\: srv/a\  become: yes\n  become_user: root\n  become_method: sudo' ~/srv.yml</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/srv.yml
---
- hosts: srv
  become: yes
  become_user: root
  become_method: sudo
  roles:
    - sudoers</pre>
</div>
</div>
<div class="paragraph">
<p>Observe atentamente a indentação do arquivo acima: caso a cópia do comando tenha inserido ou removido espaços acidentalmente, edite o arquivo diretamente e deixe-o <strong>exatamente</strong> como mostrado acima.</p>
</div>
</li>
<li>
<p>Pronto! Vamos disparar a <em>role</em> usando o <code>ansible-playbook</code> e verificar seu funcionamento:</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/hosts ~/srv.yml

PLAY [srv] **********************************************************************************************************


TASK [Gathering Facts] **********************************************************************************************

ok: [ns2]
ok: [ns1]
ok: [nfs]

TASK [sudoers : Propagate sudoers configuration] ********************************************************************

ok: [ns2]
ok: [ns1]
ok: [nfs]

TASK [sudoers : Sets root account as expired] ***********************************************************************

changed: [ns2]
changed: [nfs]
changed: [ns1]

PLAY RECAP **********************************************************************************************************

nfs                        : ok=3    changed=1    unreachable=0    failed=0
ns1                        : ok=3    changed=1    unreachable=0    failed=0
ns2                        : ok=3    changed=1    unreachable=0    failed=0</pre>
</div>
</div>
<div class="paragraph">
<p>Terá funcionado? Vamos ver, usando o módulo <em>shell</em> do Ansible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/hosts srv -b --become-user=root --become-method=sudo -m shell -a 'chage -l root | grep "Conta expira"'
nfs | CHANGED | rc=0 &gt;&gt;
Conta expira                                            : jan 01, 1970

ns1 | CHANGED | rc=0 &gt;&gt;
Conta expira                                            : jan 01, 1970

ns2 | CHANGED | rc=0 &gt;&gt;
Conta expira                                            : jan 01, 1970</pre>
</div>
</div>
<div class="paragraph">
<p>Excelente! Vamos fazer um teste <em>in loco</em> com o usuário <code>han</code> na máquina <code>ns1</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
ns1
han</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su -
Senha:
Sua conta expirou; entre em contato com o administrador do sistema
su: Falha de autenticação</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_versionamento_de_configuração_com_git">6) Versionamento de configuração com git</h3>
<div class="paragraph">
<p>À medida que fazemos novas adições de <em>tasks</em> e <em>roles</em> ao Ansible, pode surgir a necessidade de documentar as modificações sendo feitas, compartilhá-las com outros colegas de trabalho ou, em caso de mudanças incorretas, reverter o estado dos artefatos de configuração para uma versão anterior, conhecida e testada. De certa forma, as configuração que estamos fazendo em servidores do <em>datacenter</em> com o Ansible se parecem muito com o código-fonte de uma linguagem de programação&#8201;&#8212;&#8201;só que, ao invés de produzir programas, nosso código produz configurações e estados-alvo em servidores.</p>
</div>
<div class="paragraph">
<p>A ferramenta de controle de versão Git é certamente a mais utilizada mundialmente para cumprir as tarefas que delineamos acima. Criado em 2005 por Linus Torvalds (sim, o mesmo criador do kernel Linux, você não leu errado), o Git é um sistema de versionamento distribuído desenhado com o objetivo expresso de aprimorar as limitações dos sistemas de controle de versão mais usados à epoca: CVS e Subversion.</p>
</div>
<div class="paragraph">
<p>Iremos instalar um servidor Git na máquina <code>nfs</code>, e utilizá-lo como repositório para as configurações gerenciadas pelo Ansible. Assim, a cada nova modificação poderemos manter o registro de versão no repositório, comentar quais mudanças foram realizadas, bem como compartilhar o acesso ao código com outros colaboradores e aceitar suas submissões e <em>patches</em>, se desejado.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O primeiro passo é instalar o Git nas máquinas <code>nfs</code> e <code>client</code>&#8201;&#8212;&#8201;queremos usar o Ansible para fazer isso, mas o <code>sudo</code> não está configurado na máquina <code>client</code>&#8230;&#8203; ainda.</p>
<div class="paragraph">
<p>Logue como o usuário <code>ansible</code> na máquina <code>client</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Como a máquina <code>client</code> não está no DNS, iremos usar seu endereço IP no arquivo de <em>hosts</em>. Adicione-o:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ echo '192.168.42.2' &gt;&gt; ~/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat hosts
[srv]
ns1
ns2
nfs
192.168.42.2</pre>
</div>
</div>
<div class="paragraph">
<p>Lembre-se que o <code>sudo</code> ainda não está configurado na máquina local, de modo que teremos que usar o <code>su</code> para escalar privilégios. Como o método padrão de escalada de privilégios especificado no arquivo <code>/home/ansible/srv.yml</code> é o <code>sudo</code>, teremos que configurar um <em>override</em> na linha de comando. Outro ponto: queremos executar a <em>role</em> apenas na máquina local, de forma que usaremos a opção <code>--limit</code>.</p>
</div>
<div class="paragraph">
<p>Esses fatores considerados, execute a <em>role</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i hosts --limit='192.168.42.2' --ask-become-pass -e ansible_become_method=su srv.yml
SUDO password:

PLAY [srv] **********************************************************************************************************


TASK [Gathering Facts] **********************************************************************************************

ok: [192.168.42.2]

TASK [sudoers : Propagate sudoers configuration] ********************************************************************

changed: [192.168.42.2]

TASK [sudoers : Sets root account as expired] ***********************************************************************

changed: [192.168.42.2]

PLAY RECAP **********************************************************************************************************

192.168.42.2               : ok=3    changed=2    unreachable=0    failed=0</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito. Verifique que o <code>sudoers</code> foi configurado com sucesso, e que a conta do <code>root</code> foi desabilitada na máquina local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo grep ansible /etc/sudoers
ansible   ALL=(ALL:ALL)    NOPASSWD: ALL</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su -
Senha:
Sua conta expirou; entre em contato com o administrador do sistema
su: Falha de autenticação</pre>
</div>
</div>
</li>
<li>
<p>Agora sim, vamos instalar o Git nas máquinas <code>nfs</code> e <code>client</code> usando o Ansible. Note o uso da opção <code>--limit</code> para especificar o escopo do comando:</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/hosts srv -b --become-user=root --become-method=sudo --limit='nfs,192.168.42.2' -m shell -a 'apt-get install -y git'
 [WARNING]: Consider using the apt module rather than running apt-get.  If you need to use command because apt is
insufficient you can add warn=False to this command task or set command_warnings=False in ansible.cfg to get rid of this message.

nfs | CHANGED | rc=0 &gt;&gt;
(...)
Configurando git (1:2.11.0-3+deb9u4) ...

192.168.42.2 | CHANGED | rc=0 &gt;&gt;
(...)
Configurando git (1:2.11.0-3+deb9u4) ...</pre>
</div>
</div>
<div class="paragraph">
<p>Terá funcionado? Vamos ver:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/hosts srv -m shell -a 'which git'
ns2 | FAILED | rc=1 &gt;&gt;
non-zero return code

nfs | CHANGED | rc=0 &gt;&gt;
/usr/bin/git

ns1 | FAILED | rc=1 &gt;&gt;
non-zero return code

192.168.42.2 | CHANGED | rc=0 &gt;&gt;
/usr/bin/git</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito, o Git foi instalado com sucesso, e apenas nas máquinas objetivadas.</p>
</div>
</li>
<li>
<p>Iremos usar o Git em sua capacidade mais básica&#8201;&#8212;&#8201;via SSH, usando os diretórios <em>home</em> de cada usuário. É bastante possível fazer uma configuração muito mais sofisticada, configurar uma interface como o GitLab (<a href="https://about.gitlab.com/install/" class="bare">https://about.gitlab.com/install/</a>), mas para manter a simplicidade das atividades aqui realizadas não iremos fazer isso.</p>
<div class="paragraph">
<p>Primeiro, crie um repositório vazio de nome <code>ansible</code> em seu diretório <em>home</em> local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cd ~ &amp;&amp; git init ansible
Initialized empty Git repository in /home/ansible/ansible/.git/</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, clone-o para o formato <em>bare</em> (mantendo apenas os arquivos administrativos do Git) com o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git clone --bare ansible ansible.git
Cloning into bare repository 'ansible.git'...
warning: You appear to have cloned an empty repository.
done.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls -1d ansible*
ansible
ansible.git</pre>
</div>
</div>
<div class="paragraph">
<p>Devemos copiar o diretório <code>/home/ansible/ansible.git</code> para o servidor Git, que será a máquina <code>nfs</code>. Use o comando <code>scp</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ scp -r ~/ansible.git/ ansible@nfs:~
description                                                                        100%   73   179.2KB/s   00:00
HEAD                                                                               100%   23    76.8KB/s   00:00
pre-receive.sample                                                                 100%  544     1.7MB/s   00:00
commit-msg.sample                                                                  100%  896     2.7MB/s   00:00
pre-applypatch.sample                                                              100%  424     1.3MB/s   00:00
pre-push.sample                                                                    100% 1348     3.4MB/s   00:00
prepare-commit-msg.sample                                                          100% 1239     3.1MB/s   00:00
update.sample                                                                      100% 3610     9.4MB/s   00:00
post-update.sample                                                                 100%  189   478.5KB/s   00:00
pre-rebase.sample                                                                  100% 4898    13.2MB/s   00:00
applypatch-msg.sample                                                              100%  478     1.3MB/s   00:00
pre-commit.sample                                                                  100% 1642     4.4MB/s   00:00
config                                                                             100%  113   367.7KB/s   00:00
exclude                                                                            100%  240   557.6KB/s   00:00</pre>
</div>
</div>
<div class="paragraph">
<p>Pronto, o repositório Git remoto está configurado! Se quiser, remova os arquivos locais&#8201;&#8212;&#8201;iremos usar o repositório remoto a partir de agora:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ rm -rf ~/ansible*</pre>
</div>
</div>
</li>
<li>
<p>Para usar o repositório Git remoto, o primeiro passo é cloná-lo&#8201;&#8212;&#8201;por conveniência (e por já termos configurado o sistema de autenticação centralizado), iremos usar o protocolo SSH no acesso:</p>
<div class="literalblock">
<div class="content">
<pre>$ git clone ansible@nfs:/home/ansible/ansible.git
Cloning into 'ansible'...
warning: You appear to have cloned an empty repository.</pre>
</div>
</div>
<div class="paragraph">
<p>O Git reporta que clonamos um repositório vazio&#8230;&#8203; não por muito tempo! Copie os arquivos de trabalho do Ansible que usamos até aqui para dentro do repositório local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ mv ~/{hosts,roles,srv.yml} ~/ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Entre no repositório local e visualize seu estado com <code>git status</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/ansible/ ; git status
On branch master

Initial commit

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

        hosts
        roles/
        srv.yml

nothing added to commit but untracked files present (use "git add" to track)</pre>
</div>
</div>
<div class="paragraph">
<p>O Git reporta que os arquivos adicionados não estão sendo versionados. Para adicioná-los ao sistema de controle de versão, use o comando <code>git add</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git add .</pre>
</div>
</div>
<div class="paragraph">
<p>O que isso fez?</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git status
On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached &lt;file&gt;..." to unstage)

        new file:   hosts
        new file:   roles/sudoers/README.md
        new file:   roles/sudoers/defaults/main.yml
        new file:   roles/sudoers/files/sudoers
        new file:   roles/sudoers/handlers/main.yml
        new file:   roles/sudoers/meta/main.yml
        new file:   roles/sudoers/tasks/main.yml
        new file:   roles/sudoers/tests/inventory
        new file:   roles/sudoers/tests/test.yml
        new file:   roles/sudoers/vars/main.yml
        new file:   srv.yml</pre>
</div>
</div>
<div class="paragraph">
<p>Agora sim, todos os arquivos foram adicionados ao sistema de versionamento. Para confirmar essas mudanças temos que realizar um <em>commit</em>, ou confirmação, das alterações&#8201;&#8212;&#8201;antes disso, no entanto, é recomendável que configuremos nosso nome de usuário e e-mail no Git, para evitar <em>warnings</em> futuros:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git config user.name Ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git config user.email ansible@intnet</pre>
</div>
</div>
<div class="paragraph">
<p>Pronto, vamos ao <em>commit</em>. É sempre recomendável incluir uma mensagem explicativa junto com o <em>commit</em> (com a opção <code>-m</code>) indicando que alterações foram feitas naquela versão, criando um histórico do repositório.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git commit -m 'Importacao inicial, role sudoers adicionada'
[master (root-commit) 0c673e4] Importacao inicial, role sudoers adicionada
 11 files changed, 180 insertions(+)
 create mode 100644 hosts
 create mode 100644 roles/sudoers/README.md
 create mode 100644 roles/sudoers/defaults/main.yml
 create mode 100644 roles/sudoers/files/sudoers
 create mode 100644 roles/sudoers/handlers/main.yml
 create mode 100644 roles/sudoers/meta/main.yml
 create mode 100644 roles/sudoers/tasks/main.yml
 create mode 100644 roles/sudoers/tests/inventory
 create mode 100644 roles/sudoers/tests/test.yml
 create mode 100644 roles/sudoers/vars/main.yml
 create mode 100644 srv.yml</pre>
</div>
</div>
<div class="paragraph">
<p>O passo final consiste em enviar as alterações locais para o repositório remoto através do comando <code>git push</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git push
Counting objects: 22, done.
Compressing objects: 100% (10/10), done.
Writing objects: 100% (22/22), 3.27 KiB | 0 bytes/s, done.
Total 22 (delta 0), reused 0 (delta 0)
To nfs:/home/ansible/ansible.git
 * [new branch]      master -&gt; master</pre>
</div>
</div>
<div class="paragraph">
<p>Pronto, todos os dados foram enviados para o servidor <code>nfs</code> e estão&#8201;&#8212;&#8201;espera-se&#8201;&#8212;&#8201;seguros. Será mesmo? Vamos testar: retorne ao seu diretório <em>home</em> e remova todos os arquivos do repositório local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cd ~ ; rm -rf ~/ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls
scripts</pre>
</div>
</div>
<div class="paragraph">
<p>Tragédia! Perdemos todo o trabalho realizado com o Ansible até aqui! Ou&#8230;&#8203; perdemos mesmo? Tente clonar o repositório remoto a partir da máquina <code>nfs</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git clone ansible@nfs:/home/ansible/ansible.git
Cloning into 'ansible'...
remote: Counting objects: 22, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 22 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (22/22), done.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ls ~/ansible/
hosts  roles  srv.yml</pre>
</div>
</div>
<div class="paragraph">
<p>Ufa, está tudo ali ainda. Se quiser verificar o registro dos <em>commits</em> anteriores, confirmando que nossas modificações anteriores foram de fato salvas no repositório remoto, basta usar o comando <code>git log</code> dentro do repositório local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/ansible/ ; git log
commit 0c673e48dcdc7aaf2bd6738c8033c33815f10cc6
Author: Ansible &lt;ansible@intnet&gt;
Date:   Thu Nov 15 02:04:14 2018 -0200

    Importacao inicial, role sudoers adicionada</pre>
</div>
</div>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_6_registro_e_correlacionamento_de_eventos">Sessão 6: Registro e correlacionamento de eventos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A gestão de registros de eventos em sistema computacionais é com certeza um dos temas mais difíceis&#8201;&#8212;&#8201;e importantes&#8201;&#8212;&#8201;de se tratar corretamente em um <em>datacenter</em> de grande porte. Imagine a seguinte situação: você quer monitorar todos os eventos acontecendo em um servidor web de alto tráfego em sua organização, buscando por anomalias; para isso, você monitora o log de acesso do servidor web com um comando como <code>tail -f</code>, e observa as mensagens voando em alta velocidade pela tela&#8201;&#8212;&#8201;após alguns poucos segundos fica claro que o enorme volume de mensagens é impossível de ser processado por um ser humano&#8230;&#8203; são eventos demais! Agora, multiplique esse desafio por múltiplos servidores e máquinas virtuais no <em>datacenter</em>, cada qual com uma infinidade de serviços instalados: como dar conta desse trabalho?</p>
</div>
<div class="paragraph">
<p>Ferramentas SIEM (do inglês, <em>Security Information and Event Management</em>) são soluções de software que permitem que os eventos gerados por diversas aplicações de segurança (tais como firewalls, <em>proxies</em>, sistemas de prevenção a intrusão e antivírus) sejam coletados, normalizados, armazenados e correlacionados; essa gestão possibilita uma rápida identificação e resposta aos incidentes. Os SIEMs combinam ferramentas do tipo SIM (<em>Security Information Management</em>) e SEM (<em>Security Event Manager</em>)&#8201;&#8212;&#8201;enquanto ferramentas SEM oferecem monitoramento em tempo real dos eventos de segurança, coletando e agregando os dados (com resposta automática em alguns casos), ferramentas SIM oferecem análise histórica dos eventos de segurança, também coletando e correlacionando os eventos, porém não em tempo real; isso permite consultas mais complexas ao repositório.</p>
</div>
<div class="paragraph">
<p>Dentre as diversas funcionalidades desejáveis em ferramentas SIEM para auxiliar a gestão de logs corporativos, destacamos algumas:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Acesso em tempo real, centralizado e consistente a todos os logs e eventos de segurança, independente do tipo de tecnologia e fabricante.</p>
</li>
<li>
<p>Correlação de logs de tecnologias heterôgeneas, conectando atributos comuns e/ou significativos entre as fontes, de modo a transformar os dados em informação útil.</p>
</li>
<li>
<p>Identificação de comportamentos, incidentes, fraudes, anomalias e quebras de <em>baseline</em> de segurança.</p>
</li>
<li>
<p>Alertas e notificações que podem ser disparadas automaticamente no caso de não conformidade com as políticas de segurança e/ou normas regulatórias, ou ainda, de acordo com as regras de negócio pré-estabelecidas.</p>
</li>
<li>
<p>Emissão de relatórios sofisticados sobre as condições de segurança do ambiente para equipes de SOC (<em>Security Operations Center</em>) auditoria ou resposta a incidentes.</p>
</li>
<li>
<p>Retenção e indexação a longo prazo dos dados possibilitando posterior análise forense.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Nesta sessão iremos instalar e configurar o Graylog, uma das mais populares ferramentas SIEM <em>open-source</em> para armazenamento e correlação de eventos. Iremos integrá-lo com o RSyslog já instalado em nossos servidores, bem como com o sistema de autenticação centralizado via OpenLDAP. Juntamente com o Graylog, será necessário configurar um serviço NTP (<em>Network Time Protocol</em>) para manter a hora dos servidores sincronizada&#8201;&#8212;&#8201;a ferramenta OpenNTPD, do OpenBSD, é uma alternativa simples e segura para solucionar esse problema. Finalmente, faremos também uso da ferramenta Snoopy para registrar comandos digitados pelos usuários no terminal, permitindo análise posterior e garantia de não-repúdio nos acessos remotos via SSH.</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão_5">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>A figura abaixo mostra a topologia de rede que será utilizada nesta sessão, com as máquinas relevantes em destaque.</p>
</div>
<div id="img-topologia6" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/Topologia_SEG10_S6.png" alt="Topologia SEG10 S6">
</div>
<div class="title">Figure 30. Topologia de rede desta sessão</div>
</div>
<div class="paragraph">
<p>Temos uma nova máquina, a saber:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>log</code>, atuando como concentrador de logs dos servidores do <em>datacenter</em> e servidor NTP. Endereço IP 10.0.42.4/24.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Os únicos registros DNS novos a serem criado são mapeamentos direto e reverso para a máquina <code>log</code>&#8201;&#8212;&#8201;para fazer os ajustes, acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo de zonas <code>/etc/nsd/zones/intnet.zone</code>, inserindo uma entrada A para a máquina <code>log</code>, como se segue. <strong>Não se esqueça</strong> de incrementar o valor do serial no topo do arquivo!</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/intnet.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep log /etc/nsd/zones/intnet.zone
log     IN    A                 10.0.42.4</pre>
</div>
</div>
<div class="paragraph">
<p>Faça o mesmo para o arquivo de zona reversa:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/10.0.42.zone</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep log /etc/nsd/zones/10.0.42.zone
4       IN   PTR                log.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>Assine os arquivos de zona usando o <em>script</em> criado anteriormente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash /root/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 6 rrsets, 4 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a criação das entradas usando o comando <code>dig</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig log.intnet +short
10.0.42.4</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># dig -x 10.0.42.4 +short
log.intnet.</pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_2_criação_da_vm_de_gestão_de_logs">2) Criação da VM de gestão de logs</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Como visualizado na topologia que abre esta sessão, teremos uma máquina dedicada para gestão de logs e serviços auxiliares, como o NTP. Devemos começar clonando a máquina <code>debian-template</code> e criar uma nova, que chamaremos de <code>log</code>. Essa máquina estará conectada a uma única rede <em>host-only</em>, com o mesmo nome que foi alocado para a interface de rede da máquina virtual <code>ns1</code>, configurada durante a sessão 2, que está conectada à DMZ. O IP da máquina será 10.0.42.4/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue a máquina e faça login como o usuário <code>root</code>. Em seguida, use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h log -i 10.0.42.4 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ip addr show label 'enp0s*' | grep 'inet ' | awk '{print $2,$NF}' ; hostname ; whoami
10.0.42.4/24 enp0s3
log
root</pre>
</div>
</div>
</li>
<li>
<p>Agora, vamos configurar funcionamento do <code>sudo</code> na máquina <code>log</code>. Acesse a máquina <code>client</code> como o usuário <code>ansible</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Insira a máquina <code>log</code> no inventário gerenciado pelo Ansible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ echo log &gt;&gt; ~/ansible/hosts</pre>
</div>
</div>
<div class="paragraph">
<p>Execute a <em>role</em> <code>sudoers</code>, lembrando-se de limitar o escopo à máquina <code>log</code> e alterando o método de escalação de privilégio para o <code>su</code> (já que o <code>sudo</code> não foi configurado ainda):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l log -Ke ansible_become_method=su ~/ansible/srv.yml
SUDO password:

PLAY [srv] **********************************************************************************************************


TASK [Gathering Facts] **********************************************************************************************

ok: [log]

TASK [sudoers : Propagate sudoers configuration] ********************************************************************

changed: [log]

TASK [sudoers : Sets root account as expired] ***********************************************************************

changed: [log]

PLAY RECAP **********************************************************************************************************

log                        : ok=3    changed=2    unreachable=0    failed=0</pre>
</div>
</div>
<div class="paragraph">
<p>Fácil, não?</p>
</div>
</li>
<li>
<p>Note que fizemos uma alteração, ainda que ligeira, ao repositório de configuração do Ansible: adicionamos a máquina <code>log</code> ao grupo <code>srv</code> no inventário:</p>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/ansible/ ; git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   hosts

no changes added to commit (use "git add" and/or "git commit -a")</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git diff hosts
diff --git a/hosts b/hosts
index f81ed68..be6cf78 100644
--- a/hosts
+++ b/hosts
@@ -3,3 +3,4 @@ ns1
 ns2
 nfs
 192.168.42.2
+log</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos adicionar essa mudança ao repositório, efetuar o <em>commit</em> e publicar as mudanças para o repositório remoto:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git add hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git commit -m 'Maquina log adicionada ao inventario do Ansible'
[master 24bcab5] Maquina log adicionada ao inventario do Ansible
 1 file changed, 1 insertion(+)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git push
Counting objects: 3, done.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 350 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To nfs:/home/ansible/ansible.git
   0c673e4..24bcab5  master -&gt; master</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_ajuste_das_regras_de_firewall_para_o_ntp">3) Ajuste das regras de firewall para o NTP</h3>
<div class="paragraph">
<p>Iremos configurar a seguir um servidor NTP na máquina <code>log</code> para atuar como servidor de hora para os demais servidores do <em>datacenter</em>. O protocolo NTP opera por padrão na porta 123/UDP, para a qual não fizemos quaisquer liberações até aqui&#8201;&#8212;&#8201;caso não façamos a inserção de novas regras no firewall da rede, o serviço não funcionará.</p>
</div>
<div class="paragraph">
<p>Quais são os acessos a configurar? Vejamos:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>A máquina <code>log</code> deve conseguir consultar servidores NTP na Internet, exigindo regras de acesso na <em>chain</em> FORWARD da tabela <code>filter</code> e na <em>chain</em> POSTROUTING da tabela <code>nat</code>. Poderíamos limitar o conjunto de IPs de destino, mas por simplicidade iremos liberar a conexão com qualquer <em>host</em> remoto.</p>
</li>
<li>
<p>Máquinas na DMZ devem conseguir acessar a máquina <code>log</code> na porta 123/UDP. Como essas máquinas estão todas na mesma sub-rede, os acessos não passam pelo firewall e nenhuma configuração adicional se faz necessária.</p>
</li>
<li>
<p>Máquinas na Intranet devem conseguir acessar a máquina <code>log</code> na porta 123/UDP. Como esse tráfego passa <strong>através do</strong> firewall, devemos inserir a regra na <em>chain</em> FORWARD.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos lá: acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Para atender o requisito (a), insira as regras:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 10.0.42.4/32 -o enp0s3 -p udp -m udp --dport 123 -j ACCEPT</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A POSTROUTING -s 10.0.42.4/32 -o enp0s3 -p udp -m udp --dport 123 -j MASQUERADE</pre>
</div>
</div>
<div class="paragraph">
<p>Para o requisito (b), nenhuma ação é necessária. Finalmente, para o requisito (c) insira a regra a seguir:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 192.168.42.0/24 -d 10.0.42.4/32 -p udp -m udp --dport 123 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Não se esqueça de gravar as novas regras na configuração permanente do firewall:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent save
[....] Saving netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save
done.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_configuração_do_ntp">4) Configuração do NTP</h3>
<div class="paragraph">
<p>Vamos ao NTP. Como estabelecido, a máquina <code>log</code> atuará como o servidor NTP da rede, mas quais serão seus clientes? Além dos servidores do <em>datacenter</em>, também iremos configurar a máquina <code>client</code> para consultar o servidor de hora na máquina <code>log</code>. Ao invés de instalar e configurar o <em>daemon</em> do OpenNTPD em cinco (!!) máquinas diferentes, temos aqui uma excelente oportunidade para colocar nossos recém-adquiridos conhecimentos com o Ansible à prova.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acesse a máquina <code>client</code> como o usuário <code>ansible</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
</li>
<li>
<p>Para não termos que criar duas <em>roles</em> específicas&#8201;&#8212;&#8201;uma para gestão de servidores NTP, e outra para clientes&#8201;&#8212;&#8201;iremos usar a funcionalidade de grupos no inventário do Ansible para categorizar as máquinas-alvo. Edite o arquivo <code>/home/ansible/ansible/hosts</code>, deixando-o com o conteúdo a seguir:</p>
<div class="literalblock">
<div class="content">
<pre>$ nano ~/ansible/hosts
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/ansible/hosts
[srv]
ns1
ns2
nfs
192.168.42.2
log

[ntp_server]
log</pre>
</div>
</div>
<div class="paragraph">
<p>Note que incluímos a máquina <code>log</code> no novo grupo <code>ntp_server</code>, que conterá os servidores NTP da rede, deixando implícito que as demais máquinas atuarão como clientes NTP, como veremos a seguir.</p>
</div>
<div class="paragraph">
<p>Vamos agora criar uma nova <em>role</em> para gerenciar a instalação e configuração do OpenNTPD, com o nome <code>ntp</code>. Crie-a:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-galaxy init --init-path=/home/ansible/ansible/roles ntp</pre>
</div>
</div>
</li>
<li>
<p>O próximo passo consiste em editar os arquivos de configuração da <em>role</em>. Vamos começar com os <em>templates</em> de arquivos de configuração: crie o arquivo novo <code>/home/ansible/ansible/roles/ntp/templates/ntp_server.conf.j2</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">listen on 127.0.0.1
listen on {{ ansible_default_ipv4.address }}
servers pool.ntp.br</code></pre>
</div>
</div>
<div class="paragraph">
<p>O arquivo acima será o arquivo de configuração do OpenNTPD nos servidores NTP (no caso, a máquina <code>log</code>). As diretivas <code>listen</code> definem em quais interfaces de rede o <em>daemon</em> irá escutar: além da interface <em>loopback</em>, note que estamos utilizando a variável <code>ansible_default_ipv4.address</code>&#8201;&#8212;&#8201;ela contém o endereço IPv4 da interface de saída padrão da máquina sendo configurada (10.0.42.4, no caso da VM <code>log</code>). A diretiva <code>servers</code> simplesmente define quais servidores remotos na Internet serão consultados para descobrir a hora correta.</p>
</div>
<div class="paragraph">
<p>Vamos agora para o <em>template</em> do arquivo de configuração dos clientes: crie o arquivo novo <code>/home/ansible/ansible/roles/ntp/templates/ntp_client.conf.j2</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">server {{ ntpsrv }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Temos apenas uma diretiva: <code>server</code>, que define o servidor remoto a ser consultado. Note que estamos usando uma variável para configurar esse campo, <code>ntpsrv</code>, que será definida a seguir.</p>
</div>
</li>
<li>
<p>Que variáveis são essas? Edite o arquivo <code>/home/ansible/ansible/roles/ntp/vars/main.yml</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
ntpsrv: "{{ groups['ntp_server'][0] }}.intnet"
fname: "{{ 'ntp_server' if 'ntp_server' in group_names else 'ntp_client' }}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Primeiro, <code>ntpsrv</code>: essa variável contém o servidor NTP sendo configurado no momento&#8201;&#8212;&#8201;para obter seu valor, consultamos no arquivo de inventário qual grupo possui o nome <code>ntp_server</code>, e atribuímos a ela o nome do primeiro <em>host</em> desse grupo (a máquina <code>log</code>).</p>
</div>
<div class="paragraph">
<p>Depois <code>fname</code>: esse variável define qual nome de arquivo será usado para configurar um <em>host</em>&#8201;&#8212;&#8201;se a máquina pertencer ao grupo <code>ntp_server</code>, então o valor da variável será também <code>ntp_server</code>. Do contrário, ela valerá <code>ntp_client</code>.</p>
</div>
</li>
<li>
<p>Vamos às tarefas da <em>role</em>. Edite o arquivo <code>/home/ansible/ansible/roles/ntp/tasks/main.yml</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Add Backports Repository
  apt_repository:
    repo='deb http://deb.debian.org/debian stretch-backports main'
    state=present
    filename=backports
    update_cache=yes

- name: Install OpenNTPD
  apt:
    name: openntpd
    state: latest
    default_release: stretch-backports
    update_cache: true

- name: Copy OpenNTPD configuration
  template:
    src: '{{ fname }}.conf.j2'
    dest: /etc/openntpd/ntpd.conf
    owner: root
    group: root
    mode: 0644
  notify:
    - Restart OpenNTPD</code></pre>
</div>
</div>
<div class="paragraph">
<p>Temos três tarefas:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Add Backports Repository</em> irá adicionar o repositório de <em>backports</em> do Debian, permitindo a instalação da versão mais recente do OpenNTPD.</p>
</li>
<li>
<p><em>Install OpenNTPD</em> se encarrega de instalar o pacote do OpenNTPD, usando o módulo <code>apt</code> do Ansible, a partir do repositório <code>stretch-backports</code>. Antes da instalação, atualizamos a <em>cache</em> dos repositórios de forma análoga ao <code>apt-get update</code>.</p>
</li>
<li>
<p><em>Copy OpenNTPD configuration</em> copia o arquivo de configuração apropriado para <code>/etc/openntpd/ntpd.conf</code>. Note que o arquivo-origem é definido a partir da variável <code>fname</code>, que discutimos no passo anterior. O arquivo é ajustado para usuário-dono <code>root</code> e grupo-dono <code>root</code>, e permissões <code>rw-r&#8212;&#8203;r--</code>. Ao final da cópia, invocamos um <em>handler</em> para reiniciar o OpenNTPD.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Que <em>handler</em> é esse? Edite o arquivo <code>/home/ansible/ansible/roles/ntp/handlers/main.yml</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Restart OpenNTPD
  service:
    name: openntpd
    state: restarted</code></pre>
</div>
</div>
<div class="paragraph">
<p>O <em>handler</em> acima simplesmente utiliza o módulo <code>service</code> do Ansible para garantir que o <em>daemon</em> <code>openntpd</code> esteja com o estado "reiniciado" após sua execução.</p>
</div>
</li>
<li>
<p>A <em>role</em> está pronta! Para executá-la, vamos editar o arquivo <code>/home/ansible/ansible/srv.yml</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ echo '    - ntp' &gt;&gt; ~/ansible/srv.yml</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/ansible/srv.yml
---
- hosts: srv
  become: yes
  become_user: root
  become_method: sudo
  roles:
    - sudoers
    - ntp</pre>
</div>
</div>
<div class="paragraph">
<p>Note que agora ao invocarmos o arquivo <code>/home/ansible/ansible/srv.yml</code> iremos não apenas configurar o <code>sudo</code> de forma automática, mas também instalar e configurar o OpenNTPD nas máquinas-alvo. Basta, é claro, que editemos o arquivo de inventário de antemão.</p>
</div>
</li>
<li>
<p>Ufa! Agora sim, vamos testar:</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts ~/ansible/srv.yml

PLAY [srv] **********************************************************************************************************

(...)

TASK [ntp : Install OpenNTPD] ***************************************************************************************

changed: [192.168.42.2]
changed: [log]
changed: [nfs]
changed: [ns1]
changed: [ns2]

TASK [ntp : Copy OpenNTPD configuration] ****************************************************************************

changed: [ns2]
changed: [ns1]
changed: [log]
changed: [nfs]
changed: [192.168.42.2]

RUNNING HANDLER [ntp : Restart OpenNTPD] ****************************************************************************

changed: [log]
changed: [nfs]
changed: [ns1]
changed: [ns2]
changed: [192.168.42.2]

PLAY RECAP **********************************************************************************************************

192.168.42.2               : ok=6    changed=4    unreachable=0    failed=0
log                        : ok=6    changed=4    unreachable=0    failed=0
nfs                        : ok=6    changed=4    unreachable=0    failed=0
ns1                        : ok=6    changed=4    unreachable=0    failed=0
ns2                        : ok=6    changed=4    unreachable=0    failed=0</pre>
</div>
</div>
<div class="paragraph">
<p>Terá nossa "magia" funcionado? A princípio, o OpenNTPD foi instalado e configurado corretamente nas máquinas-alvo. Vamos checar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible -i ~/ansible/hosts srv -b -m shell -a 'which openntpd ; ps auxmw | grep '[/]usr/sbin/ntpd' ; cat /etc/openntpd/ntpd.conf'
log | CHANGED | rc=0 &gt;&gt;
/usr/sbin/openntpd
root      9286  0.0  0.0   7564   124 ?        -    17:32   0:00 /usr/sbin/ntpd -f /etc/openntpd/ntpd.conf
listen on 127.0.0.1
listen on 10.0.42.4
servers pool.ntp.br

ns1 | CHANGED | rc=0 &gt;&gt;
/usr/sbin/openntpd
root      7163  0.0  0.0   7564   124 ?        -    17:32   0:00 /usr/sbin/ntpd -f /etc/openntpd/ntpd.conf
server log.intnet

ns2 | CHANGED | rc=0 &gt;&gt;
/usr/sbin/openntpd
root      7117  0.0  0.0   7564   124 ?        -    17:32   0:00 /usr/sbin/ntpd -f /etc/openntpd/ntpd.conf
server log.intnet

nfs | CHANGED | rc=0 &gt;&gt;
/usr/sbin/openntpd
root      6967  0.0  0.0   7564   120 ?        -    17:32   0:00 /usr/sbin/ntpd -f /etc/openntpd/ntpd.conf
server log.intnet

192.168.42.2 | CHANGED | rc=0 &gt;&gt;
/usr/sbin/openntpd
root     14410  0.0  0.0   7564   120 ?        -    17:32   0:00 /usr/sbin/ntpd -f /etc/openntpd/ntpd.conf
server log.intnet</pre>
</div>
</div>
<div class="paragraph">
<p>Uhm&#8230;&#8203; o OpenNTPD está instalado em todas as máquinas, como verificado pelo <code>which</code>. O processo do <code>ntpd</code> também está ativo, como verificado via <code>ps</code>. E, finalmente, os arquivos de configuração de todas as máquinas cliente possui apenas a linha <code>server log.intnet</code>, como esperado, e o arquivo de configuração da máquina <code>log</code> corresponde ao que objetivávamos.</p>
</div>
<div class="paragraph">
<p>Muito legal, não é mesmo?</p>
</div>
</li>
<li>
<p>Muitas alterações em nosso repositório local&#8201;&#8212;&#8201;vamos fazer um <em>commit</em> e enviá-las:</p>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/ansible/</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git add .</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   hosts
        new file:   roles/ntp/README.md
        new file:   roles/ntp/defaults/main.yml
        new file:   roles/ntp/handlers/main.yml
        new file:   roles/ntp/meta/main.yml
        new file:   roles/ntp/tasks/main.yml
        new file:   roles/ntp/templates/ntp_client.conf.j2
        new file:   roles/ntp/templates/ntp_server.conf.j2
        new file:   roles/ntp/tests/inventory
        new file:   roles/ntp/tests/test.yml
        new file:   roles/ntp/vars/main.yml
        modified:   srv.yml</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git commit -m 'Adicionada role para instalacao e configuracao do servico NTP'
[master 17486a0] Adicionada role para instalacao e configuracao do servico NTP
 12 files changed, 146 insertions(+)
 create mode 100644 roles/ntp/README.md
 create mode 100644 roles/ntp/defaults/main.yml
 create mode 100644 roles/ntp/handlers/main.yml
 create mode 100644 roles/ntp/meta/main.yml
 create mode 100644 roles/ntp/tasks/main.yml
 create mode 100644 roles/ntp/templates/ntp_client.conf.j2
 create mode 100644 roles/ntp/templates/ntp_server.conf.j2
 create mode 100644 roles/ntp/tests/inventory
 create mode 100644 roles/ntp/tests/test.yml
 create mode 100644 roles/ntp/vars/main.yml</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git push
Counting objects: 19, done.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (19/19), 1.66 KiB | 0 bytes/s, done.
Total 19 (delta 1), reused 0 (delta 0)
To nfs:/home/ansible/ansible.git
   24bcab5..17486a0  master -&gt; master</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_registro_de_comandos_digitados_com_snoopylog">5) Registro de comandos digitados com SnoopyLog</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos agora instalar o Snoopy (<a href="https://github.com/a2o/snoopy" class="bare">https://github.com/a2o/snoopy</a>), um programa bastante simples que serve para registrar todos os comandos digitados no terminal, por qualquer usuário, nos logs do sistema. Assim, é possível gerar uma trilha de auditoria de comandos para realização de análise forense e garantia de não-repúdio em caso de incidentes.</p>
<div class="paragraph">
<p>Assim como no caso no NTP, vamos automatizar a instalação e configuração desse pacote como uma <em>baseline</em> de segurança em todos os servidores (atuais e futuros) do <em>datacenter</em> usando o Ansible. Crie a <em>role</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-galaxy init --init-path=/home/ansible/ansible/roles snoopy</pre>
</div>
</div>
</li>
<li>
<p>Felizmente, a configuração do Snoopy é bem mais simples que a do OpenNTPD, já que não temos servidores/clientes distintos no inventário. Edite o arquivo <code>/home/ansible/ansible/roles/snoopy/tasks/main.yml</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Install Snoopy
  apt:
    name: snoopy
    state: present
    update_cache: true

- name: Configure ld.so.preload
  lineinfile:
    path: /etc/ld.so.preload
    line: '/lib/snoopy.so'
    insertafter: EOF
    create: yes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Novamente, usamos o módulo <code>apt</code> para instalar o pacote <code>snoopy</code>. Em seguida, adicionamos ao final do arquivo <code>/etc/ld.so.preload</code> (criando-o se ele não existir) a linha <code>/lib/snoopy.so</code>, garantindo que a biblioteca compartilhada do Snoopy será carregada antes da execução de qualquer binário no sistema&#8201;&#8212;&#8201;garantindo assim que os comandos serão de fato logados.</p>
</div>
</li>
<li>
<p>Adicione a <em>role</em> do Snoopy ao arquivo <code>/home/ansible/ansible/srv.yml</code>:</p>
<div class="literalblock">
<div class="content">
<pre>echo '    - snoopy' &gt;&gt; ~/ansible/srv.yml</pre>
</div>
</div>
</li>
<li>
<p>Finalmente, execute a <em>role</em>:</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts ~/ansible/srv.yml

PLAY [srv] **********************************************************************************************************

(...)

TASK [snoopy : Install Snoopy] **************************************************************************************

changed: [ns2]
changed: [ns1]
changed: [nfs]
changed: [log]
changed: [192.168.42.2]

TASK [snoopy : Configure ld.so.preload] *****************************************************************************

changed: [ns1]
changed: [ns2]
changed: [nfs]
changed: [log]
changed: [192.168.42.2]

PLAY RECAP **********************************************************************************************************

192.168.42.2               : ok=7    changed=3    unreachable=0    failed=0
log                        : ok=7    changed=3    unreachable=0    failed=0
nfs                        : ok=7    changed=3    unreachable=0    failed=0
ns1                        : ok=7    changed=3    unreachable=0    failed=0
ns2                        : ok=7    changed=3    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>Terá funcionado? Logue via SSH na máquina <code>ns1</code>, ainda como o usuário <code>ansible</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh ns1
Linux ns1 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

Last login: Fri Nov 16 00:16:07 2018 from 192.168.42.2
ansible@ns1:~$</pre>
</div>
</div>
<div class="paragraph">
<p>Use o comando <code>sudo -i</code> para escalar privilégio:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo -i</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, verifique o conteúdo do arquivo <code>/var/log/auth.log</code>&#8201;&#8212;&#8201;de fato, procure por linhas que possuam a <em>string</em> <code>snoopy</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># grep 'ns1 snoopy' /var/log/auth.log | grep -v '(none)'
Nov 16 00:17:07 ns1 snoopy[10150]: [uid:10005 sid:10150 tty:/dev/pts/0 cwd:/home/ansible filename:/bin/bash]: -bash Nov 16 00:17:07 ns1 snoopy[10152]: [uid:10005 sid:10150 tty:/dev/pts/0 cwd:/home/ansible filename:/usr/bin/id]: id -u
Nov 16 00:17:07 ns1 snoopy[10154]: [uid:10005 sid:10150 tty:/dev/pts/0 cwd:/home/ansible filename:/bin/ls]: ls /etc/bash_completion.d
Nov 16 00:17:07 ns1 snoopy[10156]: [uid:10005 sid:10150 tty:/dev/pts/0 cwd:/home/ansible filename:/usr/bin/dircolors]: dircolors -b
Nov 16 00:17:07 ns1 snoopy[10158]: [uid:10005 sid:10150 tty:/dev/pts/0 cwd:/home/ansible filename:/bin/ls]: ls /etc/bash_completion.d
Nov 16 00:17:11 ns1 snoopy[10161]: [uid:10005 sid:10150 tty:/dev/pts/0 cwd:/home/ansible filename:/usr/bin/sudo]: sudo -i
Nov 16 00:17:11 ns1 snoopy[10162]: [uid:0 sid:10150 tty:/dev/pts/0 cwd:/root filename:/bin/bash]: -bash
Nov 16 00:17:11 ns1 snoopy[10164]: [uid:0 sid:10150 tty:/dev/pts/0 cwd:/root filename:/usr/bin/id]: id -u
Nov 16 00:17:11 ns1 snoopy[10167]: [uid:0 sid:10150 tty:/dev/pts/0 cwd:/root filename:/bin/ls]: ls /etc/bash_completion.d
Nov 16 00:17:11 ns1 snoopy[10168]: [uid:0 sid:10150 tty:/dev/pts/0 cwd:/root filename:/usr/bin/mesg]: mesg n
Nov 16 00:20:27 ns1 snoopy[10185]: [uid:0 sid:10150 tty:/dev/pts/0 cwd:/root filename:/bin/grep]: grep ns1 snoopy /var/log/auth.log</pre>
</div>
</div>
<div class="paragraph">
<p>Note como o Snoopy registrou todos os nossos comandos desde o login no sistema&#8201;&#8212;&#8201;desde o carregamente de opções do perfil do <em>shell</em> Bash, passando pela escalação de privilégio usando o <code>sudo</code>, e chegando até o próprio <code>grep</code> que acabamos de executar!</p>
</div>
<div class="paragraph">
<p>Agora, se seus usuários fizerem qualquer ação indevida nos servidores, ficará bem mais difícil negar o ocorrido! Especialmente com o uso do concentrador de logs e SIEM que instalaremos a seguir.</p>
</div>
</li>
<li>
<p>Como fizemos mais alterações nos repositórios locais, vamos enviá-las:</p>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/ansible/ ; git add . ; git commit -m 'Adicionada role para instalacao e configuracao do Snoopy logger' ; git push
[master ada4705] Adicionada role para instalacao e configuracao do Snoopy logger
 10 files changed, 130 insertions(+)
 create mode 100644 roles/snoopy/README.md
 create mode 100644 roles/snoopy/defaults/main.yml
 create mode 100644 roles/snoopy/handlers/main.yml
 create mode 100644 roles/snoopy/meta/main.yml
 create mode 100644 roles/snoopy/tasks/main.yml
 create mode 100644 roles/snoopy/tests/inventory
 create mode 100644 roles/snoopy/tests/test.yml
 create mode 100644 roles/snoopy/vars/main.yml
 create mode 100644 srv.retry
Counting objects: 16, done.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (16/16), 1.34 KiB | 0 bytes/s, done.
Total 16 (delta 1), reused 0 (delta 0)
To nfs:/home/ansible/ansible.git
   17486a0..ada4705  master -&gt; master</pre>
</div>
</div>
<div class="paragraph">
<p>Já estamos construindo um histório interessante no repositório, não é mesmo? Confira com o <code>git log</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git log
commit ada4705b62e53e0802c06fc75e67a89d83424467
Author: Ansible &lt;ansible@intnet&gt;
Date:   Fri Nov 16 00:29:32 2018 -0200

    Adicionada role para instalacao e configuracao do Snoopy logger

commit 17486a03a71405cb22737c026f068ac0a6a17384
Author: Ansible &lt;ansible@intnet&gt;
Date:   Fri Nov 16 00:03:36 2018 -0200

    Adicionada role para instalacao e configuracao do servico NTP

commit 24bcab569ee2f9504c54a65081f75f5cd5c400e5
Author: Ansible &lt;ansible@intnet&gt;
Date:   Thu Nov 15 16:12:51 2018 -0200

    Maquina log adicionada ao inventario do Ansible

commit 0c673e48dcdc7aaf2bd6738c8033c33815f10cc6
Author: Ansible &lt;ansible@intnet&gt;
Date:   Thu Nov 15 02:04:14 2018 -0200

    Importacao inicial, role sudoers adicionada</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_instalação_e_configuração_inicial_do_graylog">6) Instalação e configuração inicial do Graylog</h3>
<div class="paragraph">
<p>Vamos proceder à instalação do SIEM <em>open-source</em> Graylog. Como a instalação será feita em uma única máquina (<code>log</code>), e realizaremos um grande número de passos, faremos o processo "à moda antiga"&#8201;&#8212;&#8201;via comandos diretos no terminal. Seguiremos os passos de instalação indicados na documentação oficial do Graylog, em <a href="http://docs.graylog.org/en/latest/pages/installation/os/debian.html" class="bare">http://docs.graylog.org/en/latest/pages/installation/os/debian.html</a> .</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Antes de mais nada desligue a VM <code>log</code>. O Graylog exige uma quantidade bastante significativa de recursos&#8201;&#8212;&#8201;na console do Virtualbox, acesse <em>Settings</em> &gt; <em>System</em> &gt; <em>Base Memory</em> e aumente-a para 4096 MB (4 GB). Em seguida, religue a VM <code>log</code> e acesse-a como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
log
root</pre>
</div>
</div>
</li>
<li>
<p>Agora, instale as dependências do Graylog com o comando a seguir:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get update ; apt-get install -y apt-transport-https openjdk-8-jre-headless uuid-runtime pwgen</pre>
</div>
</div>
</li>
<li>
<p>O próximo passo é a instalação do MongoDB, uma base de dados NoSQL <em>open-source</em> orientada ao armazenamento e gestão de documentos:</p>
<div class="literalblock">
<div class="content">
<pre># apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5
Executing: /tmp/apt-key-gpghome.yMHAQrCigl/gpg.1.sh --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5
gpg: key 58712A2291FA4AD5: public key "MongoDB 3.6 Release Signing Key &lt;packaging@mongodb.com&gt;" imported
gpg: Total number processed: 1
gpg:               imported: 1</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># echo "deb http://repo.mongodb.org/apt/debian stretch/mongodb-org/3.6 main" &gt; /etc/apt/sources.list.d/mongodb-org-3.6.list</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get update ; apt-get install -y mongodb-org</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, inicie o serviço do MongoDB:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl daemon-reload</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl enable mongod.service
Created symlink /etc/systemd/system/multi-user.target.wants/mongod.service → /lib/systemd/system/mongod.service.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart mongod.service</pre>
</div>
</div>
</li>
<li>
<p>Agora, vamos instalar o Elasticsearch, um <em>engine</em> de busca distribuída e <em>open-source</em> baseada na biblioteca Apache Lucene:</p>
<div class="literalblock">
<div class="content">
<pre># wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -
OK</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># echo "deb https://artifacts.elastic.co/packages/5.x/apt stable main" &gt; /etc/apt/sources.list.d/elastic-5.x.list</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get update ; apt-get install -y elasticsearch</pre>
</div>
</div>
<div class="paragraph">
<p>Temos que configurar o Elasticsearch para operar com o Graylog&#8201;&#8212;&#8201;para isso, basta informarmos um nome de <em>cluster</em> no arquivo de configuração <code>/etc/elasticsearch/elasticsearch.yml</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^#\(cluster\.name:\).*/\1 graylog/' /etc/elasticsearch/elasticsearch.yml</pre>
</div>
</div>
<div class="paragraph">
<p>Feito isso, basta iniciar o serviço do Elasticsearch:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl daemon-reload</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl enable elasticsearch.service
Synchronizing state of elasticsearch.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install enable elasticsearch
Created symlink /etc/systemd/system/multi-user.target.wants/elasticsearch.service → /usr/lib/systemd/system/elasticsearch.service.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart elasticsearch.service</pre>
</div>
</div>
</li>
<li>
<p>Finalmente, vamos instalar o Graylog:</p>
<div class="literalblock">
<div class="content">
<pre># wget -q https://packages.graylog2.org/repo/packages/graylog-2.4-repository_latest.deb</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># dpkg -i graylog-2.4-repository_latest.deb ; rm graylog-2.4-repository_latest.deb</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get update ; usermod -e -1 root ; apt-get install -y graylog-server ; usermod -e 0 root</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, temos que configurar uma senha randômica para garantir a segurança do armazenamento de senhas dos usuários do Graylog, bem como uma senha de acesso admnistrativo para o Graylog (como de costume, iremos usar <code>rnpesr</code>). Os comandos a seguir irão realizar essas ações:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># SECRET=$(pwgen -s 96 1) ; sed -i -e 's/password_secret =.*/password_secret = '$SECRET'/' /etc/graylog/server/server.conf ; unset SECRET</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># PASSWORD=$(echo -n 'rnpesr' | shasum -a 256 | awk '{print $1}') ; sed -i -e 's/root_password_sha2 =.*/root_password_sha2 = '$PASSWORD'/' /etc/graylog/server/server.conf ; unset PASSWORD</pre>
</div>
</div>
<div class="paragraph">
<p>O Graylog utiliza a <em>timezone</em> UTC (<em>Universal Time Coordinated</em>) como padrão, que não é a mesma que utilizamos no Brasil. Assumindo que o curso está sendo realizado no fuso de Brasília, o comando a seguir irá ajustar a <em>timezone</em> corretamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^#\(root_timezone =\).*/\1 America\/Sao\_Paulo/' /etc/graylog/server/server.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, vamos iniciar o Graylog:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl daemon-reload</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl enable graylog-server.service
Synchronizing state of graylog-server.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install enable graylog-server
Created symlink /etc/systemd/system/multi-user.target.wants/graylog-server.service → /usr/lib/systemd/system/graylog-server.service.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl start graylog-server.service</pre>
</div>
</div>
</li>
<li>
<p>Para não termos que configurar o Graylog escutando diretamente por conexões do mundo externo, iremos instalar o servidor HTTP Nginx para atuar como um <em>proxy</em> reverso, filtrando e repassando as conexões para o Graylog. Primeiro, instale o Nginx:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y nginx</pre>
</div>
</div>
<div class="paragraph">
<p>Remova o arquivo de configuração do website padrão do Nginx&#8201;&#8212;&#8201;iremos substituí-lo a seguir:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># rm /etc/nginx/sites-enabled/default</pre>
</div>
</div>
<div class="paragraph">
<p>Crie o arquivo novo <code>/etc/nginx/sites-available/graylog</code> com o conteúdo a seguir. <strong>IMPORTANTE:</strong> ao editar o arquivo abaixo, substitua as duas ocorrências da <em>string</em> <code>NS1_ENP0S3_IPADDR</code> pelo endereço da interface <code>enp0s3</code> da sua máquina <code>ns1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">server
{
  listen      80 default_server;
  listen      [::]:80 default_server ipv6only=on;
  server_name NS1_ENP0S3_IPADDR;

  location /
    {
        proxy_set_header    Host $http_host;
        proxy_set_header    X-Forwarded-Host $host;
        proxy_set_header    X-Forwarded-Server $host;
        proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header    X-Graylog-Server-URL http://NS1_ENP0S3_IPADDR:9080/api/;
        proxy_pass          http://127.0.0.1:9000;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Suponha, por exemplo, que o endereço IP da interface <code>enp0s3</code> da sua máquina <code>ns1</code> seja 200.130.46.254; você poderia usar o comando <code>sed</code> para fazer as substituições de forma automática da seguinte forma:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/NS1_ENP0S3_IPADDR/200.130.46.254/' /etc/nginx/sites-available/graylog</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, crie um link simbólico do arquivo recém-criado para o arquivo <code>/etc/nginx/sites-enabled/graylog</code>, habilitando-o no Nginx, como se segue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># p=$PWD ; cd /etc/nginx/sites-enabled/ ; ln -s ../sites-available/graylog . ; cd $p ; unset p</pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, reinicie o Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nginx</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_7_ajuste_das_regras_de_firewall_para_o_graylog">7) Ajuste das regras de firewall para o Graylog</h3>
<div class="paragraph">
<p>O uso do Graylog exigirá alguns ajustes no firewall, a saber:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Iremos acessar a interface web do Graylog a partir da máquina física, usando o endereço IP público da máquina <code>ns1</code>. Para que consigamos atingir o Graylog, será necessário criar uma regra de DNAT na tabela <code>nat</code>, <em>chain</em> PREROUTING, fazendo o redirecionamento de endereço/porta, além de uma regra na tabela <code>filter</code>, <em>chain</em> FORWARD, correspondente. Especificamente, faremos o mapeamento da porta externa 9080/TCP para a porta interna 80/TCP.</p>
</li>
<li>
<p>Máquinas na DMZ devem conseguir acessar a máquina <code>log</code> na porta 5140/UDP, para envio dos logs locais usando o Rsyslog. Como essas máquinas estão todas na mesma sub-rede, os acessos não passam pelo firewall e nenhuma configuração adicional se faz necessária.</p>
</li>
<li>
<p>Máquinas na Intranet devem conseguir acessar a máquina <code>log</code> na porta 5140/UDP, para envio dos logs locais usando o Rsyslog. Como esse tráfego passa <strong>através do</strong> firewall, devemos inserir a regra na <em>chain</em> FORWARD.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos lá: acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Para atender o requisito (a), insira as regras:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A PREROUTING -i enp0s3 -p tcp -m tcp --dport 9080 -j DNAT --to-destination 10.0.42.4:80</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -i enp0s3 -d 10.0.42.4/32 -p tcp -m tcp --dport 80 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Para o requisito (b), nenhuma ação é necessária. Finalmente, para o requisito (c) insira a regra a seguir:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -s 192.168.42.0/24 -d 10.0.42.4/32 -p udp -m udp --dport 5140 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Grave as novas regras na configuração permanente do firewall:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent save
[....] Saving netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save
done.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_8_visualizando_logs_de_máquinas_no_graylog">8) Visualizando logs de máquinas no Graylog</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Tudo pronto? Vamos acessar a interface do Graylog: em sua máquina física, abra o navegador e aponte-o para <a href="http://NS1_ENP0S3_IPADDR:9080" class="bare">http://NS1_ENP0S3_IPADDR:9080</a> (substitua a <em>string</em> <code>NS1_ENP0S3_IPADDR</code> pelo endereço IP da interface <code>enp0s3</code> da sua máquina <code>ns1</code>). Você deverá ver a tela a seguir:</p>
<div id="img-graylog1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog1.png" alt="graylog1">
</div>
<div class="title">Figure 31. Tela de login do Graylog</div>
</div>
<div class="paragraph">
<p>Faça login com o usuário <code>admin</code> e senha <code>rnpesr</code>, como definimos anteriormente.</p>
</div>
</li>
<li>
<p>Vamos fazer alguns ajustes iniciais. Acesse o menu <em>System</em> &gt; <em>Indices</em> e clique em <em>Edit</em>. Na nova tela, configure o valor do campo <em>Index Shards</em> como 1, e em seguida clique em <em>Save</em> na base da página. Como estamos em um ambiente simulado, essa configuração irá auxiliar na economia de recursos da máquina.</p>
</li>
<li>
<p>Agora, acesse o menu <em>System</em> &gt; <em>Inputs</em>. Na caixa <em>Select input</em> desça a barra de rolagem, selecione a opção <em>Syslog UDP</em> e clique em <em>Launch new input</em>.</p>
<div class="paragraph">
<p>Na nova janela, clique no campo <em>Select Node</em> e selecione a única opção disponível; no campo <em>Title</em> , escreva <code>syslog</code>; em <em>Bind address</em>, digite o endereço local da máquina, <code>10.0.42.4</code>; finalmente, no campo <em>Port</em> informe o valor <code>5140</code>. Sua tela deve ficar assim:</p>
</div>
<div id="img-graylog2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog2.png" alt="graylog2">
</div>
<div class="title">Figure 32. Criação de um input Syslog/UDP no Graylog</div>
</div>
<div class="paragraph">
<p>Na base da janela, clique em <em>Save</em>.</p>
</div>
</li>
<li>
<p>O <em>input</em> via Syslog está configurado; temos, agora, que configurar o envio de logs para esse <em>input</em>. Novamente, o Ansible é a ferramenta para a tarefa.</p>
<div class="paragraph">
<p>Acesse a máquina <code>client</code> como o usuário <code>ansible</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos criar uma <em>role</em> que envie todos os logs das máquinas do <em>datacenter</em> para o <em>input</em> que configuramos no Graylog:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-galaxy init --init-path /home/ansible/ansible/roles/ syslog
- syslog was created successfully</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos usar uma técnica similar à que fizemos no caso do NTP: insira um novo grupo, <code>log_server</code>, no inventário do Ansible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ echo -e '\n[log_server]\nlog' &gt;&gt; ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/ansible/hosts
[srv]
ns1
ns2
nfs
192.168.42.2
log

[ntp_server]
log

[log_server]
log</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, edite o arquivo <code>/home/ansible/ansible/roles/syslog/vars/main.yml</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
logsrv: "{{ groups['log_server'][0] }}.intnet"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Onde vamos chegar com isso? Edite o arquivo <code>/home/ansible/ansible/roles/syslog/tasks/main.yml</code> com o seguinte conteúdo e confira:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Configure centralized syslog
  lineinfile:
    path: /etc/rsyslog.d/99-graylog.conf
    line: '*.* @{{ logsrv }}:5140;RSYSLOG_SyslogProtocol23Format'
    insertafter: EOF
    create: yes
  notify:
    - Restart Rsyslog</code></pre>
</div>
</div>
<div class="paragraph">
<p>A tarefa acima irá criar o arquivo <code>/etc/rsyslog.d/99-graylog.conf</code>, se inexistente, em todos os <em>hosts</em> aplicáveis e instruir o Rsyslog a enviar todos os logs para a máquina <code>logsrv</code> (que definimos no arquivo <code>vars</code>, acima) na porta 5140/UDP. Feito isso, chama-se um <em>handler</em> que reinicia o Rsyslog.</p>
</div>
<div class="paragraph">
<p>É claro, temos que criar o <em>handler</em>. Edite o arquivo <code>/home/ansible/ansible/roles/syslog/handlers/main.yml</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Restart Rsyslog
  service:
    name: rsyslog
    state: restarted</code></pre>
</div>
</div>
<div class="paragraph">
<p>O de sempre: usamos o módulo <code>service</code> para reiniciar o Rsyslog local. Adicione a nova <em>role</em> ao arquivo de amarração de inventário <code>/home/ansible/ansible/srv.yml</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ echo '    - syslog' &gt;&gt; ~/ansible/srv.yml</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos testar? Dispare a <em>role</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts ~/ansible/srv.yml

PLAY [srv] **********************************************************************************************************

(...)

TASK [syslog : Configure centralized syslog] ************************************************************************

changed: [ns1]
changed: [ns2]
changed: [nfs]
changed: [192.168.42.2]
changed: [log]

RUNNING HANDLER [syslog : Restart Rsyslog] **************************************************************************

changed: [nfs]
changed: [ns1]
changed: [ns2]
changed: [192.168.42.2]
changed: [log]

PLAY RECAP **********************************************************************************************************

192.168.42.2               : ok=9    changed=3    unreachable=0    failed=0
log                        : ok=9    changed=3    unreachable=0    failed=0
nfs                        : ok=9    changed=3    unreachable=0    failed=0
ns1                        : ok=9    changed=3    unreachable=0    failed=0
ns2                        : ok=9    changed=3    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>Como de costume, não se esqueça de enviar as mudanças para o repositório remoto do Git:</p>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/ansible/ ; git add . ; git commit -m 'Adicionada role para envio de logs para o servidor Graylog' ; git push
[master b1e7a24] Adicionada role para envio de logs para o servidor Graylog
 10 files changed, 127 insertions(+)
 create mode 100644 roles/syslog/README.md
 create mode 100644 roles/syslog/defaults/main.yml
 create mode 100644 roles/syslog/handlers/main.yml
 create mode 100644 roles/syslog/meta/main.yml
 create mode 100644 roles/syslog/tasks/main.yml
 create mode 100644 roles/syslog/tests/inventory
 create mode 100644 roles/syslog/tests/test.yml
 create mode 100644 roles/syslog/vars/main.yml
Counting objects: 16, done.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (16/16), 1.39 KiB | 0 bytes/s, done.
Total 16 (delta 3), reused 0 (delta 0)
To nfs:/home/ansible/ansible.git
   ada4705..b1e7a24  master -&gt; master</pre>
</div>
</div>
</li>
<li>
<p>Volte para o navegador em sua máquina física, e acesse a aba <em>Search</em>. Você deverá ver algo parecido com a imagem abaixo:</p>
<div id="img-graylog3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog3.png" alt="graylog3">
</div>
<div class="title">Figure 33. Visualização de logs remotos no Graylog</div>
</div>
<div class="paragraph">
<p>Legal, não é mesmo? O Graylog está recebendo todos os logs enviados pelos servidores do <em>datacenter</em> (e também da máquina <code>client</code>), tornando-os acessíveis de forma fácil e pesquisável através de uma interface bastante poderosa.</p>
</div>
<div class="paragraph">
<p>Vamos testar, por exemplo, as funções de busca do Graylog. Faça um login via SSH na máquina <code>ns1</code>, e <code>sudo</code> para <code>root</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ssh ns1
Linux ns1 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

Last login: Fri Nov 16 02:07:12 2018 from 192.168.42.2
ansible@ns1:~$</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo -i</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, volte à interface web do Graylog e busque (no canto superior esquerdo da tela, num campo identificado por uma lupa de cor verde) pelo termo <code>source:ns1 AND application_name:snoopy</code>. Esse termo de busca irá mostrar todos os logs oriundos da máquina <code>ns1</code> e que tenham sido gerados pela aplicação Snoopy, como vemos abaixo:</p>
</div>
<div id="img-graylog4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog4.png" alt="graylog4">
</div>
<div class="title">Figure 34. Filtros de busca no Graylog</div>
</div>
<div class="paragraph">
<p>Vamos um passo além: imagine que você quer encontrar todos os eventos de <code>sudo</code> executados na máquina <code>ns1</code>. Expanda o termo de busca para <code>source:ns1 AND application_name:snoopy AND message:sudo</code>. Você deverá encontrar o evento de escalação de privilégio que fizemos logo acima&#8201;&#8212;&#8201;clique sobre o evento para expandir os campos do log:</p>
</div>
<div id="img-graylog5" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog5.png" alt="graylog5">
</div>
<div class="title">Figure 35. Visualizando eventos específicos</div>
</div>
<div class="paragraph">
<p>Note que a mensagem mostra, inclusive, o UID do usuário que executou o comando: 10005. Conseguimos descobrir nosso "culpado" facilmente, consultando a base de usuários do LDAP:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ getent passwd | grep 10005
ansible:*:10005:10001:ansible:/home/ansible:/bin/bash</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_9_autenticação_centralizada_via_ldap_no_graylog">9) Autenticação centralizada via LDAP no Graylog</h3>
<div class="paragraph">
<p>Estamos usando o usuário <code>admin</code> para realizar todas as ações no Graylog, o que obviamente não é sustentável&#8201;&#8212;&#8201;e se quisermos que vários colaboradores tenham acesso à ferramenta e possam pesquisar eventos e investigar logs dos sistemas? Felizmente, a integração do Graylog com sistemas externos de autenticação, como o LDAP, é bastante fácil.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acesse o menu <em>System</em> &gt; <em>Authentication</em>. Na aba à esquerda, selecione <em>LDAP/Active Directory</em> e clique na caixa <em>Enable LDAP</em>.</p>
</li>
<li>
<p>Em <em>Server configuration</em>, mantenha <em>Server Type</em> como LDAP; em <em>Server Address</em>, digite <code>ldap://ldap.intnet:389</code>; informe <em>System Username</em> como <code>cn=admin,dc=intnet</code>; finalmente, em <code>System Password</code> digite <code>rnpesr</code>.</p>
<div class="paragraph">
<p>Clique em <em>Test Server Connection</em> para verificar a correta conexão com o servidor LDAP.</p>
</div>
</li>
<li>
<p>Continuando, em <em>User Mapping</em> defina <em>Search Base DN</em> como <code>ou=People,dc=intnet</code>; em <em>User Search Pattern</em>, digite <code>(&amp;(objectClass=posixAccount)(uid={0}))</code>; depois, em <em>Display Name Attribute</em> informe <code>cn</code>.</p>
<div class="paragraph">
<p>Até o momento, sua tela de configuração deverá estar da seguinte forma:</p>
</div>
<div id="img-graylog6" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog6.png" alt="graylog6">
</div>
<div class="title">Figure 36. Configuração do Graylog com o LDAP, parte 1</div>
</div>
</li>
<li>
<p>Em <em>Group Mapping</em>, defina <em>Group Search Base DN</em> como <code>ou=Groups,dc=intnet</code>; em <em>Group Search Pattern</em>, digite <code>(objectClass=posixGroup)</code>; para <em>Group Name Attribute</em>, informe <code>cn</code>; finalmente, mantenha <em>Default User Role</em> como <em>Reader - basic access</em>.</p>
<div class="paragraph">
<p>A segunda parte da tela de configuração ficará assim:</p>
</div>
<div id="img-graylog7" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog7.png" alt="graylog7">
</div>
<div class="title">Figure 37. Configuração do Graylog com o LDAP, parte 2</div>
</div>
<div class="paragraph">
<p>Na base da tela, clique em <em>Save LDAP settings</em>.</p>
</div>
</li>
<li>
<p>Após salvar as configurações, note que em <em>Group Mapping</em> &gt; <em>Default User Role</em> há um link destacado em azul que diz <em>mapping LDAP groups to Graylog roles</em>&#8201;&#8212;&#8201;clique neste link. Você verá a tela abaixo:</p>
<div id="img-graylog8" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog8.png" alt="graylog8">
</div>
<div class="title">Figure 38. Mapeamento de grupos do LDAP e roles no Graylog</div>
</div>
<div class="paragraph">
<p>Mapeie o grupo <code>sysadm</code> com a <em>role</em> <code>Admin</code>, e clique em <em>Save</em>. Depois, no canto superior da tela, clique em <em>Administrator</em> &gt; <em>Logout</em>.</p>
</div>
</li>
<li>
<p>Vamos testar? Logue com o usuário <code>luke</code>, membro do grupo <code>sysadm</code>. Use a mesma senha do usuário no LDAP. Observe o nível de acesso do usuário&#8201;&#8212;&#8201;ele consegue ver todas as abas e configurações às quais o usuário <code>admin</code> possui acesso.</p>
<div class="paragraph">
<p>Agora, faça logout e acesse como o usuário <code>han</code>. Note: apenas um pequeno número de abas e opções estão disponíveis, e todas como somente leitura. O usuário possui acesso apenas a <em>streams</em> de logs e <em>dashboards</em> pré-configurados pelo administrador, e não consegue alterar quaisquer configurações do sistema.</p>
</div>
<div class="paragraph">
<p>O sistema de <em>roles</em> do Graylog é bastante poderoso, permitindo a customização do nível de acesso de usuários com boa granularidade.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_10_configurando_inputs_customizados_no_graylog">10) Configurando inputs customizados no Graylog</h3>
<div class="paragraph">
<p>Acesse o Graylog novamente com o usuário <code>admin</code> (ou <code>luke</code>, se preferir). Busque por mensagens com o padrão <code>source:ns2 AND application_name:slapd AND message:dc\=intnet</code>, e expanda uma qualquer, como mostrado abaixo:</p>
</div>
<div id="img-graylog9" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog9.png" alt="graylog9">
</div>
<div class="title">Figure 39. Mensagens não interpretadas pelo Graylog</div>
</div>
<div class="paragraph">
<p>Observe: a mensagem acima é proveniente do log do OpenLDAP, e possui várias informações relevantes no campo <code>message</code>&#8201;&#8212;&#8201;temos a base de busca, escopo e filtro utilizado. Porém, como o Graylog não está configurado para processar e interpretar a mensagem acima, todos os campos ficam agrupados em uma "massa" única, dificultando operações de busca e criação de filtros e alertas. Não podemos, por exemplo, usar um termo como <code>filter:uid\=ansible</code> no campo de busca do Graylog.</p>
</div>
<div class="paragraph">
<p>Vamos instalar um <em>content pack</em> para o Graylog que irá instruí-lo sobre como processar logs de aplicações específicas; usaremos, para o nosso exemplo, o servidor web Nginx que está instalado na máquina <code>log</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>No navegador em sua máquina física, faça o download do arquivo <a href="https://raw.githubusercontent.com/graylog-labs/graylog-contentpack-nginx/master/content_pack.json" class="bare">https://raw.githubusercontent.com/graylog-labs/graylog-contentpack-nginx/master/content_pack.json</a> para sua Área de Trabalho.</p>
</li>
<li>
<p>Na interface web do Graylog, acesse <em>System</em> &gt; <em>Content Packs</em>. Clique na caixa <em>Import Content Pack</em> e em seguida em <em>Choose File</em>, apontando o arquivo que baixamos no passo anterior. Depois, clique em <em>Upload</em>.</p>
<div class="paragraph">
<p>Uma nova caixa, <em>Web Servers</em>, irá surgir. Clique nessa caixa, marque o botão <em>nginx</em> e, na aba à direita, clique em <em>Apply Content</em>.</p>
</div>
</li>
<li>
<p>Vá para <em>System</em> &gt; <em>Inputs</em>, e note que temos dois novos <em>inputs</em>, <code>nginx access_log</code> e <code>nginx error_log</code>. Em ambos, clique no botão <em>Start Input</em>&#8201;&#8212;&#8201;frequentemente, essa operação irá reportar erro. Se for esse o caso, acesse a máquina <code>log</code> como o usuário <code>root</code> e reinicie o <em>daemon</em> do Graylog:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
log
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart graylog-server</pre>
</div>
</div>
<div class="paragraph">
<p>Após o reinício, volte a <em>System</em> &gt; <em>Inputs</em> e verifique que ambos os novos <em>inputs</em> estão em estado RUNNING, como mostrado abaixo:</p>
</div>
<div id="img-graylog10" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog10.png" alt="graylog10">
</div>
<div class="title">Figure 40. Inputs do nginx ativos</div>
</div>
</li>
<li>
<p>Agora, temos que instruir o Nginx instalado na máquina <code>log</code> a enviar seus logs para os <em>inputs</em> que acabamos de configurar. Vamos ao Ansible!</p>
<div class="paragraph">
<p>Acesse a máquina <code>client</code> como o usuário <code>ansible</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos criar uma <em>role</em> que envie os logs de acesso e erro do Nginx de servidores web do <em>datacenter</em> para o <em>input</em> que configuramos no Graylog:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-galaxy init --init-path /home/ansible/ansible/roles/ nginxlog
- nginxlog was created successfully</pre>
</div>
</div>
<div class="paragraph">
<p>Desta vez, apenas um subconjunto de máquinas do <em>datacenter</em> deve ser o alvo da nossa <em>role</em>. Crie o novo grupo <code>web_server</code> no inventário do Ansible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ echo -e '\n[web_server]\nlog' &gt;&gt; ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/ansible/hosts
[srv]
ns1
ns2
nfs
192.168.42.2
log

[ntp_server]
log

[log_server]
log

[web_server]
log</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, edite o arquivo <code>/home/ansible/ansible/roles/nginxlog/vars/main.yml</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
logsrv: "{{ groups['log_server'][0] }}.intnet"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sem surpresas até aí&#8201;&#8212;&#8201;queremos configurar o envio de logs para o concentrador de eventos da rede, que está no grupo <code>log_server</code>. Vamos editar o <em>template</em> de configuração do Nginx que irá usar a variável acima: crie o arquivo novo <code>/home/ansible/ansible/roles/nginxlog/templates/nginx_graylog.conf.j2</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">log_format  graylog2_format  '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for" &lt;msec=$msec|connection=$connection|connection_requests=$connection_requests|cache_status=$upstream_cache_status|cache_control=$upstream_http_cache_control|expires=$upstream_http_expires|millis=$request_time&gt;';

access_log syslog:server={{ logsrv }}:12301 graylog2_format;
error_log syslog:server={{ logsrv }}:12302;</code></pre>
</div>
</div>
<div class="paragraph">
<p>O arquivo acima será incluído na configuração padrão do Nginx instalado na máquina <code>log</code> (e, de fato, de qualquer outro servidor web futuro que adicionemos ao <em>datacenter</em>), informando que os logs de acesso e erros devem ser enviados para a máquina remota <code>logsrv</code> (variável que definimos no arquivo <code>vars</code>, acima) num formato compatível com o esperado pelo processador do Graylog.</p>
</div>
<div class="paragraph">
<p>Vamos às tarefas: edite o arquivo <code>/home/ansible/ansible/roles/nginxlog/tasks/main.yml</code> com o seguinte conteúdo e confira:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Setup Nginx &lt;&gt; Graylog logging
  template:
    src: nginx_graylog.conf.j2
    dest: /etc/nginx/conf.d/99-graylog.conf
    owner: root
    group: root
    mode: 0644
  notify:
    - Restart Nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando o módulo <code>template</code>, a <em>task</em> acima copia o <em>template</em> que configuramos anteriormente para o diretório <code>/etc/nginx/conf.d</code> (o qual é incluído pelo arquivo-padrão <code>/etc/nginx/nginx.conf</code>), ajusta suas permissões e reinicia o <em>daemon</em> do Nginx.</p>
</div>
<div class="paragraph">
<p>É claro, temos que criar o <em>handler</em>. Edite o arquivo <code>/home/ansible/ansible/roles/nginxlog/handlers/main.yml</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Restart Nginx
  service:
    name: nginx
    state: restarted</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nada de novo: usamos o módulo <code>service</code> para reiniciar o Nginx após a execução da <em>task</em>.</p>
</div>
<div class="paragraph">
<p>Como essa nova <em>role</em> se aplica apenas a um subconjunto de <em>hosts</em> do inventário (os membros do grupo <code>web_server</code>), vamos adicionar uma nova seção ao <em>playbook</em> <code>/home/ansible/ansible/srv.yml</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat &lt;&lt; EOF &gt;&gt; ~/ansible/srv.yml

- hosts: web_server
  become: yes
  become_user: root
  become_method: sudo
  roles:
    - nginxlog
EOF</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/ansible/srv.yml
---
- hosts: srv
  become: yes
  become_user: root
  become_method: sudo
  roles:
    - sudoers
    - ntp
    - snoopy
    - syslog

- hosts: web_server
  become: yes
  become_user: root
  become_method: sudo
  roles:
    - nginxlog</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, vamos executar o <em>playbook</em>. Como apenas a máquina <code>log</code> será alvo das modificações que fizemos, o uso da opção <code>--limit</code> (ou, de forma mais simples, <code>-l</code>) é interessante para acelerar a execução do Ansible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts ~/ansible/srv.yml -l web_server

PLAY [srv] **********************************************************************************************************

(...)

PLAY [web_server] ***************************************************************************************************


TASK [Gathering Facts] **********************************************************************************************

ok: [log]

TASK [nginxlog : Setup Nginx &lt;&gt; Graylog logging] ********************************************************************

changed: [log]

RUNNING HANDLER [nginxlog : Restart Nginx] **************************************************************************

changed: [log]

PLAY RECAP **********************************************************************************************************

log                        : ok=11   changed=3    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>E agora? Se temos alterações no repositório local, é hora de enviá-las para o Git remoto:</p>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/ansible/ ; git add . ; git commit -m 'Adicionada role para envio de logs formatados do Nginx de servidores web para o servidor Graylog' ; git push
[master ad7b12d] Adicionada role para envio de logs formatados do Nginx de servidores web para o servidor Graylog
 11 files changed, 138 insertions(+)
 create mode 100644 roles/nginxlog/README.md
 create mode 100644 roles/nginxlog/defaults/main.yml
 create mode 100644 roles/nginxlog/handlers/main.yml
 create mode 100644 roles/nginxlog/meta/main.yml
 create mode 100644 roles/nginxlog/tasks/main.yml
 create mode 100644 roles/nginxlog/templates/nginx_graylog.conf.j2
 create mode 100644 roles/nginxlog/tests/inventory
 create mode 100644 roles/nginxlog/tests/test.yml
 create mode 100644 roles/nginxlog/vars/main.yml
Counting objects: 16, done.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (16/16), 1.69 KiB | 0 bytes/s, done.
Total 16 (delta 2), reused 0 (delta 0)
To nfs:/home/ansible/ansible.git
   b1e7a24..ad7b12d  master -&gt; master</pre>
</div>
</div>
</li>
<li>
<p>Vamos voltar para o Graylog. Em seu navegador, vá para <em>System</em> &gt; <em>Inputs</em> e em <code>nginx access_log</code>, clique no botão <em>Show received messages</em>.</p>
<div id="img-graylog11" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog11.png" alt="graylog11">
</div>
<div class="title">Figure 41. Recebimento de logs formatados do Nginx</div>
</div>
<div class="paragraph">
<p>Primeiro bom sinal: os logs do Nginx estão sendo recebidos e processados pelo <em>input</em> do Graylog, o que significa que nossa <em>role</em> no Ansible funcionou a contento. Mas, tirando esse fato, o que mudou? As mensagens mostradas pelo Graylog parecem, em grande parte, as mesmas de antes.</p>
</div>
</li>
<li>
<p>Expanda um dos eventos de log recebidos pelo Graylog nesse <em>input</em> <code>nginx access_log</code>, como mostrado abaixo:</p>
<div id="img-graylog12" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/graylog12.png" alt="graylog12">
</div>
<div class="title">Figure 42. Processamento de campos individuais em mensagens</div>
</div>
<div class="paragraph">
<p>Observe o evento acima, e compare-o com o do OpenLDAP que analisamos no começo desta atividade&#8201;&#8212;&#8201;em lugar de um campo <code>message</code> pouco específico, temos agora um grande conjunto de campos pesquisáveis, como:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>http_referer</code></p>
</li>
<li>
<p><code>http_user_agent</code></p>
</li>
<li>
<p><code>remote_addr</code></p>
</li>
<li>
<p><code>request_path</code></p>
</li>
<li>
<p><code>request_verb</code></p>
</li>
<li>
<p><code>response_bytes</code></p>
</li>
<li>
<p><code>response_status</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Todos esses campos são extremamente relevantes em um pacote HTTP, e seu processamento e pesquisa facilita enormemente o trabalho do analista de segurança. E se quisermos descobrir quais pacotes com método POST foram enviados para uma URL específica do servidor web, filtrando pelo IP de origem? Com os campos acima, pesquisas complexas como essa tornam-se totalmente viáveis.</p>
</div>
</li>
<li>
<p>Encerradas as nossas atividades com o Graylog, recomenda-se que o aluno mantenha a máquina <code>log</code> desligada a partir desta sessão. Apesar de ser interessante que recuperemos os logs de todas as VMs do <em>datacenter</em> simulado para análise, o fato de essa máquina exigir 4 GB de memória RAM para operar a contento torna-a um peso muito grande na execução das atividades das próximas sessões.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>O <em>Content Pack</em> que estamos usando para processar essas mensagens do Graylog é um entre muitos que podem ser encontrados no <em>Graylog Marketplace</em>: <a href="https://marketplace.graylog.org/" class="bare">https://marketplace.graylog.org/</a> . Esse website contém centenas de <em>add-ons</em> e <em>plugins</em> para as versões gratuita e empresarial do Graylog, que permitem estender suas funcionalidades de forma conveniente.</p>
</div>
<div class="paragraph">
<p>A construção de expressões regulares e regras de processamento de logs para o Graylog é um trabalho árduo, porém necessário para tornar a ferramenta SIEM verdadeiramente efetiva e produtiva para os analistas de segurança. Para facilitar seu trabalho, consulte o nome das ferramentas mais utilizadas na sua organização no <em>Graylog Marketplace</em>&#8201;&#8212;&#8201;quem sabe algum outro usuário já fez um <em>plugin</em> que irá facilitar bastante seu trabalho de integração?</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_7_hardening_de_sistemas_web">Sessão 7: Hardening de sistemas web</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nesta sessão, iremos configurar um website usando o CMS Wordpress seguindo as melhores práticas de segurança, bem como tornando-o altamente disponível através do balanceamento de carga em múltiplos nodos de <em>frontend</em> web.</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão_6">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>Criaremos quatro novas máquinas nesta sessão, a saber:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>www1</code>, primeiro nodo de atendimento web, instalado manualmente. Endereço IP 10.0.42.5/24.</p>
</li>
<li>
<p><code>www2</code>, segundo nodo de atendimento web, instalado de forma automática via Ansible. Endereço IP 10.0.42.6/24.</p>
</li>
<li>
<p><code>db</code>, servidor de banco de dados para as máquinas <code>www1</code> e <code>www2</code>. Endereço IP 10.0.42.7/24.</p>
</li>
<li>
<p><code>lb</code>, balanceador de carga HTTP/HTTPS que redirecionará requisições para as VMs <code>www1</code> e <code>www2</code>. Endereço IP 10.0.42.8/24.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Temos que criar quatro novos registros DNS diretos e reversos. Acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo de zonas <code>/etc/nsd/zones/intnet.zone</code>, inserindo entradas A para a máquinas indicadas no começo desta atividade. <strong>Não se esqueça</strong> de incrementar o valor do serial no topo do arquivo!</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/intnet.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep 'www1\|www2\|db\|lb' /etc/nsd/zones/intnet.zone
www1    IN    A                 10.0.42.5
www2    IN    A                 10.0.42.6
db      IN    A                 10.0.42.7
lb      IN    A                 10.0.42.8</pre>
</div>
</div>
<div class="paragraph">
<p>Faça o mesmo para o arquivo de zona reversa:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/10.0.42.zone</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep 'www1\|www2\|db\|lb' /etc/nsd/zones/10.0.42.zone
5       IN   PTR                www1.intnet.
6       IN   PTR                www2.intnet.
7       IN   PTR                db.intnet.
8       IN   PTR                lb.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>Assine o arquivo de zonas usando o <em>script</em> criado anteriormente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash /root/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 0 rrsets, 0 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a criação das entradas usando o comando <code>dig</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># for host in www1 www2 db lb; do echo -n "$host: "; dig ${host}.intnet +short; done
www1: 10.0.42.5
www2: 10.0.42.6
db: 10.0.42.7
lb: 10.0.42.8</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># for ip in 5 6 7 8; do echo -n "10.0.42.${ip}: "; dig -x 10.0.42.${ip} +short; done
10.0.42.5: www1.intnet.
10.0.42.6: www2.intnet.
10.0.42.7: db.intnet.
10.0.42.8: lb.intnet.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_2_configuração_do_servidor_de_banco_de_dados">2) Configuração do servidor de banco de dados</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos começar criando a máquina que atuará como servidor de banco de dados em nossa topologia. Clone a máquina <code>debian-template</code> para uma nova, de nome <code>db</code>, com uma única interface de rede conectada à DMZ. O IP da máquina será 10.0.42.7/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue a máquina e logue como <code>root</code>. Depois, use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h db -i 10.0.42.7 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ip addr show label 'enp0s*' | grep 'inet ' | awk '{print $2,$NF}' ; hostname ; whoami
10.0.42.7/24 enp0s3
db
root</pre>
</div>
</div>
</li>
<li>
<p>Vamos aplicar à máquina <code>db</code> o <em>baseline</em> de segurança que configuramos no Ansible: <code>sudo</code>, OpenNTPD, Snoopy e Rsyslog centralizado. Acesse a máquina <code>client</code> como o usuário <code>ansible</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Insira a máquina <code>db</code> no inventário gerenciado pelo Ansible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\[srv\]/a db' ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/ansible/hosts
[srv]
db
ns1
ns2
nfs
192.168.42.2
log

[ntp_server]
log

[log_server]
log

[web_server]
log</pre>
</div>
</div>
<div class="paragraph">
<p>Execute o <em>playbook</em> <code>/home/ansible/ansible/srv.yml</code>, limitando o escopo à máquina <code>db</code> e alterando a escala de privilégio para o <code>su</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l db -Ke ansible_become_method=su ~/ansible/srv.yml
SUDO password:

PLAY [srv] **********************************************************************************************************


TASK [Gathering Facts] **********************************************************************************************

ok: [db]

TASK [sudoers : Propagate sudoers configuration] ********************************************************************

changed: [db]

TASK [sudoers : Sets root account as expired] ***********************************************************************

changed: [db]

TASK [ntp : Install OpenNTPD] ***************************************************************************************

fatal: [db]: FAILED! =&gt; {"changed": false, "module_stderr": "Shared connection to db closed.\r\n", "module_stdout": "\r\nSua conta expirou; entre em contato com o administrador do sistema\r\nsu: Falha de autenticação\r\n", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}
        to retry, use: --limit @/home/ansible/ansible/srv.retry

PLAY RECAP **********************************************************************************************************

db                         : ok=3    changed=2    unreachable=0    failed=1</pre>
</div>
</div>
<div class="paragraph">
<p>A <em>role</em> irá falhar no passo de instalação do OpenNTPD, pois neste momento o <code>sudo</code> acaba de ser configurado e a conta do usuário <code>root</code>, expirada. Execute o <em>playbook</em> novamente, desta vez sem customizar o método de escalação de privilégio:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l db ~/ansible/srv.yml

PLAY [srv] **********************************************************************************************************


TASK [Gathering Facts] **********************************************************************************************

ok: [db]

TASK [sudoers : Propagate sudoers configuration] ********************************************************************

ok: [db]

TASK [sudoers : Sets root account as expired] ***********************************************************************

changed: [db]

TASK [ntp : Install OpenNTPD] ***************************************************************************************

changed: [db]

TASK [ntp : Copy OpenNTPD configuration] ****************************************************************************

changed: [db]

TASK [snoopy : Install Snoopy] **************************************************************************************

changed: [db]

TASK [snoopy : Configure ld.so.preload] *****************************************************************************

changed: [db]

TASK [syslog : Configure centralized syslog] ************************************************************************

changed: [db]

RUNNING HANDLER [ntp : Restart OpenNTPD] ****************************************************************************

changed: [db]

RUNNING HANDLER [syslog : Restart Rsyslog] **************************************************************************

changed: [db]

PLAY [web_server] ***************************************************************************************************

skipping: no hosts matched

PLAY RECAP **********************************************************************************************************

db                         : ok=10   changed=8    unreachable=0    failed=0</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito, a máquina está configurada para operar em nosso <em>datacenter</em>.</p>
</div>
</li>
<li>
<p>Agora, acesse a máquina <code>db</code> como o usuário <code>root</code>. Vamos instalar o SGBD MariaDB:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
db
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># usermod -e -1 root ; apt-get install -y --no-install-recommends mariadb-server ; usermod -e 0 root</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar uma base de dados para nosso website, com o nome <code>seg10web</code>. Para acessar a base, criaremos um usuário <code>seg10user</code>, com senha <code>seg10pass</code>. Execute os comandos a seguir:</p>
<div class="literalblock">
<div class="content">
<pre># mysql -u root
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 2
Server version: 10.1.26-MariaDB-0+deb9u1 Debian 9.1

Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>MariaDB [(none)]&gt; create database seg10web;
Query OK, 1 row affected (0.00 sec)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>MariaDB [(none)]&gt; grant all on seg10web.* to seg10user@localhost identified by 'seg10pass';
Query OK, 0 rows affected (0.00 sec)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>MariaDB [(none)]&gt; grant all on seg10web.* to seg10user@'10.0.42.%' identified by 'seg10pass';
Query OK, 0 rows affected (0.00 sec)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>MariaDB [(none)]&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>MariaDB [(none)]&gt; quit
Bye</pre>
</div>
</div>
<div class="paragraph">
<p>Note que demos permissão para login a partir de <em>localhost</em>, e também da rede 10.0.42.0/24&#8201;&#8212;&#8201;logins oriundos de qualquer outro IP serão negados.</p>
</div>
</li>
<li>
<p>O MariaDB escuta apenas a conexões vindas de <em>localhost</em>, por padrão. Vamos corrigir isso:</p>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^\(bind-address[\t ]*\=\).*/\1 0.0.0.0/' /etc/mysql/mariadb.conf.d/50-server.cnf</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart mariadb</pre>
</div>
</div>
<div class="paragraph">
<p>Note que o SGBD está escutando em todas as interfaces:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ss -tnlp | grep 3306
LISTEN     0      80           *:3306                     *:*                   users:(("mysqld",pid=3579,fd=17))</pre>
</div>
</div>
<div class="paragraph">
<p>Essa é uma limitação do MariaDB/MySQL&#8201;&#8212;&#8201;apenas uma interface pode ser especificada na diretiva <code>bind-address</code> do arquivo de configuração. Se for necessário escutar em mais de uma interface de rede, e necessário especificar o <em>catch-all</em> 0.0.0.0 (referência: <a href="https://mariadb.com/kb/en/library/configuring-mariadb-for-remote-client-access/" class="bare">https://mariadb.com/kb/en/library/configuring-mariadb-for-remote-client-access/</a>).</p>
</div>
</li>
<li>
<p>Para consertar essa limitação, vamos usar o firewall local. Insira uma regra que permite que as máquinas <em>localhost</em>, <code>www1</code> e <code>www2</code> conectem-se ao SGBD, e nenhuma outra:</p>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -i lo -p tcp -m tcp --dport 3306 -j ACCEPT</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -s 10.0.42.5,10.0.42.6 -p tcp -m tcp --dport 3306 -j ACCEPT</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A INPUT -p tcp --dport 3306 -j DROP</pre>
</div>
</div>
</li>
<li>
<p>Para manter as regras entre <em>reboots</em>, instale o pacote <code>iptables-persistent</code>:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y iptables-persistent</pre>
</div>
</div>
<div class="paragraph">
<p>Na instalação do pacote, quando perguntado, responda:</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 65%;">
<caption class="title">Table 9. Configurações do iptables-persistent</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pergunta</th>
<th class="tableblock halign-left valign-top">Resposta</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Salvar as regras IPv4 atuais?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sim</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Salvar as regras IPv6 atuais?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sim</p></td>
</tr>
</tbody>
</table>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_configuração_do_servidor_web_www1">4) Configuração do servidor web www1</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Agora, vamos para o primeiro servidor web. Clone a máquina <code>debian-template</code> para uma de nome <code>www1</code>, com uma única interface de rede conectada à DMZ. O IP da máquina será 10.0.42.5/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue a máquina e logue como <code>root</code>. Depois, use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática, como de costume.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h www1 -i 10.0.42.5 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Para aplicar o <em>baseline</em> de segurança via Ansible à máquina <code>www1</code>, repita o que fizemos no passo (2) da atividade (2) desta sessão:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\[srv\]/a www1' ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l www1 -Ke ansible_become_method=su ~/ansible/srv.yml ; ansible-playbook -i ~/ansible/hosts -l www1 ~/ansible/srv.yml
SUDO password:

(...)

PLAY RECAP **********************************************************************************************************

www1                       : ok=10   changed=8    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>Agora, acesse a máquina <code>www1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
www1
root</pre>
</div>
</div>
</li>
<li>
<p>Vamos instalar as dependências para o correto funcionamento do CMS Wordpress em nosso servidor:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y nginx php-fpm php-mysql</pre>
</div>
</div>
</li>
<li>
<p>Primeiro, vamos configurar o servidor web Nginx. Apague a configuração-padrão de websites publicados do Nginx:</p>
<div class="literalblock">
<div class="content">
<pre># rm /etc/nginx/sites-enabled/default</pre>
</div>
</div>
<div class="paragraph">
<p>Crie o arquivo novo <code>/etc/nginx/sites-available/seg10</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">upstream php {
        server unix:/run/php/php7.0-fpm.sock;
}

server {
        server_name seg10web.intnet;
        root /var/www/seg10;
        index index.php;

        location = /favicon.ico {
                log_not_found off;
                access_log off;
        }

        location = /robots.txt {
                allow all;
                log_not_found off;
                access_log off;
        }

        location / {
                try_files $uri $uri/ /index.php?$args;
        }

        location ~ \.php$ {
                include fastcgi.conf;
                fastcgi_intercept_errors on;
                fastcgi_pass php;
                fastcgi_buffers 16 16k;
                fastcgi_buffer_size 32k;
        }

        location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
                expires max;
                log_not_found off;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Habilite-o na configuração do Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># p=$PWD ; cd /etc/nginx/sites-enabled/ ; ln -s ../sites-available/seg10 . ; cd $p ; unset p</pre>
</div>
</div>
<div class="paragraph">
<p>Reinicie o Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nginx.service</pre>
</div>
</div>
</li>
<li>
<p>O Wordpress recomenda uma ligeira alteração na configuração do PHP-FPM, como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^;\(cgi\.fix\_pathinfo=\).*/\10/' /etc/php/7.0/fpm/php.ini</pre>
</div>
</div>
<div class="paragraph">
<p>Reinicie o <em>daemon</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart php7.0-fpm.service</pre>
</div>
</div>
</li>
<li>
<p>Vamos fazer o download do Wordpress, desempacotá-lo e renomear o diretório de acordo com a configuração do Nginx:</p>
<div class="literalblock">
<div class="content">
<pre># cd /var/www/ ; \
  wget -q https://wordpress.org/latest.tar.gz ; \
  tar zxf latest.tar.gz ; \
  rm latest.tar.gz ; \
  mv wordpress seg10 ; \
  chown -R www-data. /var/www</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -1 /var/www/
html
seg10</pre>
</div>
</div>
</li>
<li>
<p>Para conseguir acessar a máquina <code>www1</code> através do IP público do firewall, teremos que fazer alguns ajustes nas regras atuais. Acesse a máquina <code>ns1</code> como <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Para que consigamos atingir a máquina <code>www1</code> será necessário criar uma regra de DNAT na tabela <code>nat</code>, <em>chain</em> PREROUTING, além de uma regra na tabela <code>filter</code>, <em>chain</em> FORWARD, correspondente. Mapearemos a porta externa 80/TCP para a porta interna 80/TCP, sem alterações.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A PREROUTING -i enp0s3 -p tcp -m tcp --dport 80 -j DNAT --to-destination 10.0.42.5</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -i enp0s3 -d 10.0.42.5/32 -p tcp -m tcp --dport 80 -j ACCEPT</pre>
</div>
</div>
</li>
<li>
<p>Perfeito! Em sua máquina física, abra o navegador e aponte-o para o IP da interface <code>enp0s3</code> da máquina <code>ns1</code>, o IP público do nosso <em>datacenter</em> simulado. Você deverá ver a tela de instalação inicial do Wordpress, como se segue:</p>
<div id="img-wordpress1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/wordpress1.png" alt="wordpress1">
</div>
<div class="title">Figure 43. Tela inicial de instalação do Wordpress</div>
</div>
<div class="paragraph">
<p>Escolha o idioma <em>Português do Brasil</em>, e clique em <em>Continuar</em>. Na tela seguinte, clique em <em>Vamos lá!</em>.</p>
</div>
<div class="paragraph">
<p>Na tela de configuração da conexão com o banco de dados, digite <code>seg10web</code> em <em>Nome do banco de dados</em>; para <em>Nome de usuário</em>, informe <code>seg10user</code>; em <em>Senha</em>, <code>seg10pass</code>; para <em>Servidor do banco de dados</em>, informe <code>db.intnet</code>; para o <em>Prefixo da tabela</em>, mantenha o padrão <code>wp_</code>. Sua tela deverá ficar assim:</p>
</div>
<div id="img-wordpress2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/wordpress2.png" alt="wordpress2">
</div>
<div class="title">Figure 44. Configuração da conexão com o banco de dados</div>
</div>
<div class="paragraph">
<p>Clique em <em>Enviar</em>, e depois em <em>Instalar</em>.</p>
</div>
<div class="paragraph">
<p>Na tela de informações do site, digite <code>Seg10 Web</code> para o <em>Título do site</em>; em <em>Nome de usuário</em>, defina <code>admin</code>; para <em>Senha</em>, escolha <code>rnpesr123</code>; em <em>O seu e-mail</em>, informe <code>seg10web@int.net</code>; finalmente, mantenha a caixa <em>Visibilidade nos mecanismos de busca</em> desmarcada. Ao final do processo, sua tela deverá estar da seguinte forma:</p>
</div>
<div id="img-wordpress3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/wordpress3.png" alt="wordpress3">
</div>
<div class="title">Figure 45. Configuração das informações do site</div>
</div>
<div class="paragraph">
<p>Clique em <em>Instalar WordPress</em>. Ao final do processo de instalação, clique em <em>Acessar</em> para entrar na interface administrativa do Wordpress. Alternativamente, digite o endereço IP da interface <code>enp0s3</code> da máquina <code>ns1</code> na URL do navegador para acessar a página inicial do nosso portal, como mostra a figura abaixo:</p>
</div>
<div id="img-wordpress4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/wordpress4.png" alt="wordpress4">
</div>
<div class="title">Figure 46. Página inicial do portal Seg10 Web</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_configuração_automática_do_servidor_web_www2">5) Configuração automática do servidor web www2</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Para o segundo servidor web, a ideia é automatizar sua configuração completamente usando o Ansible. Antes de mais nada, clone a máquina <code>debian-template</code> para uma de nome <code>www2</code>, com uma única interface de rede conectada à DMZ. O IP da máquina será 10.0.42.6/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue a máquina e logue como <code>root</code>. Depois, use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática, como de costume.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h www2 -i 10.0.42.6 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Para aplicar o <em>baseline</em> de segurança via Ansible à máquina <code>www2</code>, repita o que fizemos no passo (2) da atividade (2) desta sessão:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\[srv\]/a www2' ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l www2 -Ke ansible_become_method=su ~/ansible/srv.yml ; ansible-playbook -i ~/ansible/hosts -l www2 ~/ansible/srv.yml
SUDO password:

(...)

PLAY RECAP **********************************************************************************************************

www2                       : ok=10   changed=8    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>Agora, ainda como o usuário <code>ansible</code> na máquina <code>client</code>, vamos criar uma <em>role</em> para automatizar totalmente a instalação e configuração do portal <em>Seg10 Web</em> na máquina <code>www2</code> (e em quaisquer outros nodos web que venhamos a adicionar no futuro):</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible-galaxy init --init-path=/home/ansible/ansible/roles seg10-web
- seg10-web was created successfully</pre>
</div>
</div>
</li>
<li>
<p>Vamos começar adicionando o arquivo de configuração do servidor Nginx&#8201;&#8212;&#8201;crie o arquivo novo <code>/home/ansible/ansible/roles/seg10-web/files/nginx_seg10</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">upstream php {
        server unix:/run/php/php7.0-fpm.sock;
}

server {
        server_name seg10web.intnet;
        root /var/www/seg10;
        index index.php;

        location = /favicon.ico {
                log_not_found off;
                access_log off;
        }

        location = /robots.txt {
                allow all;
                log_not_found off;
                access_log off;
        }

        location / {
                try_files $uri $uri/ /index.php?$args;
        }

        location ~ \.php$ {
                include fastcgi.conf;
                fastcgi_intercept_errors on;
                fastcgi_pass php;
                fastcgi_buffers 16 16k;
                fastcgi_buffer_size 32k;
        }

        location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
                expires max;
                log_not_found off;
        }
}</code></pre>
</div>
</div>
</li>
<li>
<p>O próximo passo é o arquivo de <em>tasks</em>. Edite o arquivo <code>/home/ansible/ansible/roles/seg10-web/tasks/main.yml</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Install nginx and deps
  apt:
    name: '{{ packages }}'
    state: present
    update_cache: true
    install_recommends: no
  vars:
    packages:
    - nginx
    - php-fpm
    - php-mysql
  notify:
    - Start nginx
    - Start php-fpm

- name: Add seg10 config
  copy:
    src: nginx_seg10
    dest: /etc/nginx/sites-available/seg10
    owner: root
    group: root

- name: Disable default site configuration
  file:
    dest: /etc/nginx/sites-enabled/default
    state: absent

- name: Enable seg10 site config
  file:
    src: /etc/nginx/sites-available/seg10
    dest: /etc/nginx/sites-enabled/seg10
    state: link

- name: Copy web root
  synchronize:
    src: seg10
    dest: /var/www
    recursive: yes

- name: Web Root Permissions
  file:
   dest: /var/www/seg10
   mode: u=rwX,g=rX,o=rX
   state: directory
   owner: www-data
   group: www-data
   recurse: yes
  notify:
    - Restart nginx

- name: Adjust php-fpm fix_pathinfo
  replace:
    path: /etc/php/7.0/fpm/php.ini
    regexp: '^;(cgi\.fix_pathinfo).*$'
    replace: '\1=0'
  notify:
    - Restart php-fpm</code></pre>
</div>
</div>
<div class="paragraph">
<p>A lista de tarefas acima irá instalar os pacotes na máquina-alvo, copiar a configuração do Nginx, desativar a configuração-padrão e criar o symlink apropriado, sincronizar usando o <code>rsync</code> os arquivos do website localizados na pasta <code>files</code> para o diretório <code>/var/www</code> no destino (copiaremos esses arquivos a seguir), configurará as permissões do <em>webroot</em> e ajustará a variável <code>cgi.fix_pathinfo</code> do PHP-FPM.</p>
</div>
</li>
<li>
<p>Temos <em>handlers</em> no arquivo acima, como visto. Edite <code>/home/ansible/ansible/roles/seg10-web/handlers/main.yml</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
- name: Start nginx
  service:
    name: nginx
    state: started

- name: Start php-fpm
  service:
    name: php7.0-fpm
    state: started

- name: Restart nginx
  service:
    name: nginx
    state: restarted

- name: Restart php-fpm
  service:
    name: php7.0-fpm
    state: restarted</code></pre>
</div>
</div>
</li>
<li>
<p>Para que a sincronização dos arquivos do website funcione, temos que obtê-los&#8201;&#8212;&#8201;use o <code>scp</code> para fazer isso:</p>
<div class="literalblock">
<div class="content">
<pre>$ scp -rpq www1:/var/www/seg10 /home/ansible/ansible/roles/seg10-web/files/</pre>
</div>
</div>
</li>
<li>
<p>Temos que ajustar o escopo das máquinas-alvo da nossa nova <em>role</em>. Adicione o novo grupo <code>seg10_server</code> ao inventário do Ansible:</p>
<div class="literalblock">
<div class="content">
<pre>$ cat &lt;&lt; EOF &gt;&gt; ~/ansible/hosts

[seg10_server]
www1
www2
EOF</pre>
</div>
</div>
<div class="paragraph">
<p>Ao final, o inventário deverá ficar assim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat ~/ansible/hosts
[srv]
www2
www1
db
ns1
ns2
nfs
192.168.42.2
log

[ntp_server]
log

[log_server]
log

[web_server]
log

[seg10_server]
www1
www2</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar um novo <em>playbook</em> para utilizar a <em>role</em> que acabamos de criar:</p>
<div class="literalblock">
<div class="content">
<pre>$ cat &lt;&lt; EOF &gt;&gt; ~/ansible/seg10web.yml
- hosts: seg10_server
  become: yes
  become_user: root
  become_method: sudo
  roles:
    - seg10-web
EOF</pre>
</div>
</div>
</li>
<li>
<p>Hora da verdade! Execute o <em>playbook</em>:</p>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts ~/ansible/seg10web.yml

PLAY [seg10_server] *************************************************************************************************


TASK [Gathering Facts] **********************************************************************************************

ok: [www1]
ok: [www2]

TASK [seg10-web : Install nginx and deps] ***************************************************************************

ok: [www1]
changed: [www2]

TASK [seg10-web : Add seg10 config] *********************************************************************************

changed: [www2]
ok: [www1]

TASK [seg10-web : Disable default site configuration] ***************************************************************

ok: [www1]
changed: [www2]

TASK [seg10-web : Enable seg10 site config] *************************************************************************

ok: [www1]
changed: [www2]

TASK [seg10-web : Copy web root] ************************************************************************************

changed: [www1]
changed: [www2]

TASK [seg10-web : Web Root Permissions] *****************************************************************************

changed: [www1]
changed: [www2]

TASK [seg10-web : Adjust php-fpm fix_pathinfo] **********************************************************************

changed: [www2]
ok: [www1]

RUNNING HANDLER [seg10-web : Start nginx] ***************************************************************************

ok: [www2]

RUNNING HANDLER [seg10-web : Start php-fpm] *************************************************************************

ok: [www2]

RUNNING HANDLER [seg10-web : Restart nginx] *************************************************************************

changed: [www1]
changed: [www2]

RUNNING HANDLER [seg10-web : Restart php-fpm] ***********************************************************************

changed: [www2]

PLAY RECAP **********************************************************************************************************

www1                       : ok=9    changed=3    unreachable=0    failed=0
www2                       : ok=12   changed=9    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>Terá funcionado? Vamos alterar o firewall para redirecionar os pacotes chegando na porta 80/TCP para a máquina <code>www2</code>, ao invés da <code>www1</code>. Acesse a máquina <code>ns1</code> como <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Remova as regras que criamos originalmente para a máquina <code>www1</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -D PREROUTING -i enp0s3 -p tcp -m tcp --dport 80 -j DNAT --to-destination 10.0.42.5</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -D FORWARD -i enp0s3 -d 10.0.42.5/32 -p tcp -m tcp --dport 80 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Insira as mesmas regras no firewall, mas agora para a máquina <code>www2</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A PREROUTING -i enp0s3 -p tcp -m tcp --dport 80 -j DNAT --to-destination 10.0.42.6</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -i enp0s3 -d 10.0.42.6/32 -p tcp -m tcp --dport 80 -j ACCEPT</pre>
</div>
</div>
</li>
<li>
<p>Vamos testar. Na máquina <code>www2</code>, como o usuário <code>root</code>, monitore o log de acesso do Nginx:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
www2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># tail -f -n0 /var/log/nginx/access.log</pre>
</div>
</div>
<div class="paragraph">
<p>No navegador da sua máquina física, acesse novamente o endereço IP da interface <code>enp0s3</code> da máquina <code>ns1</code>&#8230;&#8203; o <strong>mesmo</strong> website que havíamos configurado antes aparece! Volte a visualizar o log de acesso do Nginx instalado na máquina <code>www2</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>192.168.29.106 - - [17/Nov/2018:03:12:38 -0200] "GET / HTTP/1.1" 200 20854 "-" "Mozilla/5.0 (Windows NT 10.0; Win64;x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"
192.168.29.106 - - [17/Nov/2018:03:12:38 -0200] "GET /wp-content/themes/twentyseventeen/style.css?ver=4.9.8 HTTP/1.1" 200 83401 "http://192.168.29.104/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"
192.168.29.106 - - [17/Nov/2018:03:12:38 -0200] "GET /wp-includes/js/jquery/jquery.js?ver=1.12.4 HTTP/1.1" 200 97184"http://192.168.29.104/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"</pre>
</div>
</div>
<div class="paragraph">
<p>De fato, os acessos estão chegando à nova máquina, e o website está funcionando como esperado. Note que não fizemos <strong>qualquer</strong> modificação manual na máquina <code>www2</code>&#8201;&#8212;&#8201;todos as dependências, arquivos de configuração e arquivos do site foram instalados de forma automática pelo Ansible. Se quiséssemos lançar agora outros dois, três ou dez nodos de atendimento web, bastaria adicionar as máquinas ao inventário do Ansible e disparar a <em>role</em>; toda a configuração é feita de forma automática.</p>
</div>
</li>
<li>
<p>Como fizemos uma nova <em>role</em> para os sistemas web, é uma boa ideia enviar nossas modificações para o repositório Git central. Acesse a máquina <code>client</code> como o usuário <code>ansible</code>:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Envie as alterações, adicionando uma mensagem significativa:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cd ~/ansible/ ; git add . ; git commit -m 'Adicionada role para configuracao automatica de servidores web do portal seg10' ; git push

(...)

Counting objects: 1665, done.
Compressing objects: 100% (1632/1632), done.
Writing objects: 100% (1665/1665), 8.95 MiB | 8.87 MiB/s, done.
Total 1665 (delta 170), reused 0 (delta 0)
remote: Resolving deltas: 100% (170/170), completed with 1 local object.
To nfs:/home/ansible/ansible.git
   467f80d..bd3fbc2  master -&gt; master</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_configuração_do_balanceador_de_carga">6) Configuração do balanceador de carga</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos para a instalação e configuração do balanceador de carga. Clone a máquina <code>debian-template</code> para uma de nome <code>lb</code>, com uma única interface de rede conectada à DMZ. O IP da máquina será 10.0.42.8/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue a máquina e logue como <code>root</code>. Depois, use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática, como de costume.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h lb -i 10.0.42.8 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Aplique o <em>baseline</em> de segurança à máquina <code>lb</code>, repetindo o que fizemos no passo (2) da atividade (2) desta sessão:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\[srv\]/a lb' ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l lb -Ke ansible_become_method=su ~/ansible/srv.yml ; ansible-playbook -i ~/ansible/hosts -l lb ~/ansible/srv.yml
SUDO password:

(...)

PLAY RECAP **********************************************************************************************************

lb                       : ok=10   changed=8    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>Acesse a máquina <code>lb</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
lb
root</pre>
</div>
</div>
</li>
<li>
<p>Vamos instalar o balanceador de carga: usaremos o software HAProxy, uma solução <em>open-source</em> para balanceamento de carga e alta disponibilidade para aplicações baseadas em TCP e HTTP, reconhecido por sua excepcional performance e eficiência.</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y haproxy</pre>
</div>
</div>
</li>
<li>
<p>Edite o arquivo de configuração do HAProxy, <code>/etc/haproxy/haproxy.cfg</code>, deixando-o exatamente com o conteúdo a seguir:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">global
  log /dev/log    local0
  log /dev/log    local1 notice
  chroot /var/lib/haproxy
  stats socket /run/haproxy/admin.sock mode 660 level admin
  stats timeout 30s
  user haproxy
  group haproxy
  daemon
  maxconn 2048

  # Default SSL material locations
  ca-base /etc/ssl/certs
  crt-base /etc/ssl/private

  # Default ciphers to use on SSL-enabled listening sockets.
  # For more information, see ciphers(1SSL). This list is from:
  #  https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
  # An alternative list with additional directives can be obtained from
  #  https://mozilla.github.io/server-side-tls/ssl-config-generator/?server=haproxy
  ssl-default-bind-ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:RSA+AESGCM:RSA+AES:!aNULL:!MD5:!DSS
  ssl-default-bind-options no-sslv3
  tune.ssl.default-dh-param 2048

defaults
  log     global
  mode    http
  option  httplog
  option  dontlognull
  option  forwardfor
  option  http-server-close
  timeout connect 5000
  timeout client  50000
  timeout server  50000
  errorfile 400 /etc/haproxy/errors/400.http
  errorfile 403 /etc/haproxy/errors/403.http
  errorfile 408 /etc/haproxy/errors/408.http
  errorfile 500 /etc/haproxy/errors/500.http
  errorfile 502 /etc/haproxy/errors/502.http
  errorfile 503 /etc/haproxy/errors/503.http
  errorfile 504 /etc/haproxy/errors/504.http

  stats enable
  stats uri /stats
  stats realm Haproxy\ Statistics
  stats auth admin:rnpesr123

frontend www-http
  bind 10.0.42.8:80
  reqadd X-Forwarded-Proto:\ http
  default_backend www-backend

frontend www-https
  bind 10.0.42.8:443 ssl crt /etc/ssl/private/seg10web.pem
  reqadd X-Forwarded-Proto:\ https
  default_backend www-backend

backend www-backend
  redirect scheme https if !{ ssl_fc }
  server www1 www1.intnet:80 check
  server www2 www2.intnet:80 check</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em linhas gerais, definimos dois <em>frontends</em> de atendimento, um para conexões HTTP e outro para HTTPS. Ambos enviam suas requisições para o mesmo <em>backend</em>, o qual é atendido pelos servidores <code>www1</code> e <code>www2</code>, escutando na porta 80/TCP.</p>
</div>
</li>
<li>
<p>Note que para o atendimento das requisições HTTPS (o chamado <em>SSL offloading</em>, ou <em>SSL termination</em>), devemos configurar um par de chaves pública/privada auto-assinadas em formato PEM. Vamos fazer isso:</p>
<div class="literalblock">
<div class="content">
<pre># openssl req -x509 -nodes -days 730 -newkey rsa:4096 -keyout /etc/ssl/private/seg10web.key -out /etc/ssl/certs/seg10web.crt
Generating a 4096 bit RSA private key
..............................................++
.............................................................................................................................................................................................................................................................................................++
writing new private key to '/etc/ssl/private/seg10web.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:BR
State or Province Name (full name) [Some-State]:DF
Locality Name (eg, city) []:Brasilia
Organization Name (eg, company) [Internet Widgits Pty Ltd]:RNP
Organizational Unit Name (eg, section) []:ESR
Common Name (e.g. server FQDN or YOUR name) []:seg10web.intnet
Email Address []:seg10web@int.net</pre>
</div>
</div>
<div class="paragraph">
<p>Concatene as duas chaves em um arquivo em formato PEM:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/ssl/certs/seg10web.crt /etc/ssl/private/seg10web.key &gt; /etc/ssl/private/seg10web.pem</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># chmod 600 /etc/ssl/private/seg10web.pem</pre>
</div>
</div>
</li>
<li>
<p>Agora que tudo está configurado, reinicie o HAProxy:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl restart haproxy.service</pre>
</div>
</div>
</li>
<li>
<p>Temos que alterar o firewall uma última vez, desta vez para redirecionar os pacotes chegando na porta 80/TCP para a máquina <code>lb</code>. Acesse a máquina <code>ns1</code> como <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Remova as regras que criamos para a máquina <code>www2</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -D PREROUTING -i enp0s3 -p tcp -m tcp --dport 80 -j DNAT --to-destination 10.0.42.6</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -D FORWARD -i enp0s3 -d 10.0.42.6/32 -p tcp -m tcp --dport 80 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Adicione-as para o balanceador de carga&#8201;&#8212;&#8201;observe que como o HAProxy escuta tanto na porta 80/TCP como na 443/TCP, iremos redirecioná-las ambas:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A PREROUTING -i enp0s3 -p tcp -m multiport --dports 80,443 -j DNAT --to-destination 10.0.42.8</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -i enp0s3 -d 10.0.42.8/32 -p tcp -m multiport --dports 80,443 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Salve a configuração do firewall desta vez, já que ela será definitiva:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent save
[....] Saving netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save
done.</pre>
</div>
</div>
</li>
<li>
<p>Vamos ao teste! No navegador da sua máquina física, acesse novamente o endereço IP da interface <code>enp0s3</code> da máquina <code>ns1</code>. De imediato, notamos uma diferença: o acesso está sendo feito em HTTPS, já que a diretiva <code>redirect scheme https if !{ ssl_fc }</code> do arquivo de configuração do HAProxy força esse protocolo aos clientes que estão se conectando.</p>
<div id="img-haproxy1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/haproxy1.png" alt="haproxy1">
</div>
<div class="title">Figure 47. Acesso desviado para HTTPS pelo HAProxy</div>
</div>
<div class="paragraph">
<p>Aceite o certificado auto-assinado, e prossiga para a página do portal <em>Seg10 Web</em>. Temos um problema! O CSS da página não foi carregado corretamente:</p>
</div>
<div id="img-haproxy2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/haproxy2.png" alt="haproxy2">
</div>
<div class="title">Figure 48. CSS não foi carregado na conexão HTTPS</div>
</div>
<div class="paragraph">
<p>O que fazemos? Felizmente, esse problema é facilmente solucionável. Acesse a máquina <code>client</code> como o usuário <code>ansible</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="paragraph">
<p>Basta inserir a linha <code>if ($_SERVER['HTTP_X_FORWARDED_PROTO'] == 'https') $_SERVER['HTTPS']='on';</code> antes da última linha do arquivo <code>/home/ansible/ansible/roles/seg10-web/files/seg10/wp-config.php</code>. O comando <code>sed</code> a seguir faz a alteração de forma direta:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i "/wp-settings/i if (\$_SERVER['HTTP_X_FORWARDED_PROTO'] == 'https') \$_SERVER['HTTPS']='on';" /home/ansible/ansible/roles/seg10-web/files/seg10/wp-config.php</pre>
</div>
</div>
<div class="paragraph">
<p>Uhm&#8230;&#8203; como distribuir essas mudanças? Simples: basta re-executar nossa <em>role</em> <code>seg10-web</code> no Ansible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts ~/ansible/seg10web.yml

(...)

TASK [seg10-web : Copy web root] ************************************************************************************

changed: [www1]
changed: [www2]

TASK [seg10-web : Web Root Permissions] *****************************************************************************

changed: [www1]
changed: [www2]

(...)

PLAY RECAP **********************************************************************************************************

www1                       : ok=9    changed=3    unreachable=0    failed=0
www2                       : ok=9    changed=3    unreachable=0    failed=0</pre>
</div>
</div>
<div class="paragraph">
<p>O Ansible detecta que a cópia local está diferente da observada nas máquinas remotas, e sobrescreve o arquivo <code>/var/www/seg10/wp-config.php</code> em ambos os servidores web com as modificações locais.</p>
</div>
<div class="paragraph">
<p>Vamos verificar se isso solucionou o problema no portal. Recarregue a página web no navegador em sua máquina física:</p>
</div>
<div id="img-haproxy3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/haproxy3.png" alt="haproxy3">
</div>
<div class="title">Figure 49. Correção na visualização da página via HTTPS</div>
</div>
<div class="paragraph">
<p>Excelente, tudo funcionando a contento.</p>
</div>
</li>
<li>
<p>O HAProxy possui uma página de estatísticas bastante interessante para acompanhar o funcionamento dos diferentes <em>frontends</em> e <em>backends</em> configurados. Adicione o sufixo <code>/stats</code> à URL do seu navegador, e faça login com o usuário <code>admin</code> e senha <code>rnpesr123</code> quando solicitado. Você verá a página a seguir:</p>
<div id="img-haproxy4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/haproxy4.png" alt="haproxy4">
</div>
<div class="title">Figure 50. Página de estatísticas do HAProxy</div>
</div>
<div class="paragraph">
<p>A partir desta página, é possível verificar quais <em>frontends</em> e <em>backends</em> estão ativos, quais estão inativos ou com problemas de acesso, e quantos bytes e sessões foram trafegados para cada um dos <em>hosts</em> envolvidos.</p>
</div>
<div class="paragraph">
<p>Tente recarregar a portal <em>Seg10 Web</em> algumas vezes, e confira o número de sessões registradas para cada um dos <em>backends</em>: o HAProxy envia requisições alternadas para cada um deles, segundo um algoritmo <em>round robin</em>. Com o HAProxy, é fácil desativar seletivamente alguns <em>backends</em> para atualizações ou manutenção, e levantá-los posteriormente, mantendo a disponibilidade do serviço e minimizando o impacto para os clientes.</p>
</div>
</li>
<li>
<p>Encerradas as nossas atividades com os servidores, recomenda-se que o aluno mantenha as máquinas <code>www1</code>, <code>www2</code>, <code>db</code> e <code>lb</code> desligadas a partir desta sessão. Apesar de as máquinas individualmente não ocuparem tantos recursos de memória e processamento, o fato de não precisarmos mais usá-las e a exigência de alteração de contexto da CPU para atendê-las faz com que a liberação de recursos, nesse caso, seja recomendável.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_8_isolamento_de_processos_e_conteinerização">Sessão 8: Isolamento de processos e conteinerização</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nesta sessão, iremos configurar o sistema de conteinerização Docker, testando suas funcionalidades de criação rápida de containers, escalabilidade e orquestração via Docker Swarm. Compararemos a facilidade e rapidez de configuração com um sistema web mais "tradicional", como o que fizemos na sessão anterior.</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão_7">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>Criaremos duas novas máquinas nesta sessão, a saber:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>docker1</code>, nodo-mestre de configuração do Docker Compose/Swarm. Endereço IP 10.0.42.9/24.</p>
</li>
<li>
<p><code>docker2</code>, nodo-escravo (ou <em>worker</em>) do Docker Compose/Swarm. Endereço IP 10.0.42.10/24.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Como de costume, vamos à criação dos registros DNS. Acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo de zonas <code>/etc/nsd/zones/intnet.zone</code>, inserindo entradas A para a máquinas indicadas no começo desta atividade. <strong>Não se esqueça</strong> de incrementar o valor do serial no topo do arquivo!</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/intnet.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep docker /etc/nsd/zones/intnet.zone
docker1 IN    A                 10.0.42.9
docker2 IN    A                 10.0.42.10</pre>
</div>
</div>
<div class="paragraph">
<p>Faça o mesmo para o arquivo de zona reversa:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/10.0.42.zone</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep docker /etc/nsd/zones/10.0.42.zone
9       IN   PTR                docker1.intnet.
10      IN   PTR                docker2.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>Assine o arquivo de zonas usando o <em>script</em> criado anteriormente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash /root/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 6 rrsets, 2 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a criação das entradas usando o comando <code>dig</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># for host in docker1 docker2; do echo -n "$host: "; dig ${host}.intnet +short; done
docker1: 10.0.42.9
docker2: 10.0.42.10</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># for ip in 9 10; do echo -n "10.0.42.${ip}: "; dig -x 10.0.42.${ip} +short; done
10.0.42.9: docker1.intnet.
10.0.42.10: docker2.intnet.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_2_criação_da_vm_docker1_e_instalação">2) Criação da VM docker1 e instalação</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, vamos criar a VM <code>docker1</code> e instalar o software Docker nela. Clone a máquina <code>debian-template</code> para uma de nome <code>docker1</code>, com uma única interface de rede conectada à DMZ. O IP da máquina será 10.0.42.9/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue a máquina e logue como <code>root</code>. Depois, use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática, como de costume.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h docker1 -i 10.0.42.9 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Aplique o <em>baseline</em> de segurança à máquina <code>docker1</code>, repetindo o que fizemos no passo (2), atividade (2) da sessão 7:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\[srv\]/a docker1' ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l docker1 -Ke ansible_become_method=su ~/ansible/srv.yml ; ansible-playbook -i ~/ansible/hosts -l docker1 ~/ansible/srv.yml
SUDO password:

(...)

PLAY RECAP **********************************************************************************************************

docker1                       : ok=10   changed=8    unreachable=0    failed=0</pre>
</div>
</div>
</li>
<li>
<p>Agora, acesse a máquina <code>docker1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker1
root</pre>
</div>
</div>
</li>
<li>
<p>Vamos proceder com os passos de instalação seguindo o manual oficial do Docker, disponível <a href="https://docs.docker.com/install/linux/docker-ce/debian/#install-docker-ce" class="bare">https://docs.docker.com/install/linux/docker-ce/debian/#install-docker-ce</a> . Primeiramente, vamos habilitar a instalação de pacotes APT via HTTPS, instalando os pacotes a seguir:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg2 \
    software-properties-common</pre>
</div>
</div>
</li>
<li>
<p>Agora, adicione a chave GPG do repositório do Docker com o comando:</p>
<div class="literalblock">
<div class="content">
<pre># curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
OK</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique que a chave foi recebida corretamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-key fingerprint 0EBFCD88
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;
sub   rsa4096 2017-02-22 [S]</pre>
</div>
</div>
</li>
<li>
<p>Adicione o repositório do Docker à lista de repositórios disponíveis para instalação de pacotes:</p>
<div class="literalblock">
<div class="content">
<pre># echo "deb [arch=amd64] https://download.docker.com/linux/debian \
    $(lsb_release -cs) \
    stable" &gt; \
    /etc/apt/sources.list.d/docker.list</pre>
</div>
</div>
<div class="paragraph">
<p>Atualize a lista de pacotes disponíveis, e instale o <code>docker-ce</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># apt-get update ; apt-get install -y docker-ce</pre>
</div>
</div>
</li>
<li>
<p>Cheque qual versão do Docker foi instalada:</p>
<div class="literalblock">
<div class="content">
<pre># docker --version
Docker version 18.09.0, build 4d60db4</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a correta instalação do Docker rodando a imagem <code>hello-world</code>, uma imagem de teste:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
d1725b59e92d: Pull complete
Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/</pre>
</div>
</div>
<div class="paragraph">
<p>O Docker detecta que a imagem <code>hello-world</code> não está disponível localmente, faz o download da mesma a partir do <em>registry</em> global do Docker Hub, e a executa. Falaremos mais sobre o <em>registry</em> global em atividades posteriores.</p>
</div>
</li>
<li>
<p>Agora, desligue a VM <code>docker1</code>. Para não ter que repetir os passos de instalação na VM <code>docker2</code>, vamos cloná-la a partir da <code>docker1</code> e aproveitar o trabalho que já realizamos até aqui.</p>
<div class="literalblock">
<div class="content">
<pre># halt -p</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_criação_da_vm_docker2">3) Criação da VM docker2</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Com a VM <code>docker1</code> desligada, clone-a para uma máquina de nome <code>docker2</code>. O IP dessa máquina será 10.0.42.10/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue <strong>apenas</strong> a máquina <code>docker2</code> e logue como <code>root</code>. Não ligue a máquina <code>docker1</code> ainda, ou haverá um conflito de IP na rede. Observe: como a máquina <code>docker1</code> já estava configurada para operar com o <code>sudo</code> distribuído via Ansible, será necessário escalar privilégio a partir de um usuário autorizado, como <code>aluno</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
docker1
aluno</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sudo -i
[sudo] senha para aluno:
root@docker1:~#</pre>
</div>
</div>
<div class="paragraph">
<p>Depois, use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática, como de costume.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h docker2 -i 10.0.42.10 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Para manter a organização em nosso ambiente, adicione a máquina <code>docker2</code> ao inventário do Ansible. Como o usuário <code>ansible</code> na máquina <code>cliente</code>, execute:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\[srv\]/a docker2' ~/ansible/hosts</pre>
</div>
</div>
<div class="paragraph">
<p>Note que não é necessário re-executar o <em>playbook</em> para a máquina <code>docker2</code>, já que todos os controles de segurança foram aplicados anteriormente à máquina <code>docker1</code>, a partir da qual fizemos a clonagem.</p>
</div>
</li>
<li>
<p>Feito isso, ligue também a máquina <code>docker1</code>, e prossiga com as atividades desta sessão.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_trabalhando_com_containers">4) Trabalhando com containers</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acesse a máquina <code>docker1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, crie um diretório vazio <code>/root/docker</code>, e entre nele.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkdir ~/docker ; cd ~/docker</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar um <em>Dockerfile</em>&#8201;&#8212;&#8201;um arquivo que define o que será instalado e configurado dentro do seu container. Nesse arquivo são mapeados acessos a recursos como interfaces de rede e volumes de disco virtualizados, em um ambiente isolado do restante do sistema operacional.</p>
<div class="paragraph">
<p>Crie o arquivo novo <code>/root/docker/Dockerfile</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker"># Usar uma imagem oficial do runtime Python como imagem-pai
FROM python:2.7-slim

# Configurar o diretorio de trabalho como /app
WORKDIR /app

# Copiar o conteudo do diretorio corrent para dentro do container em /app
COPY . /app

# Instalar quaisquer dependencias do Python especificadas no arquivo requirements.txt
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# Expor a porta 80 para o mundo externo, fora do container
EXPOSE 80

# Definir uma variavel de ambiente $World
ENV NAME World

# Rodar a aplicacao app.py ao lancar o container
CMD ["python", "app.py"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse <em>Dockerfile</em> faz referência a dois arquivos que ainda não criamos&#8201;&#8212;&#8201;<code>app.py</code> e <code>requirements.txt</code>. Vamos criá-los.</p>
</div>
</li>
<li>
<p>Primeiro, crie o arquivo novo <code>/root/docker/requirements.txt</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">Flask
Redis</code></pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>pip install -r requirements.txt</code>, invocado no <em>Dockerfile</em>, irá portanto instalar as bibliotecas Flask e Redis para o ambiente Python do container.</p>
</div>
</li>
<li>
<p>Agora, vamos à aplicação em si. Crie o arquivo novo <code>/root/docker/app.py</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">from flask import Flask
from redis import Redis, RedisError
import os
import socket

# Connect to Redis
redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)

app = Flask(__name__)

@app.route("/")
def hello():
    try:
        visits = redis.incr("counter")
    except RedisError:
        visits = "&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"

    html = "&lt;h3&gt;Hello {name}!&lt;/h3&gt;" \
           "&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;" \
           "&lt;b&gt;Visits:&lt;/b&gt; {visits}"
    return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A aplicação acima, bastante simples, irá exibir a <em>string</em> <code>Hello World!</code>, uma página web que mostra o <em>hostname</em> da máquina local (no caso, o identificador do container) e um contador do número de visitas realizadas ao site. Esse contador é mantido em um volume uniforme, acessível por todos os containers da aplicação, com a biblioteca Redis.</p>
</div>
</li>
<li>
<p>Liste o conteúdo do diretório <code>/root/docker</code>. Você deve ter os arquivos abaixo:</p>
<div class="literalblock">
<div class="content">
<pre># ls -1 ~/docker/
app.py
Dockerfile
requirements.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Para fazer o <em>build</em> do container, basta rodar o comando <code>docker build</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cd ~/docker ; docker build -t pyhello .
Sending build context to Docker daemon   5.12kB
Step 1/7 : FROM python:2.7-slim
2.7-slim: Pulling from library/python
a5a6f2f73cd8: Pull complete
8da2a74f37b1: Pull complete
09b6f498cfd0: Pull complete
f0afb4f0a079: Pull complete
Digest: sha256:f82db224fbc9ff3309b7b62496e19d673738a568891604a12312e237e01ef147
Status: Downloaded newer image for python:2.7-slim
 ---&gt; 0dc3d8d47241
Step 2/7 : WORKDIR /app
(...)
Step 3/7 : COPY . /app
(...)
Step 4/7 : RUN pip install --trusted-host pypi.python.org -r requirements.txt
(...)
Step 5/7 : EXPOSE 80
(...)
Step 6/7 : ENV NAME World
(...)
Step 7/7 : CMD ["python", "app.py"]
(...)
Successfully built d2923f9142e3
Successfully tagged pyhello:latest</pre>
</div>
</div>
<div class="paragraph">
<p>O Docker irá executar os comandos do <em>Dockerfile</em>, em ordem:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ao detectar que a imagem <code>python:2.7-slim</code> não existe na máquina local, ela será baixada do <em>registry</em> global do Docker Hub, como feito anteriormente com a imagem <code>hello-world.</code></p>
</li>
<li>
<p>Deriva-se uma nova imagem a partir de <code>python:2.7-slim</code>, e o diretório <code>/app</code> é criado na raiz do container.</p>
</li>
<li>
<p>Os arquivos da pasta local são copiadas para <code>/app</code>.</p>
</li>
<li>
<p>O comando <code>pip install -r requirements.txt</code> instala as bibliotecas necessárias ao funcionamento da aplicação, Flask e Redis, bem como suas dependências.</p>
</li>
<li>
<p>A porta 80/TCP do container é exposta para o mundo externo.</p>
</li>
<li>
<p>Cria-se uma nova variável de ambiente, <code>$World</code>.</p>
</li>
<li>
<p>Roda-se o comando <code>python app.py</code>, executando a aplicação. Como este comando objetiva apenas a criação da imagem do container, a aplicação é encerrada logo em seguida, e a imagem do container é finalizada sob a <em>tag</em> <code>pyhello</code>.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Para listar a imagem recém-criada, use o comando <code>docker image ls</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
pyhello             latest              d2923f9142e3        6 minutes ago       131MB
python              2.7-slim            0dc3d8d47241        36 hours ago        120MB
hello-world         latest              4ab4c602aa5e        2 months ago        1.84kB</pre>
</div>
</div>
</li>
<li>
<p>Para rodar o container, basta executar <code>docker run</code>:</p>
<div class="literalblock">
<div class="content">
<pre># docker run -p 7080:80 pyhello
 * Serving Flask app "app" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</pre>
</div>
</div>
<div class="paragraph">
<p>O comando acima irá iniciar o container escutando na porta 80/TCP, e mapeando-a para a porta 7080/TCP da máquina virtual <code>docker1</code>.</p>
</div>
</li>
<li>
<p>Para conseguir acessar o container a partir do IP público do firewall (interface <code>enps0s3</code> da máquina <code>ns1</code>), precisamos adicionar algumas regras novas. Acesse a máquina <code>ns1</code> como <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Para que consigamos atingir a máquina <code>docker1</code> será necessário criar uma regra de DNAT na tabela <code>nat</code>, <em>chain</em> PREROUTING, além de uma regra na tabela <code>filter</code>, <em>chain</em> FORWARD, correspondente. Mapearemos a porta externa 7080/TCP para a porta interna 7080/TCP, sem alterações.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A PREROUTING -i enp0s3 -p tcp -m tcp --dport 7080 -j DNAT --to-destination 10.0.42.9</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -i enp0s3 -d 10.0.42.9/32 -p tcp -m tcp --dport 7080 -j ACCEPT</pre>
</div>
</div>
</li>
<li>
<p>Em sua máquina física, abra o navegador e aponte-o para o IP público do firewall (interface <code>enps0s3</code> da máquina <code>ns1</code>), na porta 7080/TCP:</p>
<div id="img-docker1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker1.png" alt="docker1">
</div>
<div class="title">Figure 51. Container operacional no Docker</div>
</div>
<div class="paragraph">
<p>Tudo certo!</p>
</div>
</li>
<li>
<p>De volta à máquina <code>docker1</code> como <code>root</code>, note que o acesso que fizemos foi registrado na console, com as seguintes mensagens:</p>
<div class="literalblock">
<div class="content">
<pre>192.168.29.106 - - [17/Nov/2018 20:10:53] "GET / HTTP/1.1" 200 -
192.168.29.106 - - [17/Nov/2018 20:10:53] "GET /favicon.ico HTTP/1.1" 404 -</pre>
</div>
</div>
<div class="paragraph">
<p>Para encerrar o container, digite <code>CTRL + C</code>. Vamos reexecutá-lo em <em>background</em> com a opção <code>-d</code> (<em>detached</em>):</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker run -d -p 7080:80 pyhello
2d93cc85f066dc6afa9a5c9ea5d0fd08112f52cec99aad8d1d862608d67ddc81</pre>
</div>
</div>
<div class="paragraph">
<p>O ID do container é mostrado, e retomamos controle do terminal. Para visualizar quais containers estão em operação neste momento, use o comando <code>docker container ls</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS
      NAMES
2d93cc85f066        pyhello             "python app.py"     42 seconds ago      Up 41 seconds       0.0.0.0:7080-&gt;80/tcp   modest_stallman</pre>
</div>
</div>
<div class="paragraph">
<p>Tente acessar novamente o container no navegador em sua máquina física&#8201;&#8212;&#8201;ele está funcionando normalmente.</p>
</div>
<div class="paragraph">
<p>Para parar um container rodando em <em>background</em>, use <code>docker container stop</code> e passe como parâmetro o ID do container, assim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker container stop 2d93cc85f066
2d93cc85f066</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_distribuindo_containers_para_um_registry_externo">5) Distribuindo containers para um <strong><em>registry</em></strong> externo</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos distribuir o container que criamos no passo anterior para o <em>registry</em> global do Docker Hub. Para isso, o primeiro passo é criar uma conta em <a href="https://hub.docker.com/" class="bare">https://hub.docker.com/</a> . Acesse essa página através do navegador em sua máquina física e preencha os campos em <em>New to Docker?</em>; <strong>importante</strong>: use um endereço de e-mail real em seu cadastro.</p>
<div id="img-docker2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker2.png" alt="docker2">
</div>
<div class="title">Figure 52. Cadastro no Docker Hub</div>
</div>
<div class="paragraph">
<p>Após seu cadastro, o Docker Hub irá enviar um e-mail de confirmação. Acesse a conta de e-mail informada e clique no botão para completar o cadastro. Finalmente, faça login no Docker Hub usando sua conta:</p>
</div>
<div id="img-docker3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker3.png" alt="docker3">
</div>
<div class="title">Figure 53. Interface do Docker Hub</div>
</div>
<div class="paragraph">
<p>Na tela acima, clique em <em>Create Repository</em>. Na nova tela, digite <code>seg10</code> como o nome do repositório; em <em>Description</em>, informe <code>Repositório-teste para o curso SEG10</code>; mantenha <em>Visibility</em> como <code>Public</code>.</p>
</div>
<div id="img-docker4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker4.png" alt="docker4">
</div>
<div class="title">Figure 54. Criação de novo repositório no Docker Hub</div>
</div>
<div class="paragraph">
<p>Clique em <em>Create</em>. Concluído o processo, você verá seu novo repositório como na tela a seguir:</p>
</div>
<div id="img-docker5" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker5.png" alt="docker5">
</div>
<div class="title">Figure 55. Repositório seg10 no Docker Hub</div>
</div>
</li>
<li>
<p>Agora, volte à máquina <code>docker1</code> como o usuário <code>root</code>.</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Para fazer login no Docker Hub via linha de comando, use <code>docker login</code>. Use a mesma combinação de usuário e senha que você criou no passo (1) desta atividade.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: seg10docker
Password:
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded</pre>
</div>
</div>
</li>
<li>
<p>O próximo passo é criar uma <em>tag</em> para a imagem de container que criamos na atividade anterior. Uma <em>tag</em> é descrita por uma combinação <code>usuário/repositório:tag</code>, e serve para identificar e versionar imagens de containers no Docker.</p>
<div class="paragraph">
<p>Para criar a <em>tag</em>, use o comando <code>docker tag image</code>&#8201;&#8212;&#8201;substitua no comando abaixo o nome de usuário <code>seg10docker</code> pelo usuário que você criou no Docker Hub no passo (1) desta atividade:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker tag pyhello seg10docker/seg10:pyhello-v1</pre>
</div>
</div>
<div class="paragraph">
<p>Para ver a nova imagem criada com a <em>tag</em>, use <code>docker image ls</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
seg10docker/seg10   pyhello-v1          d2923f9142e3        37 minutes ago      131MB
pyhello             latest              d2923f9142e3        37 minutes ago      131MB
python              2.7-slim            0dc3d8d47241        37 hours ago        120MB
hello-world         latest              4ab4c602aa5e        2 months ago        1.84kB</pre>
</div>
</div>
</li>
<li>
<p>Para publicar a imagem à qual aplicamos a <em>tag</em> para o <em>registry</em> global do Docker Hub, use o comando <code>docker push</code>:</p>
<div class="literalblock">
<div class="content">
<pre># docker push seg10docker/seg10:pyhello-v1
The push refers to repository [docker.io/seg10docker/seg10]
1efa6f0c4ef3: Pushed
2134161361ab: Pushed
1acdc2a51c84: Pushed
6cffeea81e5d: Mounted from library/python
614a79865f6d: Mounted from library/python
612d27bb923f: Mounted from library/python
ef68f6734aa4: Mounted from library/python
pyhello-v1: digest: sha256:2879351d8aa37d80e5cebeb676f70af2a93de107d0b801bb51e47d937f99f3ff size: 1787</pre>
</div>
</div>
<div class="paragraph">
<p>Concluído este processo, a imagem estará publicada e disponível no Docker Hub. De volta ao navegador em sua máquina física, acesse a aba <em>Tags</em> em seu repositório para visualizar a imagem que foi enviada:</p>
</div>
<div id="img-docker6" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker6.png" alt="docker6">
</div>
<div class="title">Figure 56. Imagem publicada no Docker Hub</div>
</div>
</li>
<li>
<p>A partir deste momento, é possível executar a imagem do container que publicamos para o Docker Hub a partir de qualquer máquina que possua o Docker instalado, diretamente. Por exemplo, acesse a máquina <code>docker2</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker2
root</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, execute a imagem com o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker run -p 7080:80 seg10docker/seg10:pyhello-v1
Unable to find image 'seg10docker/seg10:pyhello-v1' locally
pyhello-v1: Pulling from seg10docker/seg10
a5a6f2f73cd8: Pull complete
8da2a74f37b1: Pull complete
09b6f498cfd0: Pull complete
f0afb4f0a079: Pull complete
b0ce05758094: Pull complete
dde7e744bb50: Pull complete
0662477f0e17: Pull complete
Digest: sha256:2879351d8aa37d80e5cebeb676f70af2a93de107d0b801bb51e47d937f99f3ff
Status: Downloaded newer image for seg10docker/seg10:pyhello-v1
 * Serving Flask app "app" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que o Docker detecta que a imagem não está disponível localmente, e então faz o download da mesma, instala as dependências do Python via <code>requirements.txt</code> e executa a aplicação. Tudo é gerenciado de forma transparente, de forma que apenas tivemos que invocar o container que preparamos e enviamos para o <em>registry</em> anteriormente.</p>
</div>
<div class="paragraph">
<p>Antes de prosseguir, encerre o container <code>CTRL + C</code>.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_6_construindo_serviços_com_o_docker">6) Construindo serviços com o Docker</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Agora, vamos escalar a execução do nosso container para um ambiente simulado de produção. Acesse a máquina <code>docker1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker1
root</pre>
</div>
</div>
</li>
<li>
<p>Crie o arquivo novo <code>/root/docker/docker-compose.yml</code> com o conteúdo abaixo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">version: "3"
services:
  web:
    # substitua username/repo:tag com suas informacoes de nome de usuario, repositorio e imagem
    image: username/repo:tag
    deploy:
      replicas: 5
      resources:
        limits:
          cpus: "0.1"
          memory: 50M
      restart_policy:
        condition: on-failure
    ports:
      - "7080:80"
    networks:
      - webnet
networks:
  webnet:</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como mencionado no comentário acima, não se esqueça de substituir a <em>string</em> <code>username/repo:tag</code>, que identifica a imagem a ser executada, pelas informações de usuário, repositório e imagem que foram criadas por você na atividade anterior. Por exemplo, no caso do usuário <code>seg10docker</code> que foi ilustrado até aqui, a linha ficaria assim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># grep 'image:' ~/docker/docker-compose.yml
    image: seg10docker/seg10:pyhello-v1</pre>
</div>
</div>
<div class="paragraph">
<p>O arquivo acima irá:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Baixar a imagem que enviamos para o <em>registry</em> global do Docker Hub, se necessário.</p>
</li>
<li>
<p>Rodar 5 instâncias de um serviço denominado <code>web</code>, com cada instância ocupando no máximo 10% de CPU e 50 MB de memória RAM.</p>
</li>
<li>
<p>Reiniciar imediatamente quaisquer containers que venham a falhar.</p>
</li>
<li>
<p>Mapear a porta 7080 do <em>host</em> Docker para a porta 80 do container.</p>
</li>
<li>
<p>Instruir os containers do serviço <code>web</code> a compartilhar a porta 80 através de uma rede com balanceador de carga denominada <code>webnet</code>.</p>
</li>
<li>
<p>Definir a rede <code>webnet</code> com opções padrão (no caso, uma rede com balanceador de carga em <em>overlay</em>).</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Vamos testar? Primeiro, temos que iniciar o <em>swarm</em>, que consiste em um conjunto de máquinas rodando o Docker que operam em <em>cluster</em>. Como, neste momento, apenas a máquina <code>docker1</code> integrará esse <em>cluster</em>, ela atuará como o administrador do <em>swarm</em>.</p>
<div class="literalblock">
<div class="content">
<pre># docker swarm init
Swarm initialized: current node (1iys4vxt3k1pkcasdufb4m5vc) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-3jpdh6q1i5a9fay1y3nwavb18enoqhujwxk9bgin2k4as1p38z-6ft56u5yq0zxpc7wcsmvgzsux 10.0.42.9:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</pre>
</div>
</div>
<div class="paragraph">
<p>Agora sim, vamos iniciar a <em>stack</em> do serviço. Iremos nomeá-la <code>pyhello-stack</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cd ~/docker ; docker stack deploy -c docker-compose.yml pyhello-stack
Creating network pyhello-stack_webnet
Creating service pyhello-stack_web</pre>
</div>
</div>
<div class="paragraph">
<p>A partir desse momento, a <em>stack</em> do serviço está rodando 5 instâncias de containers da imagem <code>pyhello-v1</code>.</p>
</div>
</li>
<li>
<p>Verifique se, de fato, todos esses containers estão rodando com <code>docker service ls</code>:</p>
<div class="literalblock">
<div class="content">
<pre># docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                          PORTS
nrglkuxxdyer        pyhello-stack_web   replicated          5/5                 seg10docker/seg10:pyhello-v1   *:7080-&gt;80/tcp</pre>
</div>
</div>
<div class="paragraph">
<p>O serviço reporta que há 5 réplicas operando. Para visualizá-las individualmente, use <code>docker service ps</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker service ps pyhello-stack_web
ID                  NAME                  IMAGE                          NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS
x69lu01rscpt        pyhello-stack_web.1   seg10docker/seg10:pyhello-v1   docker1             Running             Running 2 minutes ago
i0id1ygbu7ba        pyhello-stack_web.2   seg10docker/seg10:pyhello-v1   docker1             Running             Running 2 minutes ago
uiu2pvojpzvw        pyhello-stack_web.3   seg10docker/seg10:pyhello-v1   docker1             Running             Running 2 minutes ago
9tpopx8y3prr        pyhello-stack_web.4   seg10docker/seg10:pyhello-v1   docker1             Running             Running 2 minutes ago
wp539pcus74u        pyhello-stack_web.5   seg10docker/seg10:pyhello-v1   docker1             Running             Running 2 minutes ago</pre>
</div>
</div>
<div class="paragraph">
<p>Também é possível listar todos os containers operando via <code>docker container ls</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker container ls -q
f12b9b2db505
81c893056bfa
4b0c462de8f5
70b9a762aed2
0e4742201217</pre>
</div>
</div>
<div class="paragraph">
<p>No navegador em sua máquina física, acessando o IP da interface <code>enp0s3</code> da máquina <code>ns1</code>, porta 7080, solicite o recarregamento da página diversas vezes com o atalho <code>F5</code>. Note como, a cada <em>refresh</em>, o ID do container muda no campo <em>Hostname</em>.</p>
</div>
</li>
<li>
<p>Suponhamos que temos um pico de acessos, e é necessário aumentar de 5 para 8 o número de réplicas de container ativas. O Docker permite que façamos isso sem ter que reiniciar o serviço, veja: primeiro, edite o arquivo <code>/root/docker/docker-compose.yml</code>.</p>
<div class="literalblock">
<div class="content">
<pre># sed -i 's/^\([[:space:]]*replicas:\).*/\1 8/' ~/docker/docker-compose.yml</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep replicas ~/docker/docker-compose.yml
      replicas: 8</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, faça o <em>redeploy</em> do serviço:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cd ~/docker ; docker stack deploy -c docker-compose.yml pyhello-stack
Updating service pyhello-stack_web (id: nrglkuxxdyer9andac5feb51t)</pre>
</div>
</div>
<div class="paragraph">
<p>Note que o número de réplicas de containers aumenta imediatamente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                          PORTS
nrglkuxxdyer        pyhello-stack_web   replicated          8/8                 seg10docker/seg10:pyhello-v1   *:7080-&gt;80/tcp</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># docker container ls -q
fc5d90deda22
afeb8dc18eea
bb599b864df5
f12b9b2db505
81c893056bfa
4b0c462de8f5
70b9a762aed2
0e4742201217</pre>
</div>
</div>
</li>
<li>
<p>Para interromper o serviço, remove a <em>stack</em> com o comando <code>docker stack rm</code>:</p>
<div class="literalblock">
<div class="content">
<pre># docker stack rm pyhello-stack
Removing service pyhello-stack_web
Removing network pyhello-stack_webnet</pre>
</div>
</div>
<div class="paragraph">
<p>Depois, abandone o <em>swarm</em> usando <code>docker swarm leave</code>. Como a máquina <code>docker1</code> é um administrador do <em>swarm</em>, temos que usar o parâmetro <code>--force</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker swarm leave --force
Node left the swarm.</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que todos os containers foram encerrados, como esperado.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker container ls -q | wc -l
0</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_7_operando_com_múltiplos_membros_no_cluster">7) Operando com múltiplos membros no cluster</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Operar com múltiplas máquinas no <em>cluster</em> (ao invés de apenas uma, como fizemos com a máquina <code>docker1</code> na atividade anterior) é bastante fácil. Primeiro, acesse a máquina <code>docker1</code> como <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker1
root</pre>
</div>
</div>
</li>
<li>
<p>Inicie o <em>swarm</em> como fizemos anteriormente, com o comando <code>docker swarm init</code>:</p>
<div class="literalblock">
<div class="content">
<pre># docker swarm init
Swarm initialized: current node (k0nruds0qup7nscmf0j43jb30) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-3mw379ioa403z9kpu2rfbnjdzct1o4p33xh83zngsyey0rw9lp-afg4svcx1rjprgvug53vm21v4 10.0.42.9:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</pre>
</div>
</div>
<div class="paragraph">
<p>Observe o que fala a segunda linha do <em>output</em> acima: para adicionar novas máquinas ao <em>swarm</em>, execute o comando abaixo na máquina-alvo. Vamos fazer exatamente isso.</p>
</div>
</li>
<li>
<p>Acesse a máquina <code>docker2</code> como <code>root</code>.</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker2
root</pre>
</div>
</div>
<div class="paragraph">
<p>Copie o comando <code>docker swarm join</code> mostrado no <em>output</em> do passo (2), acima, e execute-o na máquina <code>docker2</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker swarm join --token SWMTKN-1-3mw379ioa403z9kpu2rfbnjdzct1o4p33xh83zngsyey0rw9lp-afg4svcx1rjprgvug53vm21v4 10.0.42.9:2377
This node joined a swarm as a worker.</pre>
</div>
</div>
<div class="paragraph">
<p>Pronto! As máquinas <code>docker1</code> e <code>docker2</code> estão agora juntas no <em>cluster</em>, sendo a máquina <code>docker1</code> o <em>manager</em> e a <code>docker2</code> o <em>worker</em> nesse cenário.</p>
</div>
</li>
<li>
<p>Volte à máquina <code>docker1</code>, como <code>root</code>, e faça o <em>deploy</em> do serviço <code>pyhello-stack</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker1
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># cd ~/docker ; docker stack deploy -c docker-compose.yml pyhello-stack
Creating network pyhello-stack_webnet
Creating service pyhello-stack_web</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique quantos containers estão executando na máquina <code>docker1</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker container ls -q | wc -l
4</pre>
</div>
</div>
<div class="paragraph">
<p>Ué, apenas 4 containers? Onde estão os outros 4? O comando <code>docker service ps</code> nos dá uma visão mais ampla da situação:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># docker service ps pyhello-stack_web
ID                  NAME                  IMAGE                          NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
pmshw6028oin        pyhello-stack_web.1   seg10docker/seg10:pyhello-v1   docker2             Running             Running 42 seconds ago
ilcy0qubdj7v        pyhello-stack_web.2   seg10docker/seg10:pyhello-v1   docker1             Running             Running 44 seconds ago
qm8frg324qjj        pyhello-stack_web.3   seg10docker/seg10:pyhello-v1   docker2             Running             Running 42 seconds ago
vdijie0369g8        pyhello-stack_web.4   seg10docker/seg10:pyhello-v1   docker1             Running             Running 43 seconds ago
nqt5l1sm678e        pyhello-stack_web.5   seg10docker/seg10:pyhello-v1   docker2             Running             Running 43 seconds ago
8czx47nhep2n        pyhello-stack_web.6   seg10docker/seg10:pyhello-v1   docker1             Running             Running 44 seconds ago
ryrf4ovcq7d6        pyhello-stack_web.7   seg10docker/seg10:pyhello-v1   docker2             Running             Running 42 seconds ago
4fr3zlwdgqjg        pyhello-stack_web.8   seg10docker/seg10:pyhello-v1   docker1             Running             Running 44 seconds ago</pre>
</div>
</div>
<div class="paragraph">
<p>Veja que temos 4 containers rodando na máquina <code>docker1</code>, e outros 4 rodando na máquina <code>docker2</code>.</p>
</div>
</li>
<li>
<p>Agora, pode surgir uma questão em sua mente: "Ora, se as configurações que fizemos no firewall instruem o repasse de pacotes na porta 7080/TCP diretamente para a máquina <code>docker1</code>, então é evidente que os 4 containers rodando na máquina <code>docker2</code> estão inacessíveis, pelo menos até que corrijamos as regras de firewall, certo?"</p>
<div class="paragraph">
<p>Será mesmo? Na máquina <code>docker2</code>, como <code>root</code>, liste os containers em operação:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker2
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># docker container ls
CONTAINER ID        IMAGE                          COMMAND             CREATED             STATUS              PORTS
              NAMES
37bbca732ec7        seg10docker/seg10:pyhello-v1   "python app.py"     6 minutes ago       Up 6 minutes        80/tcp
              pyhello-stack_web.7.ryrf4ovcq7d6cvrxyoyh372kk
ab9171ebcf69        seg10docker/seg10:pyhello-v1   "python app.py"     6 minutes ago       Up 6 minutes        80/tcp
              pyhello-stack_web.5.nqt5l1sm678e96ctsv2kwuk9f
f0d973c6c635        seg10docker/seg10:pyhello-v1   "python app.py"     6 minutes ago       Up 6 minutes        80/tcp
              pyhello-stack_web.1.pmshw6028oinz61bh509suza3
c420565a43f1        seg10docker/seg10:pyhello-v1   "python app.py"     6 minutes ago       Up 6 minutes        80/tcp
              pyhello-stack_web.3.qm8frg324qjj5roggzfwwznbn</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, em seu navegador na máquina física, recarregue a página algumas vezes e observe os IDs de container que são mostrados:</p>
</div>
<div id="img-docker7" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker7.png" alt="docker7">
</div>
<div class="title">Figure 57. Container da máquina docker2 sendo acessado</div>
</div>
<div class="paragraph">
<p>Note que o ID de container mostrado acima está executando na máquina <code>docker2</code>, mas claramente é impossível que tenhamos acessado essa máquina, já que as regras de firewall criadas anteriormente redirecionam pacotes <strong>apenas</strong> para a máquina <code>docker1</code>. Como isso está acontecendo?</p>
</div>
<div class="paragraph">
<p>A razão pela qual as duas máquinas estão acessíveis é porque um nodo do <em>swarm</em> Docker participa de um roteamento ingresso do tipo <em>mesh</em>, como ilustrado pela figura a seguir. Esse roteamento garante que um serviço alocado a uma porta em seu <em>swarm</em> sempre terá essa porta reservada para si, independente de qual nodo esteja rodando o container. Note, no exemplo, que é perfeitamente possível que uma requisição chegue à máquina <code>docker1</code> mas seja atendida por um container em <code>docker2</code>, ou vice-versa.</p>
</div>
<div id="img-docker-routing" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker-routing.png" alt="docker routing">
</div>
<div class="title">Figure 58. Roteamento do tipo mesh no Docker</div>
</div>
</li>
<li>
<p>Mesmo com a funcionalidade acima, é interessante que o firewall envie requisições para ambas as máquinas <code>docker1</code> e <code>docker2</code>, indistintamente. Volte à máquina <code>ns1</code>, como <code>root</code>.</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Apague as regras que havíamos criado anteriormente.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -D PREROUTING -i enp0s3 -p tcp -m tcp --dport 7080 -j DNAT --to-destination 10.0.42.9</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -D FORWARD -i enp0s3 -d 10.0.42.9/32 -p tcp -m tcp --dport 7080 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Em seu lugar, insira regras que redirecionem o tráfego para ambas as máquinas, em modalidade <em>round robin</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A PREROUTING -i enp0s3 -p tcp -m tcp --dport 7080 -j DNAT --to-destination 10.0.42.9-10.0.42.10</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -i enp0s3 -d 10.0.42.9/32,10.0.42.10/32 -p tcp -m tcp --dport 7080 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Em seu navegador na máquina física, verifique que o serviço continua ativo, recarregando a página algumas vezes.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_8_adicionando_novos_serviços_ao_cluster">8) Adicionando novos serviços ao cluster</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>É bastante fácil adicionar novos serviços a um <em>cluster</em> Docker, mesmo quando em operação. Acesse a máquina <code>docker1</code> como <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker1
root</pre>
</div>
</div>
</li>
<li>
<p>Vamos adicionar um serviço <em>visualizer</em>, um container pré-pronto do Docker que permite que observemos como está a alocação de containers em nosso <em>cluster</em>. Edite o arquivo de configuração do <em>swarm</em>, <code>/root/docker/docker-compose.yml</code>, com o comando <code>sed</code> a seguir:</p>
<div class="literalblock">
<div class="content">
<pre># sed -i '/^networks:$/i\
  visualizer:\
    image: dockersamples/visualizer:stable\
    ports:\
      - "8080:8080"\
    volumes:\
      - "/var/run/docker.sock:/var/run/docker.sock"\
    deploy:\
      placement:\
        constraints: [node.role == manager]\
    networks:\
      - webnet' ~/docker/docker-compose.yml</pre>
</div>
</div>
<div class="paragraph">
<p>O comando acima irá:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Adicionar um novo serviço, <code>visualizer</code>, usando a imagem de container <code>dockersamples/visualizer:stable</code> baixada do <em>registry</em> global do Docker Hub.</p>
</li>
<li>
<p>Mapear a porta externa 8080 para a porta interna 8080, dentro do contexto do container.</p>
</li>
<li>
<p>Criar um mapeamento de volume do <em>socket</em> <code>/var/run/docker.sock</code> na máquina <em>host</em> para o mesmo caminho dentro do container. Vale observar que este <em>socket</em> está disponível exclusivamente no nodo <em>manager</em> do <em>cluster</em>.</p>
</li>
<li>
<p>Por esse motivo, cria-se uma restrição de alocação desse container, que deve rodar exclusivamente em nodos que possuam a <em>role</em> de <em>manager</em> no <em>cluster</em>.</p>
</li>
<li>
<p>Finalmente, conecta-se o serviço à mesma rede <code>webnet</code> que havíamos criado antes.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Para lançar o novo serviço, basta executar um <em>redeploy</em> da <em>stack</em>:</p>
<div class="literalblock">
<div class="content">
<pre># cd ~/docker ; docker stack deploy -c docker-compose.yml pyhello-stack
Creating service pyhello-stack_visualizer
Updating service pyhello-stack_web (id: fld46go1hn34kirew3xn3019v)</pre>
</div>
</div>
<div class="paragraph">
<p>O Docker detecta que a imagem <code>dockersamples/visualizer:stable</code> está indisponível localmente, e faz o download da mesma do <em>registry</em> global, lançando-a em seguida.</p>
</div>
</li>
<li>
<p>Presumindo que o serviço está ativo, note que estamos fazendo um novo mapeamento de portas: da 8080 (externa) para a 8080 (interna). Temos, naturalmente, que fazer ajustes em nosso firewall de rede. Acesse a máquina <code>ns1</code> como <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Apague as regras recém-criadas:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -D PREROUTING -i enp0s3 -p tcp -m tcp --dport 7080 -j DNAT --to-destination 10.0.42.9-10.0.42.10</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -D FORWARD -i enp0s3 -d 10.0.42.9/32,10.0.42.10/32 -p tcp -m tcp --dport 7080 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Torne-as mais abrangentes, incluindo também a porta 8080:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -t nat -A PREROUTING -i enp0s3 -p tcp -m multiport --dports 7080,8080 -j DNAT --to-destination 10.0.42.9-10.0.42.10</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># iptables -A FORWARD -i enp0s3 -d 10.0.42.9/32,10.0.42.10/32 -p tcp -m multiport --dports 7080,8080 -j ACCEPT</pre>
</div>
</div>
<div class="paragraph">
<p>Agora sim, sendo estas regras definitivas, grave-as na configuração do firewall local:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># /etc/init.d/netfilter-persistent save
[....] Saving netfilter rules...run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save
run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save
done.</pre>
</div>
</div>
</li>
<li>
<p>Em sua máquina física, aponte agora o navegador para o IP público do <em>datacenter</em>, o endereço do interface <code>enp0s3</code> da máquina <code>ns1</code> na porta 8080:</p>
<div id="img-docker8" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker8.png" alt="docker8">
</div>
<div class="title">Figure 59. Visualizando a operação do cluster Docker</div>
</div>
<div class="paragraph">
<p>O container <code>visualizer</code> nos mostra, de forma fácil, como está o estado do <em>cluster</em> Docker. Note como o container <code>visualizer</code> está operando apenas na máquina <code>docker1</code>, já que ela é o <em>manager</em> do <em>swarm</em>. Os containers <code>web</code>, por outro lado, podem operar em qualquer nodo, estando distribuídos 4 a cada lado.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_9_configurando_a_persistência_dos_dados">9) Configurando a persistência dos dados</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Você deve ter notado que o contador de visitantes do website, por algum motivo, não está funcionando. Isso se deve ao fato que o serviço do Redis, que fornece uma espécie de banco de dados em arquivo, não está operacional. Vamos corrigir isso: acesse a máquina <code>docker1</code> como <code>root</code>.</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
docker1
root</pre>
</div>
</div>
</li>
<li>
<p>Para adicionar um serviço para o Redis, edite o arquivo de configuração <code>/root/docker/docker-compose.yml</code> com o comando <code>sed</code> a seguir:</p>
<div class="literalblock">
<div class="content">
<pre># sed -i '/^networks:$/i\
  redis:\
    image: redis\
    ports:\
      - "6379:6379"\
    volumes:\
      - "/root/data:/data"\
    deploy:\
      placement:\
        constraints: [node.role == manager]\
    command: redis-server --appendonly yes\
    networks:\
      - webnet' ~/docker/docker-compose.yml</pre>
</div>
</div>
<div class="paragraph">
<p>O comando acima irá:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Adicionar um novo serviço, <code>redis</code>, usando a imagem de container <code>redis</code> baixada do <em>registry</em> global do Docker Hub.</p>
</li>
<li>
<p>Mapear a porta externa 6379 para a porta interna 6379, dentro do contexto do container. Como esse serviço não será acessado externamente, não será necessário criar novas regras no firewall <code>ns1</code>.</p>
</li>
<li>
<p>Criar um mapeamento de volume do diretório <code>/root/data</code> na máquina <em>host</em> para o caminho <code>/data</code> dentro do container. A persistência de dados de vistantes do website será armazenada nesse diretório.</p>
</li>
<li>
<p>Cria-se uma restrição de alocação desse container, que deve rodar exclusivamente em nodos que possuam a <em>role</em> de <em>manager</em> no <em>cluster</em>. Assim, todos os containers do <em>cluster</em> terão a mesma visão dos dados em persistência.</p>
</li>
<li>
<p>Finalmente, conecta-se o serviço à mesma rede <code>webnet</code> que havíamos criado antes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Naturalmente, temos que criar o diretório <code>/root/data</code>, que ainda não existe:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkdir ~/data</pre>
</div>
</div>
</li>
<li>
<p>Faça o <em>redeploy</em> da <em>stack</em>:</p>
<div class="literalblock">
<div class="content">
<pre># cd ~/docker ; docker stack deploy -c docker-compose.yml pyhello-stack
Updating service pyhello-stack_visualizer (id: kzzk52hi201lz8jlsoif86p45)
Creating service pyhello-stack_redis
Updating service pyhello-stack_web (id: fld46go1hn34kirew3xn3019v)</pre>
</div>
</div>
</li>
<li>
<p>Em sua máquina física, aponte o navegador para o IP público do <em>datacenter</em>, o endereço do interface <code>enp0s3</code> da máquina <code>ns1</code> na porta 7080. Note que o contador de visitas está, agora sim, sendo contabilizado corretamente:</p>
<div id="img-docker9" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker9.png" alt="docker9">
</div>
<div class="title">Figure 60. Contador de visitas operacional</div>
</div>
<div class="paragraph">
<p>Recarregue a página algumas vezes, e observe que o contador continua aumentando independentemente do fato de estarmos sendo atendidos por um container localizado na máquina <code>docker1</code> ou na máquina <code>docker2</code>. Como todos os containers tem a mesma visão da "verdade", isto é, a base de dados compartilhada no diretório <code>/root/data</code> da máquina <code>docker1</code>, conseguimos obter o valor correto e incrementá-lo sem importar de onde está partindo a requisição.</p>
</div>
<div class="paragraph">
<p>Observando o <code>visualizer</code>, que opera na porta 8080, note que o container do Redis executa exclusivamente na máquina <code>docker1</code>, como configurado:</p>
</div>
<div id="img-docker10" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/docker10.png" alt="docker10">
</div>
<div class="title">Figure 61. Máquina docker1 executando visualizador e Redis</div>
</div>
</li>
<li>
<p>Encerradas as nossas atividades com containers, encerre o <em>stack</em> e <em>swarm</em> em ambas as máquinas <code>docker1</code> e <code>docker2</code>, e desligue-as. Para manter reduzido o uso de recursos durante o decorrer das próximas sessões, é interessante que tenhamos o mínimo de VMs operacionais.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_9_criação_de_sistemas_linux_customizados">Sessão 9: Criação de sistemas Linux customizados</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nesta sessão iremos aprender como criar uma distribuição Linux sob medida usando o <em>live-build</em>, um sistema de construção de distribuições Debian sob medida.</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão_8">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>Criaremos apenas uma nova máquina nesta sessão, a saber:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>live</code>, sistema para construção de imagens Linux customizadas usando o sistema <em>live-build</em>. Endereço IP 10.0.42.11/24.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Como de costume, vamos à criação dos registros DNS. Acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo de zonas <code>/etc/nsd/zones/intnet.zone</code>, inserindo entradas A para a máquinas indicadas no começo desta atividade. <strong>Não se esqueça</strong> de incrementar o valor do serial no topo do arquivo!</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/intnet.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep live /etc/nsd/zones/intnet.zone
live    IN    A                 10.0.42.11</pre>
</div>
</div>
<div class="paragraph">
<p>Faça o mesmo para o arquivo de zona reversa:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/10.0.42.zone</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep live /etc/nsd/zones/10.0.42.zone
11      IN   PTR                live.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>Assine o arquivo de zonas usando o <em>script</em> criado anteriormente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash /root/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 6 rrsets, 2 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a criação das entradas usando o comando <code>dig</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig live.intnet +short
10.0.42.11</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># dig -x 10.0.42.11 +short
live.intnet.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_2_criação_da_vm_de_build">2) Criação da VM de build</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos criar a VM <code>live</code> e utilizá-la para criar imagens Linux customizadas. Clone a máquina <code>debian-template</code> para uma de nome <code>live</code>, com uma única interface de rede conectada à DMZ. O IP da máquina será 10.0.42.11/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, na console principal do Virtualbox, acesse o menu <em>Settings</em>. Em <em>System</em> &gt; <em>Motherboard</em> &gt; <em>Base Memory</em>, aloque ao menos 4 GB de RAM para essa VM. Adicionalmente, vá para <em>System</em> &gt; <em>Processor</em> e aumente o número de processadores disponíveis para a máquina, tanto quanto possível: se você tiver à disposição uma máquina <em>quad-core</em>, por exemplo, aloque dois processadores; caso sejam oito <em>cores</em>, aloque quatro CPUs, e assim sucessivamente.</p>
</div>
<div class="paragraph">
<p>Essas alterações são necessárias pois o processo de <em>build</em> de uma nova distribuição é bastante intensivo computacionalmente, e quanto mais processamento tivermos à disposição, mais cedo concluiremos os passos.</p>
</div>
<div class="paragraph">
<p>Em <em>Settings</em> &gt; <em>Storage</em> &gt; <em>Controller: SATA</em>, adicione um novo disco à VM. Escolha o formato VDI, alocação dinâmica de espaço, nome da unidade <code>live-build</code> e 20 GB de tamanho. Iremos usar este espaço para fazer o download e instalação dos pacotes das distribuições customizadas em um <em>chroot</em> dedicado.</p>
</div>
<div class="paragraph">
<p>Finalmente, clique em <em>OK</em> e ligue a VM. Logue como <code>root</code> e use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática, como de costume.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h live -i 10.0.42.11 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Aplique o <em>baseline</em> de segurança à máquina <code>live</code>, repetindo o que fizemos no passo (2), atividade (2) da sessão 7:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\[srv\]/a live' ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l live -Ke ansible_become_method=su ~/ansible/srv.yml ; ansible-playbook -i ~/ansible/hosts -l live ~/ansible/srv.yml
SUDO password:

(...)

PLAY RECAP **********************************************************************************************************

live                       : ok=10   changed=8    unreachable=0    failed=0</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_construindo_uma_distribuição_mínima">3) Construindo uma distribuição mínima</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acesse a máquina <code>live</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
live
root</pre>
</div>
</div>
</li>
<li>
<p>Vamos preparar o disco para uso. Descubra sob qual nome ele foi detectado:</p>
<div class="literalblock">
<div class="content">
<pre># dmesg | grep 'GiB'
[    1.507032] sd 2:0:0:0: [sda] 16777216 512-byte logical blocks: (8.59 GB/8.00 GiB)
[    1.507324] sd 3:0:0:0: [sdb] 41943040 512-byte logical blocks: (21.5 GB/20.0 GiB)</pre>
</div>
</div>
<div class="paragraph">
<p>Perfeito, o nome do disco é <code>/dev/sdb</code>. Use o <code>fdisk</code> para formatá-lo&#8201;&#8212;&#8201;crie uma única partição do tipo LVM ocupando a totalidade do espaço.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># fdisk /dev/sdb

Bem-vindo ao fdisk (util-linux 2.29.2).
As alterações permanecerão apenas na memória, até que você decida gravá-las.
Tenha cuidado antes de usar o comando de gravação.

A unidade não contém uma tabela de partição conhecida.
Criado um novo rótulo de disco DOS com o identificador de disco 0x19d210eb.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): o
Criado um novo rótulo de disco DOS com o identificador de disco 0xdaead0ba.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): n
Tipo da partição
   p   primária (0 primárias, 0 estendidas, 4 livre)
   e   estendida (recipiente para partições lógicas)
Selecione (padrão p): p
Número da partição (1-4, padrão 1): 1
Primeiro setor (2048-41943039, padrão 2048):
Último setor, +setores ou +tamanho{K,M,G,T,P} (2048-41943039, padrão 41943039):

Criada uma nova partição 1 do tipo "Linux" e de tamanho 20 GiB.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): t
Selecionou a partição 1
Tipo de partição (digite L para listar todos os tipos): 8e
O tipo da partição "Linux" foi alterado para "Linux LVM".</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Comando (m para ajuda): w
A tabela de partição foi alterada.
Chamando ioctl() para reler tabela de partição.
Sincronizando discos.</pre>
</div>
</div>
<div class="paragraph">
<p>Inicialize o disco para o sistema LVM:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pvcreate /dev/sdb1
  Physical volume "/dev/sdb1" successfully created.</pre>
</div>
</div>
<div class="paragraph">
<p>Crie novos VG/LV para o disco:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># vgcreate vg-live /dev/sdb1
  Volume group "vg-live" successfully created</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># lvcreate -l +100%FREE -n lv-live vg-live
  Logical volume "lv-live" created.</pre>
</div>
</div>
<div class="paragraph">
<p>Formate-o sob o sistema de arquivos <code>ext4</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkfs.ext4 /dev/mapper/vg--live-lv--live
mke2fs 1.43.4 (31-Jan-2017)
Creating filesystem with 5241856 4k blocks and 1310720 inodes
Filesystem UUID: 0716d2c6-cd6a-43a0-ab04-83075886e790
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
        4096000

Allocating group tables: done
Writing inode tables: done
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done</pre>
</div>
</div>
<div class="paragraph">
<p>Configure a montagem automática via <code>/etc/fstab</code> no diretório <code>/live</code>, e monte o disco:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkdir /live</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># echo '/dev/mapper/vg--live-lv--live /live ext4 defaults 0 2' &gt;&gt; /etc/fstab</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mount -a</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># df -h | grep live
/dev/mapper/vg--live-lv--live   20G   45M   19G   1% /live</pre>
</div>
</div>
</li>
<li>
<p>Instale a ferramenta que iremos utilizar para construir imagens customizadas, o <em>live-build</em>:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y live-build</pre>
</div>
</div>
</li>
<li>
<p>Vamos fazer uma imagem mínima para experimentar com o sistema do <em>live-build</em>. Crie o diretório novo <code>/live/basic</code>, e entre nele:</p>
<div class="literalblock">
<div class="content">
<pre># mkdir /live/basic ; cd /live/basic</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>lb config</code> irá criar uma estrutura de diretórios padrão para o <em>live-build</em> operar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lb config</pre>
</div>
</div>
<div class="paragraph">
<p>Antes de disparar o <em>build</em>, vamos apenas customizar o conjunto de repositórios usados para buscar os pacotes de instalação para uma opção mais veloz:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|ftp.debian.org|ftp.br.debian.org|g' /live/basic/config/bootstrap</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|ftp.debian.org|ftp.br.debian.org|g' /live/basic/config/build</pre>
</div>
</div>
<div class="paragraph">
<p>Desabilite também a instalação de <em>firmwares</em> diversos para o kernel Linux&#8201;&#8212;&#8201;como iremos rodar a distribuição exclusivamente em um ambiente virtualizado, não há porque atrasar o <em>build</em> e aumentar o tamanho da imagens com <em>drivers</em> que não utilizaremos no sistema finalizado.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|^\(LB_FIRMWARE_[A-Z]*=\).*|\1\"false\"|' /live/basic/config/binary</pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, inicie o <em>build</em> do sistema customizado, e aguarde sua construção. Esse passo pode ser relativamente demorado, então tenha paciência.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># lb build
[2018-11-17 23:51:27] lb build
P: live-build 1:20170213
P: Building config tree for a debian/stretch/amd64 system

(...)

Reading package lists... Done
Building dependency tree
Reading state information... Done
[2018-11-17 23:57:01] lb source</pre>
</div>
</div>
<div class="paragraph">
<p>Para ilustrar o tempo médio a esperar, note que o <em>build</em> acima levou cerca de seis minutos para concluir. Esse tempo pode variar para mais, ou para menos, dependendo da velocidade do processador, memória e disco da máquina física, bem como o volume de recursos alocados à VM <code>live</code>.</p>
</div>
</li>
<li>
<p>O que esse comando produziu? Vejamos:</p>
<div class="literalblock">
<div class="content">
<pre># ls *.iso
live-image-amd64.hybrid.iso</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># du -sm live-image-amd64.hybrid.iso
216     live-image-amd64.hybrid.iso</pre>
</div>
</div>
<div class="paragraph">
<p>Foi criada uma imagem ISO de 216 MB, com um sistema <em>live</em> perfeitamente bootável, que testaremos a seguir.</p>
</div>
</li>
<li>
<p>Copie a imagem ISO produzida no passo (4) acima para sua máquina física. Há vários métodos para se atingir esse objetivo&#8201;&#8212;&#8201;um dos meus favoritos é usar o comando <code>scp</code> no Cygwin, que permite cópia direta da VM para a máquina física, sem a necessidade de instalação de qualquer software adicional. Caso não tenha o Cygwin instalado, considere usar o programa WinSCP, uma ferramenta gráfica que provê funcionalidade semelhante.</p>
<div class="paragraph">
<p>No exemplo abaixo, copiaremos via <code>scp</code> + Cygwin a ISO para a Área de Trabalho do usuário <code>fbs</code>, na máquina física Windows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ scp aluno@10.0.42.11:/live/basic/live-image-amd64.hybrid.iso /cygdrive/c/Users/fbs/Desktop/
aluno@10.0.42.11's password:
live-image-amd64.hybrid.iso                                                        100%  216MB  59.5MB/s   00:03</pre>
</div>
</div>
</li>
<li>
<p>Na console principal do Virtualbox, crie uma nova máquina virtual. Como nome, define <code>iso-test</code>, <em>Type</em> <code>Linux</code> e <em>Version</em> <code>Debian (64-bit)</code>. Mantenha o valor padrão de memória RAM, 1024 GB. Quando perguntado sobre o disco rígida da VM, escolha a opção <em>Do not add a virtual hard disk</em> e clique em <em>Create</em>, confirmando sua escolha.</p>
<div class="paragraph">
<p>Selecione a nova VM e acesse o menu <em>Settings</em> &gt; <em>Storage</em> &gt; <em>Controller: IDE</em>.  Selecione o <em>drive</em> de CD vazio e, em <em>Attributes</em>, escolha o arquivo de disco ótico virtual que copiamos no passo anterior, a imagem <code>live-image-amd64.hybrid.iso</code>.</p>
</div>
<div class="paragraph">
<p>Clique em <em>OK</em> e ligue a máquina virtual. Após a tela de BIOS do Virtualbox, você verá o <em>bootloader</em> do sistema customizado que construímos, como mostrado abaixo:</p>
</div>
<div id="img-live1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/live1.png" alt="live1">
</div>
<div class="title">Figure 62. Bootloader do sistema live</div>
</div>
<div class="paragraph">
<p>Selecione a primeira opção, e prossiga com o <em>boot</em>. Brevemente surgirá um <em>shell</em> para interação com o sistema&#8201;&#8212;&#8201;estamos logados com o usuário <code>user</code>:</p>
</div>
<div id="img-live2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/live2.png" alt="live2">
</div>
<div class="title">Figure 63. Shell do sistema live</div>
</div>
<div class="paragraph">
<p>Temos em mãos um sistema plenamente funcional, operando em memória. Para escalar privilégio para <code>root</code>, execute <code>sudo -i</code>. Para colocar em perspectiva o quão enxuto é o sistema que estamos trabalhando, observe a memória utilizada:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># free -m
              total        used        free      shared  buff/cache   available
Mem:            996          26         872           7          97         847
Swap:             0           0           0</pre>
</div>
</div>
<div class="paragraph">
<p>Apenas 26 MB de RAM! Conte o número de pacotes instalados:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dpkg -l | grep '^ii' | wc -l
198</pre>
</div>
</div>
<div class="paragraph">
<p>Compare com a máquina <code>live</code>, por exemplo, que é derivada de um sistema bastante minimalista que construímos durante a primeira sessão deste curso: ela possui 360 pacotes instalados.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; dpkg -l | grep '^ii' | wc -l
live
360</pre>
</div>
</div>
</li>
<li>
<p>Como o sistema customizado que fizemos está perfeitamente funcional, vamos instalar o cliente OpenSSH:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y openssh-client</pre>
</div>
</div>
<div class="paragraph">
<p>O APT consegue instalar pacotes mesmo operando em memória, como podemos ver. Produza uma lista dos pacotes instalados e copie-a para a máquina <code>live</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dpkg -l | grep '^ii' &gt; /tmp/basic-packages.txt</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># scp /tmp/basic-packages.txt aluno@10.0.42.11:~
aluno@10.0.42.11's password:
basic-packages.txt                                 100%   24KB  20.4MB/s   00:00</pre>
</div>
</div>
</li>
<li>
<p>Apesar de interessante, nosso sistema customizado ainda não faz muita coisa. Desligue-o, e vamos tentar incrementá-lo.</p>
<div class="literalblock">
<div class="content">
<pre># halt -p</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_utilizando_um_repositório_local_de_pacotes">4) Utilizando um repositório local de pacotes</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Volte à máquina <code>live</code>, como o usuário <code>root</code>. Em seguida, verifique o tamanho do diretório <code>/live/basic</code>.</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
live
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># du -sh /live/basic/
1,6G    /live/basic/</pre>
</div>
</div>
<div class="paragraph">
<p>Note que mesmo para produzir um sistema tão básico quando o que fizemos na atividade (3), o sistema de <em>build</em> ocupou 1,6 <strong>gigabytes</strong> de espaço em disco! Além da necessidade de criar um sistema de <em>bootstrap</em> e um <em>chroot</em> que contém o sistema customizado, é também necessário armazenar todos os pacotes <code>.deb</code> que foram baixados durante o <em>build</em>.</p>
</div>
</li>
<li>
<p>Para limpar os arquivos de trabalho do <em>live-build</em>, utilize o comando <code>lb clean</code>. Para remover a totalidade dos arquivos gerados pelo <em>live-build</em>, como diretórios de <em>cache</em>, <em>chroot</em>, binários e fontes, use a opção <code>--purge</code>.</p>
<div class="literalblock">
<div class="content">
<pre># cd /live/basic ; lb clean --purge</pre>
</div>
</div>
<div class="paragraph">
<p>Volte a verificar o tamanho da pasta <code>/live/basic</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># du -sh /live/basic/
208K    /live/basic/</pre>
</div>
</div>
</li>
<li>
<p>Se quisermos produzir um novo sistema, como fizemos antes, basta rodar o comando <code>lb build</code> novamente. Note, porém, que todos os pacotes <code>.deb</code> de instalação do <em>bootstrap</em> e sistema-base serão baixados novamente&#8201;&#8212;&#8201;como a construção de sistemas customizados normalmente envolve uma boa quantidade de tentativa e erro, a quantidade de dados a serem baixados a cada <em>build</em> irá rapidamente se tornar a principal fonte de atraso no processo.</p>
<div class="paragraph">
<p>Para suplantar esse problema, podemos construir um repositório local de pacotes, usando por exemplo a ferramenta Aptly. Ao contrário de um espelho total do repositório de pacotes do Debian, que é gigantesco (estimado em 326 GB quando da escrita desta atividade, ref. <a href="https://www.debian.org/mirror/size" class="bare">https://www.debian.org/mirror/size</a>), o Aptly permite que façamos um repositório local bastante enxuto, contendo apenas os pacotes necessários à instalação do sistema-base e suas dependências.</p>
</div>
<div class="paragraph">
<p>Copie o diretório <code>/live/basic</code> para <code>/live/aptly-basic</code>, e entre dentro do novo diretório.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cp -a /live/basic /live/aptly-basic ; cd /live/aptly-basic</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, crie o arquivo novo <code>/live/aptly-basic/makebuild.sh</code>, com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

ABS_PATH=`readlink -f $0 | sed 's/\/[^\/]*$//'`

if uname -r | egrep '686-pae$' &amp;&gt; /dev/null; then
  LB_DISK="${ABS_PATH}/live-image-i386.img"
  RAW_DISK="${ABS_PATH}/live-image-i386.raw"
  LINUX_HEADERS="linux-headers-686-pae"
  REPO_ARCH="i386"
else
  LB_DISK="${ABS_PATH}-amd64.img"
  RAW_DISK="${ABS_PATH}/live-image-amd64.raw"
  LINUX_HEADERS="linux-headers-amd64"
  REPO_ARCH="amd64"
fi

DEPSOK="${ABS_PATH}/.depsok"

MIRROR_DIR="${ABS_PATH}/aptly"
PKGL_LB="${MIRROR_DIR}/lb_packages.list"
PKGL_DIR="${ABS_PATH}/config/package-lists"
PKGL_STR="$( cat ${PKGL_LB} ${PKGL_DIR}/* | grep -v '^#' | sed '/^$/d' | sort | paste -s -d'|' | sed 's/|/ | /g' )" FILTER="Priority (required) | Priority (important) | Priority (standard) | ${PKGL_STR}"

OPTS="(update | img | clean | purge)"

# - - - - -


err() {
  echo
  echo "  [*] Error: $1"
}


usage() {
  echo
  echo "----------------------------------------------------------------------------------------"
  echo
  echo "  Usage: $0 -o $OPTS"
  echo
  echo "  Run 'update' first if executing for the first time. Must be connected to the Internet."
  echo "  Run 'img' to build ISO/HDD file. Inbetween builds, run 'clean' or 'purge'."
  echo
  echo "----------------------------------------------------------------------------------------"
  echo
  exit 1
}


setmirror() {
  cat ${MIRROR_DIR}/aptly.conf | sed "s|\(^ *\"rootDir\": \).*|\1\"${MIRROR_DIR}\",|" &gt; /root/.aptly.conf
}


imgbuild() {
  setmirror

  # check if repo key is in place
  if ! [ -f ${ABS_PATH}/config/archives/aptly.key ]; then
    gpg --export --armor &gt; ${ABS_PATH}/config/archives/aptly.key
  fi

  # create and publish mirror snapshots
  aptly snapshot create stretch-main-spei from mirror stretch-main
  aptly snapshot create stretch-updates-spei from mirror stretch-updates
  aptly snapshot create stretch-security-spei from mirror stretch-security

  aptly snapshot merge -latest stretch-final-spei stretch-main-spei stretch-updates-spei stretch-security-spei
  aptly publish snapshot -distribution=stretch stretch-final-spei

  # ensure mirror is not yet running, then run it
  kill $( pgrep -f "aptly serve" ) 2&gt; /dev/null
  aptly serve &amp;

  # run build
  lb build

  # stop mirror and wipe snapshots
  kill $( pgrep -f "aptly serve" ) 2&gt; /dev/null

  aptly publish drop stretch

  aptly snapshot drop stretch-final-spei
  aptly snapshot drop stretch-security-spei
  aptly snapshot drop stretch-updates-spei
  aptly snapshot drop stretch-main-spei
}


update() {
  if ! [ -d /root/.gnupg ]; then
    rngd -r /dev/urandom
    gpg --gen-key --batch ${MIRROR_DIR}/genkey.unattended
    gpg --no-default-keyring --keyring /usr/share/keyrings/debian-archive-keyring.gpg --export | gpg --no-default-keyring --keyring trustedkeys.gpg --import
    killall rngd
  fi

  setmirror

  mirrors="$( aptly mirror list | grep '^ * ' | sed 's/.*\[\([A-Za-z-]*\).*/\1/' )"

  echo "$mirrors" | grep stretch-main      &amp;&gt; /dev/null &amp;&amp; aptly mirror drop stretch-main
  echo "$mirrors" | grep stretch-updates   &amp;&gt; /dev/null &amp;&amp; aptly mirror drop stretch-updates
  echo "$mirrors" | grep stretch-security  &amp;&gt; /dev/null &amp;&amp; aptly mirror drop stretch-security

  aptly mirror create -architectures=${REPO_ARCH} -filter="$FILTER" -filter-with-deps stretch-main http://ftp.br.debian.org/debian/ stretch main contrib non-free
  aptly mirror create -architectures=${REPO_ARCH} -filter="$FILTER" -filter-with-deps stretch-updates http://ftp.br.debian.org/debian/ stretch-updates main contrib non-free
  aptly mirror create -architectures=${REPO_ARCH} -filter="$FILTER" -filter-with-deps stretch-security http://security.debian.org/debian-security/ stretch/updates main contrib non-free

  aptly mirror update stretch-main
  aptly mirror update stretch-updates
  aptly mirror update stretch-security
}


clean () {
  rm -rf ${LB_DISK}
  [ -n "$1" ] &amp;&amp; lb clean --purge || lb clean
}


deps() {
  # add necessary repository sections &amp; update
  sed -i 's/\(main\) *$/\1 contrib non-free/' /etc/apt/sources.list
  apt-get update

  apt-get -y install --no-install-recommends ${LINUX_HEADERS} live-build mbr netcat-traditional syslinux aptly rng-tools dirmngr
}


# - - - - -


if [ $( id -u ) -ne 0 ]; then
  err "$0 must be run as root. Aborting..."
  exit 1
fi

if ! uname -r | egrep '686-pae$|amd64$' &amp;&gt; /dev/null; then
  err "Must run on '686-pae' or 'amd64' kernel archs. Aborting..."
  exit 1
fi

while getopts ":o:" opt; do
  case "$opt" in
    o)
      option=${OPTARG}
      ;;
    *)
      usage
      ;;
  esac
done

[ -z $option ] &amp;&amp; { err "No option specified, aborting."; usage; }

# check deps
if [ ! -f ${DEPSOK} ]; then
  if [ $( which lb ) ] &amp;&amp; [ $( which install-mbr ) ] &amp;&amp; [ $( which nc ) ] &amp;&amp; [ $( which syslinux ) ] &amp;&amp; [ $( which aptly ) ] &amp;&amp; [ $( which rngd ) ] &amp;&amp; [ $( which dirmngr ) ]; then
    echo "All dependencies met. Continuing..."
  else
    echo "Missing dependencies. Installing..."
    deps
  fi

  touch ${DEPSOK}
fi

case ${option} in
  "img")
    mirrors="$( aptly mirror list | grep '^ * ' | sed 's/.*\[\([A-Za-z-]*\).*/\1/' )"
    ! echo "$mirrors" | grep stretch-main &amp;&gt; /dev/null &amp;&amp; { err "No 'stretch-main' mirror detected, run '$0 -o update' first."; usage; }
    ! echo "$mirrors" | grep stretch-updates &amp;&gt; /dev/null &amp;&amp; { err "No 'stretch-updates' mirror detected, run '$0 -oupdate' first."; usage; }
    ! echo "$mirrors" | grep stretch-security &amp;&gt; /dev/null &amp;&amp; { err "No 'stretch-security' mirror detected, run '$0 -o update' first."; usage; }

    imgbuild
    ;;
  "update")
    update
    ;;
  "clean")
    clean
    ;;
  "purge")
    clean all
    ;;
  *)
    usage
    ;;
esac</code></pre>
</div>
</div>
<div class="paragraph">
<p>O <em>script</em> acima é relativamente complexo, então convidamos o aluno a estudá-lo atentamente. Em linhas gerais, o objetivo é automatizar o uso e criação de repositórios locais usando o Aptly antes de iniciar o <em>build</em> de um sistema customizado. Também há a checagem de dependências dos pacotes necessários ao funcionamento do <em>live-build</em> e do Aptly, conjuntamente.</p>
</div>
</li>
<li>
<p>Vamos agora gerar a lista de pacotes que o Aptly deve manter localmente para acelerar a construção do sistema customizado. Crie um diretório de nome <code>aptly</code> dentro da pasta atual:</p>
<div class="literalblock">
<div class="content">
<pre># mkdir /live/aptly-basic/aptly</pre>
</div>
</div>
<div class="paragraph">
<p>Dentro dele, crie o arquivo novo <code>/live/aptly-basic/aptly/aptly.conf</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">{
  "rootDir": "/live/aptly-basic/aptly",
  "downloadConcurrency": 4,
  "downloadSpeedLimit": 0,
  "architectures": [],
  "dependencyFollowSuggests": false,
  "dependencyFollowRecommends": false,
  "dependencyFollowAllVariants": false,
  "dependencyFollowSource": false,
  "dependencyVerboseResolve": false,
  "gpgDisableSign": false,
  "gpgDisableVerify": false,
  "gpgProvider": "gpg",
  "downloadSourcePackages": false,
  "skipLegacyPool": true,
  "ppaDistributorID": "ubuntu",
  "ppaCodename": "",
  "skipContentsPublishing": false,
  "FileSystemPublishEndpoints": {},
  "S3PublishEndpoints": {},
  "SwiftPublishEndpoints": {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Basicamente, no arquivo acima definimos a raiz do repositório local que será criado, bem como quais pacotes serão baixados pelo Aptly (se apenas dependências básicas, ou também pacotes recomendados/sugeridos).</p>
</div>
</li>
<li>
<p>Agora, crie o arquivo novo <code>/live/aptly-basic/aptly/genkey.unattended</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">     Key-Type: default
     Subkey-Type: default
     Name-Real: ESR
     Name-Email: suporte@esr.rnp.br
     Expire-Date: 0
     %no-protection
     %commit
     %echo done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Todos os pacotes mantidos no repositório local do Aptly serão assinados com um par de chaves criado sob demanda&#8201;&#8212;&#8201;as informações de geração das chaves são definidas no arquivo acima.</p>
</div>
</li>
<li>
<p>Crie o arquivo novo <code>/live/aptly-basic/aptly/lb_packages.list</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">adduser
apt
apt-utils
base-files
base-passwd
bash
bsdmainutils
bsdutils
busybox
coreutils
cpio
cron
dash
dbus
dctrl-tools
debconf
debconf-i18n
debian-archive-keyring
debianutils
diffutils
dmidecode
dmsetup
dosfstools
dpkg
e2fslibs
e2fsprogs
extlinux
findutils
firmware-linux-free
gcc-6-base
gnupg
gnupg-agent
gpgv
grep
grub-common
grub-efi-amd64-bin
grub-efi-ia32-bin
gzip
hdmi2usb-fx2-firmware
hostname
ifupdown
init
initramfs-tools
initramfs-tools-core
init-system-helpers
iproute2
iptables
iputils-ping
irqbalance
isc-dhcp-client
isc-dhcp-common
isolinux
ixo-usb-jtag
keyboard-configuration
klibc-utils
kmod
krb5-locales
libacl1
libapparmor1
libapt-inst2.0
libapt-pkg5.0
libassuan0
libattr1
libaudit1
libaudit-common
libblkid1
libbsd0
libbz2-1.0
libc6
libcap2
libcap-ng0
libc-bin
libc-l10n
libcomerr2
libcryptsetup4
libdb5.3
libdbus-1-3
libdebconfclient0
libdevmapper1.02.1
libdns-export162
libedit2
libelf1
libestr0
libexpat1
libfastjson4
libfdisk1
libffi6
libgcc1
libgcrypt20
libgdbm3
libglib2.0-0
libglib2.0-data
libgmp10
libgnutls30
libgpg-error0
libgssapi-krb5-2
libhogweed4
libicu57
libidn11
libidn2-0
libip4tc0
libip6tc0
libiptc0
libisc-export160
libk5crypto3
libkeyutils1
libklibc
libkmod2
libkrb5-3
libkrb5support0
libksba8
liblocale-gettext-perl
liblogging-stdlog0
liblognorm5
liblz4-1
liblzma5
libmnl0
libmount1
libncurses5
libncursesw5
libnetfilter-conntrack3
libnettle6
libnewt0.52
libnfnetlink0
libnpth0
libnuma1
libp11-kit0
libpam0g
libpam-modules
libpam-modules-bin
libpam-runtime
libpcre3
libpipeline1
libpopt0
libprocps6
libpsl5
libreadline7
librsvg2-bin
libseccomp2
libselinux1
libsemanage1
libsemanage-common
libsepol1
libslang2
libsmartcols1
libsqlite3-0
libss2
libssl1.0.2
libssl1.1
libstdc++6
libsystemd0
libtasn1-6
libtext-charwidth-perl
libtext-iconv-perl
libtext-wrapi18n-perl
libtinfo5
libudev1
libunistring0
libustr-1.0-1
libuuid1
libx11-6
libx11-data
libxapian30
libxau6
libxcb1
libxdmcp6
libxext6
libxml2
libxmuu1
libxtables12
linux-base
linux-image-4.9.0-8-amd64
linux-image-amd64
live-boot
live-boot-doc
live-boot-initramfs-tools
live-config
live-config-doc
live-config-systemd
live-tools
locales
login
logrotate
lsb-base
mawk
mount
multiarch-support
nano
ncurses-base
ncurses-bin
netbase
openssh-client
parted
passwd
perl-base
pinentry-curses
procps
readline-common
rsync
rsyslog
sed
sensible-utils
sgml-base
shared-mime-info
squashfs-tools
sudo
syslinux
syslinux-common
systemd
systemd-sysv
sysvinit-utils
tar
tasksel
tasksel-data
tzdata
udev
user-setup
util-linux
uuid-runtime
vim-common
vim-tiny
wget
whiptail
xauth
xdg-user-dirs
xml-core
xorriso
xxd
zlib1g
zsync</code></pre>
</div>
</div>
<div class="paragraph">
<p>A lista acima foi construída a partir da lista de pacotes instalados automaticamente no sistema-base (que copiamos no passo 8 da atividade anterior), bem como através de tentativa-e-erro durante <em>builds</em> consecutivos usando o repositório local. Caso algum pacote essencial esteja faltando, o <em>build</em> irá falhar e reclamar que o pacote não está disponível no repositório local&#8201;&#8212;&#8201;nesse caso, adicionamos o pacote à lista acima e repetimos o <em>build</em>, até que não ocorram mais erros.</p>
</div>
<div class="paragraph">
<p>Se você estiver se perguntando: sim, produzir a lista acima levou UM BOM número de tentativas.</p>
</div>
</li>
<li>
<p>Temos que trocar os repositórios a serem usados durante o <em>build</em>: ao invés de usar os repositórios <code>ftp.br.debian.org</code> e <code>security.debian.org</code>, iremos usar o Aptly local, escutando em <code>127.0.0.1:8080</code>:</p>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|http://ftp\.br\.debian\.org/debian/|http://127\.0\.0\.1:8080/|' /live/aptly-basic/config/bootstrap</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|http://security\.debian\.org/|http://127\.0\.0\.1:8080/|' /live/aptly-basic/config/bootstrap</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|http://httpredir\.debian\.org/debian/|http://127\.0\.0\.1:8080/|' /live/aptly-basic/config/bootstrap</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|http://ftp\.br\.debian\.org/debian/|http://127\.0\.0\.1:8080/|' /live/aptly-basic/config/build</pre>
</div>
</div>
<div class="paragraph">
<p>Uma vez que todos os repositórios serão concatenados em um único, gerenciado localmente pelo Aptly, não precisamos incluir as seções <code>security</code> ou <code>updates</code> no <em>chroot</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|^\(LB_SECURITY=\).*|\1\"false\"|' /live/aptly-basic/config/chroot</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|^\(LB_UPDATES=\).*|\1\"false\"|' /live/aptly-basic/config/chroot</pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, vamos desabilitar a instalação de pacotes recomendados, bem como a checagem de confiança da chave de assinatura dos pacotes no repositório local (já que iremos usar uma chave auto-assinada):</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|^\(LB_APT_RECOMMENDS=\).*|\1\"false"|' /live/aptly-basic/config/common</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|^\(LB_APT_SECURE=\).*|\1\"false"|' /live/aptly-basic/config/common</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|^\(LB_APT_SOURCE_ARCHIVES=\).*|\1\"false"|' /live/aptly-basic/config/common</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|^\(APT_OPTIONS.*\)\"|\1 -o Acquire::ForceIPv4=true\"|' /live/aptly-basic/config/common</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i 's|^\(DEBOOTSTRAP_OPTIONS.*\)\"|\1--no-check-gpg\"|' /live/aptly-basic/config/common</pre>
</div>
</div>
</li>
<li>
<p>Algumas das coisas que mais ocupam espaço em instalações minimalistas&#8201;&#8212;&#8201;além de bibliotecas e <em>drivers</em> essenciais&#8201;&#8212;&#8201;são artefatos como páginas de manual, documentação e <em>locales</em> (traduções de <em>strings</em> para diferentes linguagens). Não precisamos de nada disso em nosso sistema!</p>
<div class="paragraph">
<p>Crie o arquivo novo <code>/live/aptly-basic/config/hooks/normal/0450-stripped.hook.chroot</code> com o seguinte conteúdo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/sh

set -e

# remover pacotes desnecessarios
for PACKAGE in apt-utils aptitude man-db manpages info wget dselect
do
	if ! apt-get remove --purge --yes "${PACKAGE}"
	then
		echo "WARNING: ${PACKAGE} isn't installed"
	fi
done

# limpar a cache apt por completo
apt-get autoremove --yes || true
apt-get clean
find /var/cache/apt/ -type f -exec rm -f {} \;
find /var/lib/apt/lists/ -type f -exec rm -f {} \;

# remover arquivos temporarios
find . -name *~ -print0 | xargs -0 rm -f

# remover locales ! en/pt-br
find /usr/share/locale -maxdepth 1 -type d -not -regex '.*\(locale\|en\|pt_BR\)$' | xargs rm -rf

# remover paginas de manual e documentacao
rm -rf /usr/share/groff/*
rm -rf /usr/share/doc/*
rm -rf /usr/share/man/*
rm -rf /usr/share/info/*
rm -rf /usr/share/lintian/*
rm -rf /usr/share/linda/*
rm -rf /var/cache/man/*

# truncar logs
for FILE in $(find /var/log/ -type f)
do
	: &gt; ${FILE}
done</code></pre>
</div>
</div>
<div class="paragraph">
<p>O <em>script</em> acima será executado ao final do passo de <em>chroot</em>, e irá remover boa parte dos arquivos que não são integralmente necessários ao funcionamento do sistema, reduzindo o tamanho da imagem final consideravelmente.</p>
</div>
<div class="paragraph">
<p>Não se esqueça de dar permissão de execução ao <em>script</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># chmod +x /live/aptly-basic/config/hooks/normal/0450-stripped.hook.chroot</pre>
</div>
</div>
</li>
<li>
<p>Ufa! Chega de configurações&#8201;&#8212;&#8201;vamos atualizar o repositório local:</p>
<div class="literalblock">
<div class="content">
<pre># cd /live/aptly-basic/ ; bash makebuild.sh -o update</pre>
</div>
</div>
<div class="paragraph">
<p>O <em>script</em> irá detectar dependências faltantes e instalá-las, e posteriormente irá baixar todos os pacotes que mapeamos no passo (6) desta atividade para o repositório APT local.</p>
</div>
</li>
<li>
<p>Uma vez concluído o download, rode novamente o <em>build</em> do sistema customizado:</p>
<div class="literalblock">
<div class="content">
<pre># cd /live/aptly-basic/ ; date &gt; buildtime ; bash makebuild.sh -o img  ; date &gt;&gt; buildtime</pre>
</div>
</div>
<div class="paragraph">
<p>O Aptly irá publicar um repositório local com todos os pacotes que baixamos no passo anterior, e logo a seguir o comando <code>lb build</code> será invocado. Note como a velocidade de obtenção dos pacotes é significativamente superior, desta vez.</p>
</div>
<div class="paragraph">
<p>Note que criamos um arquivo <code>/live/aptly-basic/buildtime</code> para registrar o tempo de <em>build</em>, desta vez. Confira seu conteúdo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /live/aptly-basic/buildtime
dom nov 18 01:24:35 -02 2018
dom nov 18 01:26:56 -02 2018</pre>
</div>
</div>
<div class="paragraph">
<p>No mesmo sistema que produziu o <em>build</em> da atividade (3), note que o tempo caiu de cerca de seis minutos para, agora, cerca de 2 minutos e 20 segundos. Significativo, não? E outra vantagem&#8201;&#8212;&#8201;se precisarmos refazer o <em>build</em>, todos os pacotes já estão na <em>cache</em> local, e não precisam ser baixados novamente!</p>
</div>
</li>
<li>
<p>Vamos ver se nossas otimizações de espaço surtiram efeito no tamanho da imagem:</p>
<div class="literalblock">
<div class="content">
<pre># du -sh /live/aptly-basic/live-image-amd64.hybrid.iso
129M    /live/aptly-basic/live-image-amd64.hybrid.iso</pre>
</div>
</div>
<div class="paragraph">
<p>De 216 MB na imagem anterior, temos agora uma imagem equivalente de tamanho igual a 129 MB, apenas com a remoção de documentação, <em>locales</em> e outros arquivos acessórios. Uma redução de 40%!</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_5_construindo_uma_imagem_mais_divertida">5) Construindo uma imagem mais&#8230;&#8203; divertida?</h3>
<div class="paragraph">
<p>É bem verdade que apesar de extremamente enxuto, nosso sistema customizado não faz nada&#8230;&#8203; interessante, até aqui. Para incrementar suas funcionalidades, vamos produzir um sistema que possua um ambiente gráfico e um navegador.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Entre na pasta <code>/live/aptly-basic</code> e limpe os arquivos de trabalho do <em>build</em> anterior. Vamos usá-la como base para nossa próxima imagem.</p>
<div class="literalblock">
<div class="content">
<pre># cd /live/aptly-basic/ ; bash makebuild.sh -o purge
[2018-11-18 01:35:53] lb clean --purge
P: Cleaning chroot</pre>
</div>
</div>
<div class="paragraph">
<p>Note que o diretório ainda é significativamente grande, em razão da <em>cache</em> de pacotes do Aptly:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># du -sh /live/aptly-basic/
263M    /live/aptly-basic/</pre>
</div>
</div>
</li>
<li>
<p>Copie o diretório <code>/live/aptly-basic</code> para um novo <code>/live/aptly-x</code>, e entre nesse diretório:</p>
<div class="literalblock">
<div class="content">
<pre># cp -a /live/aptly-basic /live/aptly-x ; cd /live/aptly-x</pre>
</div>
</div>
</li>
<li>
<p>Podemos customizar a lista de pacotes instalados em uma imagem do <em>live-build</em> criando arquivos de pacotes no diretório <code>config/package-lists</code>. Crie o arquivo novo <code>/live/aptly-x/config/package-lists/my.list.chroot</code> com o seguinte conteúdo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-conf" data-lang="conf">feh
firefox-esr
fluxbox
initramfs-tools
keyboard-configuration
live-tools
locales
nodm
openssl
rsync
sudo
task-desktop
user-setup
uuid-runtime
xterm
x11-xserver-utils</code></pre>
</div>
</div>
<div class="paragraph">
<p>No arquivo acima informamos que, além dos pacotes básicos do sistema <em>live</em>, instalaremos também o sistema gráfico X.Org, o gerenciador de janelas Fluxbox e o navegador web Mozilla Firefox, dentre outros pacotes.</p>
</div>
</li>
<li>
<p>É também possível customizar quais arquivos estão presentes no <em>build</em> final, inserindo-os em uma raiz alternativa no diretório <code>config/includes.chroot</code>. Suponha que queiramos que o usuário <code>user</code>, ao fazer login no sistema <em>live</em>, tenha lançado para si o gerenciador de janelas Fluxbox.</p>
<div class="paragraph">
<p>Crie o caminho de diretórios apropriado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mkdir -p /live/aptly-x/config/includes.chroot/home/user/</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, crie o arquivo <code>.xinitrc</code> com a configuração adequada:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># echo "startfluxbox" &gt; /live/aptly-x/config/includes.chroot/home/user/.xinitrc</pre>
</div>
</div>
<div class="paragraph">
<p>Quando iniciarmos o sistema <em>live</em>, os diretórios e arquivos que criamos acima já estarão presentes na distribuição, e o gerenciado de login <code>nodm</code> se encarregará de iniciar o Fluxbox automaticamente. Esse é um excelente método para distribuir arquivos e configurações em sistemas especialistas, como um servidor web embarcado, por exemplo.</p>
</div>
</li>
<li>
<p>Tudo pronto? Vamos atualizar a lista de pacotes do repositório local, já que fizemos várias adições novas no passo (3):</p>
<div class="literalblock">
<div class="content">
<pre># cd /live/aptly-x ; bash makebuild.sh -o update</pre>
</div>
</div>
<div class="paragraph">
<p>Os pacotes faltantes e suas dependências serão baixados para o <em>mirror</em> Aptly local, como esperado.</p>
</div>
</li>
<li>
<p>Faça o <em>build</em> do sistema customizado:</p>
<div class="literalblock">
<div class="content">
<pre># cd /live/aptly-x/ ; date &gt; buildtime ; bash makebuild.sh -o img  ; date &gt;&gt; buildtime</pre>
</div>
</div>
<div class="paragraph">
<p>Vamos ver qual foi o tempo de <em>build</em> para esse sistema, um pouco mais complexo que o anterior:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /live/aptly-x/buildtime
dom nov 18 01:51:13 -02 2018
dom nov 18 01:55:12 -02 2018</pre>
</div>
</div>
<div class="paragraph">
<p>Cerca de quatro minutos, muito bom. E quanto ao tamanho?</p>
</div>
<div class="literalblock">
<div class="content">
<pre># du -sh /live/aptly-x/live-image-amd64.hybrid.iso
262M    /live/aptly-x/live-image-amd64.hybrid.iso</pre>
</div>
</div>
<div class="paragraph">
<p>Com 262 MB, o tamanho é superior ao que tínhamos obtido com o sistema básico anterior, mas ainda é certamente muito inferior ao que poderíamos esperar de uma distribuição Linux de propósito geral&#8201;&#8212;&#8201;especialmente ao considerar que essa imagem inclui sistema gráfico, ambiente de janelas e o navegador Mozilla Firefox.</p>
</div>
</li>
<li>
<p>Vamos aos testes. Copie a imagem para sua máquina física usando o comando <code>scp</code> ou o programa WinSCP:</p>
<div class="literalblock">
<div class="content">
<pre>$ scp aluno@10.0.42.11:/live/aptly-x/live-image-amd64.hybrid.iso /cygdrive/c/Users/fbs/Desktop/
aluno@10.0.42.11's password:
live-image-amd64.hybrid.iso                                                        100%  262MB  59.6MB/s   00:04</pre>
</div>
</div>
<div class="paragraph">
<p>Inicie a VM <code>iso-test</code> na console principal do Virtualbox. Não é necessário reconfigurá-la, já que o caminho do CD de <em>boot</em> aponta para o mesmo arquivo que sobrescrevemos na cópia acima.</p>
</div>
<div id="img-live3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/live3.png" alt="live3">
</div>
<div class="title">Figure 64. Fluxbox iniciado no sistema live</div>
</div>
<div class="paragraph">
<p>Legal, não é mesmo? Que tal navegar na Internet? Lance o <code>xterm</code> com o atalho <code>ALT + F1</code>, e invoque o Mozilla Firefox com o comando <code>firefox &amp;</code>:</p>
</div>
<div id="img-live4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/live4.png" alt="live4">
</div>
<div class="title">Figure 65. Navegação no Firefox com o sistema live</div>
</div>
<div class="paragraph">
<p>Temos aberto acima o site da Escola Superior de Redes, rodando dentro de um sistema customizado com tamanho inferior a 300MB, e que fizemos em alguns poucos passos.</p>
</div>
</li>
<li>
<p>Daqui pra frente, seu limite passa a ser sua imaginação:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Como poderíamos tornar a imagem acima ainda mais leve e eficiente? Há outros programas e navegadores que seriam mais apropriados para esse tipo de uso?</p>
</li>
<li>
<p>Para quais outras aplicações seria interessante produzir sistemas especialistas como o que fizemos aqui?</p>
</li>
<li>
<p>Que outras opções de segurança e <em>lockdown</em> poderíamos ativar em nosso sistema customizado para torná-lo ainda mais seguro?</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Encerradas as nossas atividades com a máquina <code>live</code>, recomenda-se que o aluno a mantenha desligada a partir desta sessão. A grande quantidade de recursos demandada por esse sistema para operar com sucesso a torna um peso muito grande na execução das atividades das próximas sessões.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sessão_10_módulos_de_segurança_do_kernel">Sessão 10: Módulos de segurança do kernel</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nesta sessão iremos trabalhar com o módulo de segurança AppArmor, que implementa um modeloe de segurança MAC (<em>Mandatory Access Controls</em>) para o kernel Linux.</p>
</div>
<div class="sect2">
<h3 id="_1_topologia_desta_sessão_9">1) Topologia desta sessão</h3>
<div class="paragraph">
<p>Criaremos apenas uma nova máquina nesta sessão, a saber:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>lsm</code>, um ambiente para testes de módulos de segurança do kernel, os <em>Linux Security Modules</em>. Endereço IP 10.0.42.12/24.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Como de costume, vamos à criação dos registros DNS. Acesse a máquina <code>ns1</code> como o usuário <code>root</code>:</p>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
ns1
root</pre>
</div>
</div>
<div class="paragraph">
<p>Edite o arquivo de zonas <code>/etc/nsd/zones/intnet.zone</code>, inserindo entradas A para a máquinas indicadas no começo desta atividade. <strong>Não se esqueça</strong> de incrementar o valor do serial no topo do arquivo!</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/intnet.zone
(...)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep lsm /etc/nsd/zones/intnet.zone
lsm     IN    A                 10.0.42.12</pre>
</div>
</div>
<div class="paragraph">
<p>Faça o mesmo para o arquivo de zona reversa:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># nano /etc/nsd/zones/10.0.42.zone</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># grep lsm /etc/nsd/zones/10.0.42.zone
12      IN   PTR                lsm.intnet.</pre>
</div>
</div>
<div class="paragraph">
<p>Assine o arquivo de zonas usando o <em>script</em> criado anteriormente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># bash /root/scripts/signzone-intnet.sh
reconfig start, read /etc/nsd/nsd.conf
ok
ok
ok
ok removed 11 rrsets, 10 messages and 0 key entries</pre>
</div>
</div>
<div class="paragraph">
<p>Verifique a criação das entradas usando o comando <code>dig</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># dig lsm.intnet +short
10.0.42.12</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># dig -x 10.0.42.12 +short
lsm.intnet.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_2_criação_do_ambiente_de_segurança">2) Criação do ambiente de segurança</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos criar a VM <code>lsm</code> e utilizá-la para testes de módulos de segurança do kernel. Clone a máquina <code>debian-template</code> para uma de nome <code>lsm</code>, com uma única interface de rede conectada à DMZ. O IP da máquina será 10.0.42.12/24.</p>
<div class="paragraph">
<p>Concluída a clonagem, ligue a VM e logue como <code>root</code>. Use o script <code>/root/scripts/changehost.sh</code> para fazer a configuração automática, como de costume.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
debian-template
root</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># bash ~/scripts/changehost.sh -h lsm -i 10.0.42.12 -g 10.0.42.1
Signing ssh_host_ecdsa_key.pub key...
Signing ssh_host_ed25519_key.pub key...
Signing ssh_host_rsa_key.pub key...
Configuring host key trust...
Configuring user key trust...
All done!</pre>
</div>
</div>
</li>
<li>
<p>Aplique o <em>baseline</em> de segurança à máquina <code>lsm</code>, repetindo o que fizemos no passo (2), atividade (2) da sessão 7:</p>
<div class="literalblock">
<div class="content">
<pre>$ hostname ; whoami
client
ansible</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ sed -i '/\[srv\]/a lsm' ~/ansible/hosts</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ansible-playbook -i ~/ansible/hosts -l lsm -Ke ansible_become_method=su ~/ansible/srv.yml ; ansible-playbook -i ~/ansible/hosts -l lsm ~/ansible/srv.yml
SUDO password:

(...)

PLAY RECAP **********************************************************************************************************

lsm                       : ok=10   changed=8    unreachable=0    failed=0</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_3_instalação_do_apparmor">3) Instalação do AppArmor</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Vamos agora instalar o AppArmor, um sistema MAC que atua como módulo de segurança do kernel Linux com o objetivo de confinar programas a um conjunto limitado de recursos.</p>
<div class="paragraph">
<p>Acesse a máquina <code>lsm</code> como o usuário <code>root</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># hostname ; whoami
lsm
root</pre>
</div>
</div>
</li>
<li>
<p>Instale os pacotes:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y apparmor apparmor-utils</pre>
</div>
</div>
</li>
<li>
<p>Habilite o AppArmor durante o <em>boot</em> do kernel&#8201;&#8212;&#8201;para isso, basta alterar a linha de <em>boot</em> padrão do GRUB usando os comandos a seguir:</p>
<div class="literalblock">
<div class="content">
<pre># mkdir -p /etc/default/grub.d</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># echo 'GRUB_CMDLINE_LINUX_DEFAULT="$GRUB_CMDLINE_LINUX_DEFAULT apparmor=1 security=apparmor"' \
    &gt; /etc/default/grub.d/apparmor.cfg</pre>
</div>
</div>
<div class="paragraph">
<p>Reconstrua a configuração do GRUB com o comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># update-grub</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, reinicie a máquina para que as configurações realizadas sejam carregadas durante o próximo <em>boot</em>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># reboot</pre>
</div>
</div>
</li>
<li>
<p>Após o <em>reboot</em>, logue novamente como <code>root</code> e verifique o estado de execução do AppArmor:</p>
<div class="literalblock">
<div class="content">
<pre># aa-status
apparmor module is loaded.
0 profiles are loaded.
0 profiles are in enforce mode.
0 profiles are in complain mode.
0 processes have profiles defined.
0 processes are in enforce mode.
0 processes are in complain mode.
0 processes are unconfined but have a profile defined.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_criação_de_um_perfil_apparmor_para_o_servidor_web_nginx">4) Criação de um perfil AppArmor para o servidor web Nginx</h3>
<div class="paragraph">
<p>Em que o AppArmor pode incrementar a segurança do sistema? Vamos fazer um caso de teste com o servidor web Nginx: iremos criar um perfil de segurança para essa aplicação, definindo com precisão o que ela está ou não autorizada a fazer no sistema.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Primeiro, instale o Nginx:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y nginx</pre>
</div>
</div>
<div class="paragraph">
<p>Em sua máquina física, aponte o navegador para o IP da máquina <code>lsm</code>, 10.0.42.12. Voce deverá ver a página a seguir, comprovando que o Nginx foi instalado com sucesso:</p>
</div>
<div id="img-apparmor1" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/apparmor1.png" alt="apparmor1">
</div>
<div class="title">Figure 66. Nginx instalado com sucesso</div>
</div>
</li>
<li>
<p>Vamos criar duas pastas: <code>/data/www/safe</code>, à qual o Nginx deve ter acesso, e <code>/data/www/unsafe</code>, cujo acesso deve ser negado ao Nginx pelo AppArmor.</p>
<div class="literalblock">
<div class="content">
<pre># mkdir -p /data/www/safe</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># mkdir -p /data/www/unsafe</pre>
</div>
</div>
<div class="paragraph">
<p>Em cada uma das pastas, crie um arquivo <code>index.html</code> que indique de forma clara no navegador que estamos, de fato, navegando no local pretendido.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat &lt;&lt; EOF &gt;&gt; /data/www/safe/index.html
&lt;html&gt;
    &lt;b&gt;Oi! Acessar este arquivo e permitido.&lt;/b&gt;
&lt;/html&gt;
EOF</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># cat &lt;&lt; EOF &gt;&gt; /data/www/unsafe/index.html
&lt;html&gt;
    &lt;b&gt;Oi! Acessar este arquivo NAO e permitido.&lt;/b&gt;
&lt;/html&gt;
EOF</pre>
</div>
</div>
</li>
<li>
<p>Altere a configuração do Nginx para servir esses arquivos na porta 8080/TCP, como se segue:</p>
<div class="literalblock">
<div class="content">
<pre># cat &lt;&lt; EOF &gt;&gt; /etc/nginx/conf.d/apparmor.conf
server {
    listen 8080;
    location / {
            root /data/www;
    }
}
EOF</pre>
</div>
</div>
<div class="paragraph">
<p>Recarregue a configuração do Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl reload nginx</pre>
</div>
</div>
<div class="paragraph">
<p>Teste o acesso à URL <code><a href="http://10.0.42.12:8080/safe/" class="bare">http://10.0.42.12:8080/safe/</a></code>:</p>
</div>
<div id="img-apparmor2" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/apparmor2.png" alt="apparmor2">
</div>
<div class="title">Figure 67. Acesso permitido à pasta SAFE</div>
</div>
<div class="paragraph">
<p>O acesso é permitido, como esperado. Evidentemente, o acesso a <code><a href="http://10.0.42.12:8080/unsafe/" class="bare">http://10.0.42.12:8080/unsafe/</a></code> também é autorizado, já que ainda não configuramos o AppArmor.</p>
</div>
<div id="img-apparmor3" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/apparmor3.png" alt="apparmor3">
</div>
<div class="title">Figure 68. Acesso permitido à pasta UNSAFE</div>
</div>
</li>
<li>
<p>O Debian possui um conjunto de perfis pré-prontos para o AppArmor que irão nos auxiliar na tarefa de configuração&#8201;&#8212;&#8201;instale o pacote <code>apparmor-profiles</code>:</p>
<div class="literalblock">
<div class="content">
<pre># apt-get install -y apparmor-profiles</pre>
</div>
</div>
<div class="paragraph">
<p>Para verificar o estado dos perfis do AppArmor, execute o comando <code>apparmor_status</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># apparmor_status
apparmor module is loaded.
33 profiles are loaded.
0 profiles are in enforce mode.
33 profiles are in complain mode.
   /usr/lib/dovecot/anvil
   /usr/lib/dovecot/auth
   /usr/lib/dovecot/config
   /usr/lib/dovecot/deliver
   /usr/lib/dovecot/dict
   /usr/lib/dovecot/dovecot-auth
   /usr/lib/dovecot/dovecot-lda
   /usr/lib/dovecot/dovecot-lda///usr/sbin/sendmail
   /usr/lib/dovecot/imap
   /usr/lib/dovecot/imap-login
   /usr/lib/dovecot/lmtp
   /usr/lib/dovecot/log
   /usr/lib/dovecot/managesieve
   /usr/lib/dovecot/managesieve-login
   /usr/lib/dovecot/pop3
   /usr/lib/dovecot/pop3-login
   /usr/lib/dovecot/ssl-params
   /usr/sbin/avahi-daemon
   /usr/sbin/dnsmasq
   /usr/sbin/dnsmasq//libvirt_leaseshelper
   /usr/sbin/dovecot
   /usr/sbin/identd
   /usr/sbin/mdnsd
   /usr/sbin/nmbd
   /usr/sbin/nscd
   /usr/sbin/smbd
   /usr/sbin/smbldap-useradd
   /usr/sbin/smbldap-useradd///etc/init.d/nscd
   /usr/{sbin/traceroute,bin/traceroute.db}
   klogd
   ping
   syslog-ng
   syslogd
1 processes have profiles defined.
0 processes are in enforce mode.
0 processes are in complain mode.
1 processes are unconfined but have a profile defined.
   /usr/sbin/nscd (400)</pre>
</div>
</div>
</li>
<li>
<p>Vamos criar um perfil de acesso customizado para o Nginx. Entre na pasta <code>/etc/apparmor.d</code> e use o comando <code>aa-autodep nginx</code> para criar um perfil em branco:</p>
<div class="literalblock">
<div class="content">
<pre># cd /etc/apparmor.d</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># aa-autodep nginx
Writing updated profile for /usr/sbin/nginx.</pre>
</div>
</div>
<div class="paragraph">
<p>Uma vez criado o perfil, use o comando <code>aa-complain nginx</code> para colocá-lo no modo <em>complain</em>&#8201;&#8212;&#8201;nesse perfil, violações serão autorizadas, e apenas um alerta será gerado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># aa-complain nginx
Setting /usr/sbin/nginx to complain mode.</pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, reinicie o Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nginx</pre>
</div>
</div>
</li>
<li>
<p>Em seu navegador, acesse a URL <code><a href="http://10.0.42.12:8080/safe/" class="bare">http://10.0.42.12:8080/safe/</a></code> uma vez, e <strong>apenas</strong> essa URL (i.e. não acesse a área <em>unsafe</em>). Essa requisição gerará um evento no log de acessos do Nginx, o qual processaremos a seguir.</p>
</li>
<li>
<p>Feito isso, use o comando <code>aa-logprof</code> para processar os eventos observados no log do Nginx e gerar um perfil de acesso para a aplicação.</p>
<div class="paragraph">
<p>O comando acima irá processar os logs do Nginx e atualizar o perfil de acesso do programa. Para cada tipo de acesso identificado, você deverá responder se deseja autorizar ou negar uma capacidade à aplicação. Assumindo que o sistema não está sob ataque, é razoável supor que todos os acessos são legítimos, portanto autorize todos com o atalho <code>A</code> (para <em>Allow</em>).</p>
</div>
<div class="paragraph">
<p>Ao final do processo, o programa irá perguntar se você deseja salvar as informações no perfil do Nginx. Confirme com o atalho <code>S</code> (para <em>Save Changes</em>).</p>
</div>
<div class="paragraph">
<p>Temos abaixo uma execução típica do <code>aa-logprof</code> para esse cenário:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># aa-logprof
Reading log entries from /var/log/syslog.
Updating AppArmor profiles in /etc/apparmor.d.
Complain-mode changes:

Profile:    /usr/sbin/nginx
Capability: dac_override
Severity:   9

 [1 - capability dac_override,]
(A)llow / [(D)eny] / (I)gnore / Audi(t) / Abo(r)t / (F)inish
Adding capability dac_override, to profile.

Profile:  /usr/sbin/nginx
Path:     /data/www/safe/index.html
New Mode: r
Severity: unknown

 [1 - /data/www/safe/index.html r,]
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding /data/www/safe/index.html r, to profile.

Profile:  /usr/sbin/nginx
Path:     /etc/ssl/openssl.cnf
New Mode: r
Severity: 2

 [1 - #include &lt;abstractions/openssl&gt;]
  2 - #include &lt;abstractions/ssl_keys&gt;
  3 - /etc/ssl/openssl.cnf r,
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding #include &lt;abstractions/openssl&gt; to profile.

Profile:  /usr/sbin/nginx
Path:     /usr/share/nginx/modules-available/mod-http-dav-ext.conf
New Mode: r
Severity: unknown

 [1 - /usr/share/nginx/modules-available/mod-http-dav-ext.conf r,]
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding /usr/share/nginx/modules-available/mod-http-dav-ext.conf r, to profile.

Profile:  /usr/sbin/nginx
Path:     /usr/lib/nginx/modules/ngx_http_auth_pam_module.so
Old Mode: r
New Mode: mr
Severity: unknown

 [1 - #include &lt;abstractions/ubuntu-browsers.d/plugins-common&gt;]
  2 - /{usr/,}lib{,32,64}/** mr,
  3 - /usr/lib/nginx/modules/ngx_http_auth_pam_module.so mr,
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding #include &lt;abstractions/ubuntu-browsers.d/plugins-common&gt; to profile.

Profile:  /usr/sbin/nginx
Path:     /etc/nginx/nginx.conf
New Mode: r
Severity: unknown

 [1 - /etc/nginx/nginx.conf r,]
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding /etc/nginx/nginx.conf r, to profile.

Profile:  /usr/sbin/nginx
Path:     /etc/nginx/modules-enabled/
New Mode: r
Severity: unknown

 [1 - /etc/nginx/modules-enabled/ r,]
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding /etc/nginx/modules-enabled/ r, to profile.

Profile:  /usr/sbin/nginx
Path:     /usr/share/nginx/modules-available/mod-http-auth-pam.conf
New Mode: r
Severity: unknown

 [1 - /usr/share/nginx/modules-available/mod-http-auth-pam.conf r,]
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding /usr/share/nginx/modules-available/mod-http-auth-pam.conf r, to profile.

Profile:  /usr/sbin/nginx
Path:     /var/log/nginx/access.log
New Mode: w
Severity: 8

 [1 - /var/log/nginx/access.log w,]
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding /var/log/nginx/access.log w, to profile.

Profile:  /usr/sbin/nginx
Path:     /var/log/nginx/error.log
New Mode: w
Severity: 8

 [1 - /var/log/nginx/error.log w,]
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding /var/log/nginx/error.log w, to profile.

Profile:  /usr/sbin/nginx
Path:     /usr/share/nginx/modules-available/mod-http-echo.conf
New Mode: r
Severity: unknown

 [1 - /usr/share/nginx/modules-available/mod-http-echo.conf r,]
(A)llow / [(D)eny] / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Audi(t) / Abo(r)t / (F)inish
Adding /usr/share/nginx/modules-available/mod-http-echo.conf r, to profile.

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /usr/sbin/nginx]
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
Writing updated profile for /usr/sbin/nginx.</pre>
</div>
</div>
</li>
<li>
<p>O isso fez? Confira o conteúdo do arquivo <code>/etc/apparmor.d/usr.sbin.nginx</code>:</p>
<div class="literalblock">
<div class="content">
<pre># cat /etc/apparmor.d/usr.sbin.nginx
# Last Modified: Sun Nov 18 02:48:57 2018
#include &lt;tunables/global&gt;

/usr/sbin/nginx flags=(complain) {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/openssl&gt;
  #include &lt;abstractions/ubuntu-browsers.d/plugins-common&gt;

  capability dac_override,

  /data/www/safe/index.html r,
  /etc/nginx/modules-enabled/ r,
  /etc/nginx/nginx.conf r,
  /lib/x86_64-linux-gnu/ld-*.so mr,
  /usr/sbin/nginx mr,
  /usr/share/nginx/modules-available/mod-http-auth-pam.conf r,
  /usr/share/nginx/modules-available/mod-http-dav-ext.conf r,
  /usr/share/nginx/modules-available/mod-http-echo.conf r,
  /var/log/nginx/access.log w,
  /var/log/nginx/error.log w,

}</pre>
</div>
</div>
<div class="paragraph">
<p>Cada um dos acessos autorizados foi adicionado em uma linha do arquivo acima, com a permissão correspondente ao final. Observe que <strong>qualquer</strong> tipo de acesso que não conste do arquivo acima será negado pelo AppArmor ao ativarmos o modo <em>enforcing</em> do sistema.</p>
</div>
</li>
<li>
<p>Tudo pronto&#8230;&#8203; certo? Coloque o Nginx em modo <em>enforce</em>:</p>
<div class="literalblock">
<div class="content">
<pre># aa-enforce nginx
Setting /usr/sbin/nginx to enforce mode.</pre>
</div>
</div>
<div class="paragraph">
<p>E reinicie ambos AppArmor e Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl reload apparmor</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nginx
Job for nginx.service failed because the control process exited with error code.
See "systemctl status nginx.service" and "journalctl -xe" for details.</pre>
</div>
</div>
<div class="paragraph">
<p>OOPS! Temos um problema. Confira o que aconteceu verificando o log de erros do Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># tail /var/log/nginx/error.log -n1
2018/11/18 02:56:10 [emerg] 1850#1850: open() "/etc/nginx/modules-enabled/50-mod-http-geoip.conf" failed (13: Permission denied) in /etc/nginx/nginx.conf:4</pre>
</div>
</div>
<div class="paragraph">
<p>Uhm, aparentemente o Nginx precisa acessar o arquivo <code>/etc/nginx/modules-enabled/50-mod-http-geoip.conf</code>, mas essa permissão não consta do seu perfil. Note que esse arquivo é um <em>symlink</em> para o <code>/usr/share/nginx/modules-available/mod-http-geoip.conf</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls -ld /etc/nginx/modules-enabled/50-mod-http-geoip.conf
lrwxrwxrwx 1 root root 54 nov 18 02:31 /etc/nginx/modules-enabled/50-mod-http-geoip.conf -&gt; /usr/share/nginx/modules-available/mod-http-geoip.conf</pre>
</div>
</div>
<div class="paragraph">
<p>Sem problema, vamos adicionar essa permissão:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># sed -i '/\/usr\/share\/nginx\/modules-available\/mod-http-echo.conf/a\  \/usr\/share\/nginx\/modules-available\/mod-http-geoip.conf r,' /etc/apparmor.d/usr.sbin.nginx</pre>
</div>
</div>
<div class="paragraph">
<p>Veja como ficou o arquivo, agora:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat /etc/apparmor.d/usr.sbin.nginx
# Last Modified: Sun Nov 18 02:48:57 2018
#include &lt;tunables/global&gt;

/usr/sbin/nginx {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/openssl&gt;
  #include &lt;abstractions/ubuntu-browsers.d/plugins-common&gt;

  capability dac_override,

  /data/www/safe/index.html r,
  /etc/nginx/modules-enabled/ r,
  /etc/nginx/nginx.conf r,
  /lib/x86_64-linux-gnu/ld-*.so mr,
  /usr/sbin/nginx mr,
  /usr/share/nginx/modules-available/mod-http-auth-pam.conf r,
  /usr/share/nginx/modules-available/mod-http-dav-ext.conf r,
  /usr/share/nginx/modules-available/mod-http-echo.conf r,
  /usr/share/nginx/modules-available/mod-http-geoip.conf r,
  /var/log/nginx/access.log w,
  /var/log/nginx/error.log w,

}</pre>
</div>
</div>
<div class="paragraph">
<p>Agora sim! Recarregue o AppArmor e reinicie o Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl reload apparmor</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nginx
Job for nginx.service failed because the control process exited with error code.
See "systemctl status nginx.service" and "journalctl -xe" for details.</pre>
</div>
</div>
<div class="paragraph">
<p>Oh não&#8230;&#8203; o que foi dessa vez? Vamos ver:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># tail /var/log/nginx/error.log -n1
2018/11/18 03:03:04 [emerg] 1976#1976: open() "/etc/nginx/modules-enabled/50-mod-http-image-filter.conf" failed (13:Permission denied) in /etc/nginx/nginx.conf:4</pre>
</div>
</div>
<div class="paragraph">
<p>Podemos adicionar essa permissão, mas já posso lhe adiantar que teremos OUTRO erro logo a seguir. Que coisa, não?</p>
</div>
</li>
<li>
<p>Após algum tempo em tentativas e erros, chegamos a um arquivo de perfil que funciona para o nosso caso. Edite o arquivo <code>/etc/apparmor.d/usr.sbin.nginx</code> e deixe seu conteúdo <strong>exatamente</strong> como o que se segue:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Last Modified: Sun Nov 18 03:32:21 2018
#include &lt;tunables/global&gt;

/usr/sbin/nginx {
  #include &lt;abstractions/apache2-common&gt;
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;
  #include &lt;abstractions/openssl&gt;
  #include &lt;abstractions/ubuntu-browsers.d/plugins-common&gt;

  capability dac_override,
  capability setgid,
  capability setuid,

  deny /data/www/unsafe/* r,

  /data/www/safe/* r,
  /etc/group r,
  /etc/nginx/conf.d/ r,
  /etc/nginx/conf.d/apparmor.conf r,
  /etc/nginx/mime.types r,
  /etc/nginx/modules-enabled/ r,
  /etc/nginx/nginx.conf r,
  /etc/nginx/sites-available/default r,
  /etc/nginx/sites-enabled/ r,
  /etc/nsswitch.conf r,
  /etc/passwd r,
  /etc/ssl/openssl.cnf r,
  /lib/x86_64-linux-gnu/ld-*.so mr,
  /run/nginx.pid rw,
  /usr/sbin/nginx mr,
  /usr/share/nginx/modules-available/* r,
  /var/log/nginx/access.log w,
  /var/log/nginx/error.log w,

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note que há um número significativo de diferenças entre o arquivo acima e o que tínhamos originalmente&#8201;&#8212;&#8201;você pode imaginar o tempo necessário para construir um perfil desse tipo. E observe que estamos trabalhando aqui no perfil de UMA única aplicação, o servidor web Nginx. Imagine se tivéssemos um número maior de programas, ou requerimentos de acesso mais complexos.</p>
</div>
<div class="paragraph">
<p>Observe ainda que estamos detalhando políticas expressas de acesso para as pastas <em>safe</em> e <em>unsafe</em>:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Na linha <code>/data/www/safe/* r,</code>, o acesso de leitura a todos os arquivos dentro da pasta <em>safe</em> é autorizado ao Nginx.</p>
</li>
<li>
<p>Já na linha <code>deny /data/www/unsafe/* r,</code>, o mesmo tipo de acesso na pasta <em>unsafe</em> é negado.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Enfim, reescrito o perfil acima, recarregue o AppArmor e reinicie o Nginx:</p>
<div class="literalblock">
<div class="content">
<pre># systemctl reload apparmor</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># systemctl restart nginx</pre>
</div>
</div>
<div class="paragraph">
<p>Sucesso! Vamos ver se nossa proteção funcionou: retorne ao navegador e carregue a URL <code><a href="http://10.0.42.12:8080/safe/" class="bare">http://10.0.42.12:8080/safe/</a></code>:</p>
</div>
<div id="img-apparmor4" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/apparmor4.png" alt="apparmor4">
</div>
<div class="title">Figure 69. Acesso autorizado à área safe</div>
</div>
<div class="paragraph">
<p>Perfeito, o acesso foi autorizado. E quanto a <code><a href="http://10.0.42.12:8080/unsafe/" class="bare">http://10.0.42.12:8080/unsafe/</a></code>?</p>
</div>
<div id="img-apparmor5" class="imageblock" style="text-align: center">
<div class="content">
<img src="./img/apparmor5.png" alt="apparmor5">
</div>
<div class="title">Figure 70. Acesso negado à área unsafe</div>
</div>
<div class="paragraph">
<p>Como esperado, o acesso foi negado pelo AppArmor. Observe a mensagem de erro no log do Nginx:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># tail -f -n0 /var/log/nginx/error.log
2018/11/18 03:36:10 [error] 4035#4035: *2 open() "/data/www/unsafe/index.html" failed (13: Permission denied), client: 10.0.42.254, server: , request: "GET /unsafe/ HTTP/1.1", host: "10.0.42.12:8080"</pre>
</div>
</div>
</li>
<li>
<p>Como objetivado, conseguimos usar o AppArmor para construir um perfil de segurança específico para o servidor web Nginx, e testar esse perfil com sucesso. Fica claro, também, que a construção de perfis por meio de ferramentas MAC (como o AppArmor ou o SELinux), apesar de se apresentar como uma ferramenta muito poderosa, também traz consigo um custo administrativo bastante alto.</p>
<div class="paragraph">
<p>Leve isso em consideração ao implantar esquemas de segurança em seus servidores. É possível que haja um ganho de segurança significativo por meio da construção de perfis de segurança, mas convém analisar a criticidade dos sistemas-alvo para determinar se o custo administrativo compensa, de fato, o risco que se incorre com a falta da proteção.</p>
</div>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-10-17 11:06:58 -03
</div>
</div>
</body>
</html>